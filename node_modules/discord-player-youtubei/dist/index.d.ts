import { Track, BaseExtractor, ExtractorStreamable, SearchQueryType, ExtractorSearchContext, ExtractorInfo, Playlist, GuildQueueHistory } from 'discord-player';
import Innertube, { OAuth2Tokens } from 'youtubei.js';
import { InnerTubeClient, DownloadOptions, InnerTubeConfig } from 'youtubei.js/dist/src/types';
import { Readable } from 'node:stream';
import { Video } from 'youtubei.js/dist/src/parser/nodes';
import { AsyncLocalStorage } from 'node:async_hooks';
import { PuppeteerLaunchOptions } from 'puppeteer';
import * as youtubei_js_agnostic from 'youtubei.js/agnostic';
import { VideoInfo } from 'youtubei.js/dist/src/parser/youtube';
import { YTNode } from 'youtubei.js/dist/src/parser/helpers';
import { Author } from 'youtubei.js/dist/src/parser/misc';
import { ChatAction } from 'youtubei.js/dist/src/parser/youtube/LiveChat';

declare class LiveChatAuthor {
    username: string;
    url: string;
    thumbnail: string;
    verifiedChannel: boolean;
    verifiedArtist: boolean;
    isMod: boolean;
    id: string;
    raw: Author;
    constructor(author: Author);
}

declare enum ChatMessageType {
    Regular = 1,
    Premium = 2,
    PremiumSticker = 3
}
declare class LiveChatMessage {
    author: LiveChatAuthor;
    type: ChatMessageType;
    content?: string;
    timestamp: number;
    constructor(chatUpdate: YTNode, type: ChatMessageType);
}

type LiveChatReturnType = ReturnType<typeof VideoInfo['prototype']['getLiveChat']>;
declare const LiveChatEvents: {
    readonly MessageCreate: "messageCreate";
    readonly StreamEnd: "streamEnd";
};
type LiveChatEvents = typeof LiveChatEvents[keyof typeof LiveChatEvents];
interface LiveChatEventsData {
    [LiveChatEvents.MessageCreate]: (message: LiveChatMessage) => any;
    [LiveChatEvents.StreamEnd]: () => any;
}
declare class LiveChat {
    #private;
    chat: ReturnType<typeof VideoInfo['prototype']['getLiveChat']>;
    chatUpdateHandler: (action: ChatAction) => void;
    constructor(chat: LiveChatReturnType);
    on<T extends LiveChatEvents>(event: T, handler: LiveChatEventsData[T]): void;
    destroy(): void;
}

declare function getLiveChat(videoUrl: string, ext?: YoutubeiExtractor): Promise<LiveChat | null>;

interface GeneratorReturnData {
    visitorData: string;
    poToken: string;
}
interface GeneratorOptions {
    puppeteerOptions?: Omit<PuppeteerLaunchOptions, "headless">;
    timeout?: number;
    embeddedVideoUrl?: string;
    skipPuppeteerCheck?: boolean;
}
declare function generateTrustedToken(options?: GeneratorOptions): Promise<GeneratorReturnData>;

interface IGeneratorOptions {
    interval?: number;
    onGenerate: (data: GeneratorReturnData) => any;
    generateInstant?: boolean;
    onError: (e: any) => any;
}
type IntervalGeneratorOptions = IGeneratorOptions & Omit<GeneratorOptions, "skipPuppeteerCheck">;
declare function generateTrustedTokenInterval(options: IntervalGeneratorOptions): Promise<{
    background: () => NodeJS.Timeout;
    foreground: () => NodeJS.Timeout;
    stop: () => void;
}>;

interface StreamOptions {
    useClient?: InnerTubeClient;
    highWaterMark?: number;
}
interface RefreshInnertubeOptions {
    filePath: string;
    interval?: number;
}
type TrustedTokenConfig = GeneratorReturnData;
interface YoutubeiOptions {
    authentication?: string;
    overrideDownloadOptions?: DownloadOptions;
    createStream?: (q: Track, extractor: BaseExtractor<object>) => Promise<string | Readable>;
    signOutOnDeactive?: boolean;
    streamOptions?: StreamOptions;
    overrideBridgeMode?: "ytmusic" | "yt";
    disablePlayer?: boolean;
    ignoreSignInErrors?: boolean;
    innertubeConfigRaw?: InnerTubeConfig;
    trustedTokens?: TrustedTokenConfig;
    cookie?: string;
}
interface AsyncTrackingContext {
    useClient: InnerTubeClient;
    highWaterMark?: number;
}
declare class YoutubeiExtractor extends BaseExtractor<YoutubeiOptions> {
    #private;
    static identifier: string;
    innerTube: Innertube;
    _stream: (q: Track, extractor: BaseExtractor<object>) => Promise<ExtractorStreamable>;
    static instance?: YoutubeiExtractor;
    priority: number;
    static ytContext: AsyncLocalStorage<AsyncTrackingContext>;
    setTrustedTokens(tokens: TrustedTokenConfig): void;
    setInnertube(tube: Innertube): void;
    static getInstance(): YoutubeiExtractor | undefined;
    setClientMode(client: InnerTubeClient): void;
    static getStreamingContext(): AsyncTrackingContext;
    activate(): Promise<void>;
    signIn(tokens: string): Promise<void>;
    deactivate(): Promise<void>;
    validate(query: string, type?: SearchQueryType | null | undefined): Promise<boolean>;
    bridge(track: Track, ext: BaseExtractor | null): Promise<ExtractorStreamable | null>;
    bridgeFromYTMusic(query: string, track: Track): Promise<ExtractorStreamable | null>;
    bridgeFromYT(query: string, track: Track): Promise<ExtractorStreamable | null>;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    buildTrack(vid: Video, context: ExtractorSearchContext, pl?: Playlist): Track<any>;
    stream(info: Track<unknown>): Promise<ExtractorStreamable>;
    getRelatedTracks(track: Track<{
        duration_ms: number;
        live: boolean;
    }>, history: GuildQueueHistory<unknown>): Promise<ExtractorInfo>;
}

declare function objectToToken(tokens: OAuth2Tokens): string;
declare function tokenToObject(token: string): OAuth2Tokens;

declare function getYoutubeiInstance(): youtubei_js_agnostic.Innertube | undefined;

declare function generateOauthTokens(): Promise<void>;

export { type AsyncTrackingContext, ChatMessageType, type GeneratorOptions, type GeneratorReturnData, type IGeneratorOptions, type IntervalGeneratorOptions, LiveChatEvents, type RefreshInnertubeOptions, type StreamOptions, type TrustedTokenConfig, YoutubeiExtractor, type YoutubeiOptions, generateOauthTokens, generateTrustedToken, generateTrustedTokenInterval, getLiveChat, getYoutubeiInstance, objectToToken, tokenToObject };
