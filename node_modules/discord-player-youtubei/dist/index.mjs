// lib/index.ts
import Innertube3 from "youtubei.js";

// lib/common/tokenUtils.ts
function objectToToken(tokens) {
  return Object.entries(tokens).map(([k, v]) => `${k}=${v instanceof Date ? v.toISOString() : v}`).join("; ");
}
function tokenToObject(token) {
  if (!token.includes("; ") || !token.includes("="))
    throw new Error(
      "Error: this is not a valid authentication token. Make sure you are putting the entire string instead of just what's behind access_token="
    );
  const kvPair = token.split("; ");
  const validKeys = [
    "access_token",
    "expiry_date",
    "expires_in",
    "refresh_token",
    "scope",
    "token_type",
    "client"
  ];
  let finalObject = {};
  for (let kv of kvPair) {
    const [key, value] = kv.split("=");
    if (!validKeys.includes(key)) continue;
    finalObject[key] = Number.isNaN(Number(value)) ? value : Number(value);
  }
  const requiredKeys = ["access_token", "expiry_date", "refresh_token"];
  for (const key of requiredKeys) {
    if (!(key in finalObject))
      throw new Error(
        `Error: Invalid authentication keys. Missing the required key ${key}. Make sure you are putting the entire string instead of just what's behind access_token=`
      );
  }
  return finalObject;
}

// lib/Extractor/Youtube.ts
import {
  Util,
  Track,
  Playlist,
  QueryType,
  BaseExtractor
} from "discord-player";
import Innertube2, { UniversalCache, YTNodes as YTNodes2 } from "youtubei.js";

// lib/common/createNativeReadable.ts
import { Readable } from "stream";
import { Constants, Utils } from "youtubei.js";
var TEN_MB = 1048576 * 10;
function createNativeReadable(url, size, innertube, videoInfo) {
  let start = 0;
  let end = Math.min(size, TEN_MB);
  let isEnded = false;
  let abortController;
  return new Readable({
    async read() {
      if (isEnded) return;
      if (end >= size) {
        isEnded = true;
        end = size;
      }
      abortController = new AbortController();
      const fUrl = `${url}&cpn=${videoInfo.cpn}&range=${start}-${end || ""}`;
      const getReq = await innertube.session.http.fetch_function(fUrl, {
        headers: Constants.STREAM_HEADERS,
        signal: abortController.signal
      });
      if (!getReq.body)
        throw new Error(`Download of video failed at ${start / size * 100}%`);
      for await (const chunk of Utils.streamToIterable(getReq.body)) {
        this.push(Buffer.from(chunk));
      }
      if (isEnded) {
        this.push(null);
      }
      start = end + 1;
      end += TEN_MB;
    },
    destroy(err) {
      if (abortController) abortController.abort(err);
    }
  });
}

// lib/common/generateYTStream.ts
var DEFAULT_DOWNLOAD_OPTIONS = {
  quality: "best",
  format: "mp4",
  type: "audio"
};
async function streamFromYT(query, innerTube, options = {
  overrideDownloadOptions: DEFAULT_DOWNLOAD_OPTIONS
}) {
  const context = YoutubeiExtractor.getStreamingContext();
  let id = new URL(query.url).searchParams.get("v");
  if (!id) id = query.url.split("/").at(-1)?.split("?").at(0);
  const videoInfo = await innerTube.getBasicInfo(id, context.useClient);
  if (videoInfo.basic_info.is_live)
    return videoInfo.streaming_data?.hls_manifest_url;
  let format = videoInfo.chooseFormat(
    options.overrideDownloadOptions || DEFAULT_DOWNLOAD_OPTIONS
  );
  if (["IOS", "ANDROID", "TV_EMBEDDED"].includes(
    context.useClient
  )) {
    if (!format.url || !format.content_length)
      throw new Error("Not matching URL for this format found");
    return createNativeReadable(
      format.url,
      format.content_length,
      innerTube,
      videoInfo
    );
  } else {
    format.url = format.decipher(innerTube.session.player);
    if (!format.content_length)
      throw new Error("Not matching URL for this format found");
    return createNativeReadable(
      format.url,
      format.content_length,
      innerTube,
      videoInfo
    );
  }
}

// lib/Extractor/Youtube.ts
import { AsyncLocalStorage } from "node:async_hooks";

// lib/utils/index.ts
import { Platform } from "youtubei.js";

// lib/utils/live/LiveChat.ts
import { TypedEmitter } from "tiny-typed-emitter";

// lib/utils/live/LiveChatAuthor.ts
var LiveChatAuthor = class {
  username;
  url;
  thumbnail;
  verifiedChannel;
  verifiedArtist;
  isMod;
  id;
  raw;
  constructor(author) {
    this.username = author.name;
    this.url = author.url;
    this.thumbnail = author.best_thumbnail?.url ?? author.thumbnails[0].url;
    this.verifiedChannel = author.is_verified || false;
    this.verifiedArtist = author.is_verified_artist || false;
    this.isMod = author.is_moderator || false;
    this.id = author.id;
    this.raw = author;
  }
};

// lib/utils/live/LiveChatMessage.ts
var ChatMessageType = /* @__PURE__ */ ((ChatMessageType2) => {
  ChatMessageType2[ChatMessageType2["Regular"] = 1] = "Regular";
  ChatMessageType2[ChatMessageType2["Premium"] = 2] = "Premium";
  ChatMessageType2[ChatMessageType2["PremiumSticker"] = 3] = "PremiumSticker";
  return ChatMessageType2;
})(ChatMessageType || {});
var LiveChatMessage = class {
  author;
  type;
  content;
  timestamp;
  constructor(chatUpdate, type) {
    this.author = new LiveChatAuthor(
      chatUpdate.author
    );
    this.type = type;
    this.timestamp = chatUpdate.timestamp || Date.now();
    if (chatUpdate.type === "LiveChatTextMessage" || chatUpdate.type === "LiveChatPaidMessage") {
      this.content = chatUpdate.message.toString();
    }
  }
};

// lib/utils/live/LiveChat.ts
import { YTNodes } from "youtubei.js";
var LiveChatEvents = {
  MessageCreate: "messageCreate",
  StreamEnd: "streamEnd"
};
var LiveChat = class {
  chat;
  #eventEmitter = new TypedEmitter();
  #hasListener = {
    [LiveChatEvents.MessageCreate]: false,
    [LiveChatEvents.StreamEnd]: false
  };
  // this is scuffed but i cant access 'this' inside other non-arrow functions
  chatUpdateHandler = (action) => {
    if (action.is(YTNodes.AddChatItemAction)) {
      const { item } = action.as(YTNodes.AddChatItemAction);
      switch (item.type) {
        case "LiveChatTextMessage": {
          this.#eventEmitter.emit(
            LiveChatEvents.MessageCreate,
            new LiveChatMessage(item, 1 /* Regular */)
          );
          break;
        }
        case "LiveChatPaidMessage": {
          this.#eventEmitter.emit(
            LiveChatEvents.MessageCreate,
            new LiveChatMessage(item, 2 /* Premium */)
          );
          break;
        }
        case "LiveChatPaidSticker": {
          this.#eventEmitter.emit(
            LiveChatEvents.MessageCreate,
            new LiveChatMessage(item, 3 /* PremiumSticker */)
          );
          break;
        }
        default: {
          break;
        }
      }
    }
  };
  #chatEndHandler = () => {
    this.#eventEmitter.emit(LiveChatEvents.StreamEnd);
  };
  constructor(chat) {
    this.chat = chat;
  }
  on(event, handler) {
    switch (event) {
      case LiveChatEvents.MessageCreate: {
        if (!this.#hasListener[LiveChatEvents.MessageCreate]) {
          this.chat.on("chat-update", this.chatUpdateHandler);
          this.#hasListener[LiveChatEvents.MessageCreate] = true;
        }
        this.#eventEmitter.on(event, handler);
      }
      case LiveChatEvents.StreamEnd: {
        if (!this.#hasListener[LiveChatEvents.StreamEnd]) {
          this.chat.on("end", this.#chatEndHandler);
        }
      }
    }
  }
  destroy() {
    if (this.#hasListener[LiveChatEvents.MessageCreate])
      this.chat.off("chat-update", this.chatUpdateHandler);
    if (this.#hasListener[LiveChatEvents.StreamEnd])
      this.chat.off("end", this.#chatEndHandler);
    this.chat.stop();
  }
};

// lib/utils/live/getLiveChat.ts
var YOUTUBE_URL_REGEX = /^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube(?:-nocookie)?\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|live\/|v\/)?)([\w\-]+)(\S+)?$/;
function parseYoutubeVideo(videoUrl) {
  if (!YOUTUBE_URL_REGEX.test(videoUrl))
    throw new Error("This is not a valid video URL");
  const idExtractor = new URL(videoUrl);
  let id = idExtractor.searchParams.get("v");
  if (!id) id = videoUrl.split("/").at(-1)?.split("?").at(0);
  return id;
}
async function getLiveChat(videoUrl, ext) {
  const instance = YoutubeiExtractor.instance ?? ext;
  if (!instance)
    throw new Error("Invoked getLiveChat before player.extractors.register");
  const innertube = instance.innerTube;
  const videoId = parseYoutubeVideo(videoUrl);
  const info = await innertube.getInfo(videoId);
  if (!info.basic_info.is_live) return null;
  const chat = info.getLiveChat();
  chat.start();
  return new LiveChat(chat);
}

// lib/utils/downloader/index.ts
import Innertube from "youtubei.js";
var Errors = {
  InvalidURL: new Error("Invalid URL: Expected a URL got a string instead"),
  InvalidYTURL: new Error(
    "Invalid YouTube URL: Expected a YouTube URL but got something else"
  ),
  NoDownload: new Error("Unable to download video")
};
var YOUTUBE_REGEX = /^(https:\/\/(www\.)?youtu(\.be\/[A-Za-z0-9]{11}(.+)?|be\.com\/watch\?v=[A-Za-z0-9]{11}(&.+)?))/gm;
function validateURL(url) {
  try {
    return new URL(url);
  } catch {
    return false;
  }
}
async function stream(url, skipStream, options, tube, client) {
  const urlObj = validateURL(url);
  if (!urlObj) throw Errors.InvalidURL;
  if (!YOUTUBE_REGEX.test(url)) throw Errors.InvalidYTURL;
  const vidId = urlObj.searchParams.get("v") || url.split("/").at(-1).split("?").at(0);
  const yt = tube || await Innertube.create({
    retrieve_player: false
  });
  const info = await yt.getBasicInfo(vidId, client);
  let fmt = info.chooseFormat(
    options || {
      format: "mp4",
      quality: "best",
      type: "audio"
    }
  );
  if (client && !["IOS", "ANDROID"].includes(client))
    fmt.url = fmt.decipher(yt.session.player);
  if (!fmt.url || !fmt.content_length) throw Errors.NoDownload;
  const downloadedUrl = fmt.url;
  const stream2 = skipStream ? null : createNativeReadable(downloadedUrl, fmt.content_length, yt, info);
  return {
    basicInfo: info.basic_info,
    formatInfo: fmt,
    stream: stream2,
    downloadedUrl
  };
}

// lib/utils/index.ts
function defaultPeerUrlBuilder(url, id) {
  return `${url}/${id}`;
}
function defaultFetch(_player, input, init, proxy) {
  let requestInit = {
    ...init
  };
  if (proxy) {
    requestInit.dispatcher = proxy;
    return Platform.shim.fetch(input, requestInit);
  } else {
    return Platform.shim.fetch(input, requestInit);
  }
}

// lib/common/peerDownloader.ts
function peerDownloader(id, peer) {
  const peerUrl = typeof peer.parse === "function" ? peer.parse(peer.url, id) : defaultPeerUrlBuilder(peer.url, id);
  return peerUrl;
}

// lib/common/extractVideoID.ts
function extractVideoId(vid) {
  const YOUTUBE_REGEX2 = /^https:\/\/(www\.)?youtu(\.be\/.{11}(.+)?|be\.com\/watch\?v=.{11}(&.+)?)/;
  if (!YOUTUBE_REGEX2.test(vid)) throw new Error("Invalid youtube url");
  let id = new URL(vid).searchParams.get("v");
  if (!id) id = vid.split("/").at(-1)?.split("?").at(0);
  return id;
}

// lib/ServerAbr/CreateServerAbrStream.ts
import { PassThrough } from "node:stream";
async function getGoogleVideo() {
  try {
    return await import("googlevideo");
  } catch {
    throw new Error(
      "Unable to import GoogleVideo. Install it by running 'npm install googlevideo'"
    );
  }
}
async function createServerAbrStream(track, innertube, ext) {
  ext.context.player.debug("[YOUTUBE] Attempting to use Sabr for streaming");
  const isTrackCached = track.raw?.formats && Date.now() - track.raw?.formats.executedAt < 36e5;
  const { GoogleVideo } = await getGoogleVideo();
  if (!innertube.session.po_token)
    throw new Error("An PoToken must be present to use sabr stream");
  if (ext.options.streamOptions?.useClient !== "WEB")
    throw new Error("Sabr streaming only works on WEB client");
  let serverAbrStreamingUrl;
  let videoPlaybackUstreamerConfig;
  let format;
  let durationMs;
  if (isTrackCached) {
    const trackData = track.raw?.formats;
    serverAbrStreamingUrl = trackData.sabrUrl;
    videoPlaybackUstreamerConfig = trackData.uStreamConfig;
    format = trackData.fmt;
    durationMs = trackData.durationMs;
  } else {
    const videoId = extractVideoId(track.url);
    const basicInfo = await innertube.getBasicInfo(videoId);
    format = basicInfo.chooseFormat({
      quality: "best",
      format: "webm",
      type: "audio"
    });
    durationMs = (basicInfo.basic_info.duration ?? 0) * 1e3;
    serverAbrStreamingUrl = innertube.session.player?.decipher(
      basicInfo.page[0].streaming_data?.server_abr_streaming_url
    );
    videoPlaybackUstreamerConfig = basicInfo.page[0].player_config?.media_common_config.media_ustreamer_request_config?.video_playback_ustreamer_config;
  }
  const selectedFormat = {
    itag: format.itag,
    lastModified: format.last_modified_ms,
    xtags: format.xtags
  };
  if (!serverAbrStreamingUrl)
    throw new Error("Unable to find the streaming url for server abr");
  if (!videoPlaybackUstreamerConfig)
    throw new Error(
      "Unable to find UstreamerConfig which is required for Sabr"
    );
  const sabrStream = new GoogleVideo.ServerAbrStream({
    fetch: innertube.session.http.fetch_function,
    serverAbrStreamingUrl,
    poToken: innertube.session.po_token,
    durationMs,
    videoPlaybackUstreamerConfig
  });
  const audioStream = new PassThrough();
  function serverAbrDataHandler(streamData) {
    const format2 = streamData.initializedFormats[0];
    if (!format2) return;
    const chunks = format2.mediaChunks;
    if (!chunks || chunks.length === 0) return;
    for (const chunk of chunks) {
      audioStream.write(chunk);
    }
  }
  sabrStream.on("data", serverAbrDataHandler);
  sabrStream.on("error", (message) => {
    console.log("[SERVER ABR STREAM ERR]");
    console.error(message);
  });
  await sabrStream.init({
    audioFormats: [selectedFormat],
    videoFormats: [],
    clientAbrState: {
      enabledTrackTypesBitfield: 1,
      playerTimeMs: 0
    }
  });
  audioStream.on("end", () => {
  });
  return audioStream;
}

// lib/token/tokenGenerator.ts
import { JSDOM } from "jsdom";
import { BG } from "bgutils-js";
async function generateToken(innertube) {
  const requestKey = "O43z0dpjhgX20SCx4KAo";
  const visitorData = innertube.session.context.client.visitorData;
  if (!visitorData) throw new Error("Could not get visitor data");
  const bgConfig = {
    fetch: (input, init) => fetch(input, init),
    globalObj: globalThis,
    identifier: visitorData,
    requestKey
  };
  const dom = new JSDOM();
  Object.assign(globalThis, {
    window: dom.window,
    document: dom.window.document
  });
  const bgChallenge = await BG.Challenge.create(bgConfig);
  if (!bgChallenge) throw new Error("Could not get challenge");
  const interpreterJavascript = bgChallenge.interpreterJavascript.privateDoNotAccessOrElseSafeScriptWrappedValue;
  if (interpreterJavascript) {
    new Function(interpreterJavascript)();
  } else throw new Error("Could not load VM");
  const poTokenResult = {
    ...await BG.PoToken.generate({
      program: bgChallenge.program,
      globalName: bgChallenge.globalName,
      bgConfig
    }),
    visitorData
  };
  try {
    globalThis.document.close();
  } catch {
  }
  delete globalThis.window;
  delete globalThis.document;
  return poTokenResult;
}

// lib/Extractor/Youtube.ts
var validPathDomains = /^https?:\/\/(youtu\.be\/|(www\.)?youtube\.com\/(embed|v|shorts)\/)/;
var validQueryDomains = /* @__PURE__ */ new Set([
  "youtube.com",
  "www.youtube.com",
  "m.youtube.com",
  "music.youtube.com",
  "gaming.youtube.com"
]);
var idRegex = /^[a-zA-Z0-9-_]{11}$/;
var YoutubeiExtractor = class _YoutubeiExtractor extends BaseExtractor {
  static identifier = "com.retrouser955.discord-player.discord-player-youtubei";
  innerTube;
  _stream;
  static instance;
  priority = 2;
  static ytContext = new AsyncLocalStorage();
  interval;
  setInnertube(tube) {
    this.innerTube = tube;
  }
  static getInstance() {
    return this.instance;
  }
  setClientMode(client) {
    if (!this.options.streamOptions) this.options.streamOptions = {};
    this.options.streamOptions.useClient = client;
  }
  async #createWithToken() {
    const token = await generateToken(this.innerTube);
    this.innerTube = await Innertube2.create({
      retrieve_player: this.options.disablePlayer === true ? false : true,
      ...this.options.innertubeConfigRaw,
      cookie: this.options.cookie,
      cache: new UniversalCache(false),
      generate_session_locally: true,
      visitor_data: token.visitorData,
      po_token: token.poToken,
      fetch: (input, init) => defaultFetch(this.context.player, input, init, this.options.proxy)
    });
  }
  static getStreamingContext() {
    const ctx = _YoutubeiExtractor.ytContext.getStore();
    if (!ctx) throw new Error("INVALID INVOKCATION");
    return ctx;
  }
  async activate() {
    this.protocols = ["ytsearch", "youtube"];
    const INNERTUBE_OPTIONS = {
      retrieve_player: this.options.disablePlayer === true ? false : true,
      ...this.options.innertubeConfigRaw,
      cookie: this.options.cookie
    };
    this.innerTube = await Innertube2.create({
      ...INNERTUBE_OPTIONS,
      fetch: (input, init) => defaultFetch(this.context.player, input, init, this.options.proxy),
      cache: this.options.generateWithPoToken ? new UniversalCache(false) : void 0,
      // OVERRIDE AS STREAMING DOES NOT WORK WITH LOCALLY GENERATED TOKENS
      generate_session_locally: false
    });
    if (this.options.generateWithPoToken) {
      await this.#createWithToken();
      this.interval = setInterval(this.#createWithToken, 6048e5).unref();
    }
    if (typeof this.options.createStream === "function") {
      this._stream = this.options.createStream;
    } else {
      this._stream = (q, _) => {
        return _YoutubeiExtractor.ytContext.run(
          {
            useClient: this.options.streamOptions?.useClient ?? "IOS",
            highWaterMark: this.options.streamOptions?.highWaterMark
          },
          async () => {
            if (this.options.peers && this.options.peers.length > 0) {
              return peerDownloader(
                extractVideoId(q.url),
                this.options.peers[Math.round(Math.random() * (this.options.peers.length - 1))]
              );
            }
            if (this.options.useServerAbrStream) {
              return createServerAbrStream(q, this.innerTube, this);
            }
            return streamFromYT(q, this.innerTube, {
              overrideDownloadOptions: this.options.overrideDownloadOptions
            });
          }
        );
      };
    }
    _YoutubeiExtractor.instance = this;
    if (this.options.authentication) {
      try {
        await this.signIn(this.options.authentication);
        const info = await this.innerTube.account.getInfo();
        this.context.player.debug(
          info.contents?.contents ? `Signed into YouTube using the name: ${info.contents.contents[0].is(YTNodes2.AccountItem) ? info.contents.contents[0].as(YTNodes2.AccountItem).account_name.text ?? "UNKNOWN ACCOUNT" : "UNKNOWN ACCOUNT"}` : `Signed into YouTube using the client name: ${this.innerTube.session.client_name}@${this.innerTube.session.client_version}`
        );
      } catch (error) {
        if (this.options.ignoreSignInErrors)
          process.emitWarning(`Unable to sign into YouTube

${error}`);
        else throw error;
      }
    }
  }
  async signIn(tokens) {
    const tkn = tokenToObject(tokens);
    await this.innerTube.session.signIn(tkn);
  }
  async deactivate() {
    this.protocols = [];
    if (this.interval) clearInterval(this.interval);
    if (this.options.signOutOnDeactive && this.innerTube.session.logged_in)
      await this.innerTube.session.signOut();
  }
  async validate(query, type) {
    if (typeof query !== "string") return false;
    return [
      QueryType.YOUTUBE,
      QueryType.YOUTUBE_PLAYLIST,
      QueryType.YOUTUBE_SEARCH,
      QueryType.YOUTUBE_VIDEO,
      QueryType.AUTO,
      QueryType.AUTO_SEARCH
    ].some((r) => r === type);
  }
  async bridge(track, ext) {
    if (ext?.identifier === this.identifier) return this.stream(track);
    let protocol;
    if (this.options.overrideBridgeMode) {
      if (typeof this.options.overrideBridgeMode === "string") {
        protocol = this.options.overrideBridgeMode;
      } else if (track.queryType) {
        const opts = this.options.overrideBridgeMode;
        protocol = opts[track.queryType] ?? opts.default;
      }
    }
    if (!protocol) {
      if (this.innerTube.session.logged_in) protocol = "ytmusic";
      else protocol = "yt";
    }
    const query = ext?.createBridgeQuery(track) || `${track.author} - ${track.title}${protocol === "yt" ? " (official audio)" : ""}`;
    switch (protocol) {
      case "ytmusic": {
        try {
          let stream2 = await this.bridgeFromYTMusic(query, track);
          if (!stream2) {
            this.context.player.debug(
              "Unable to bridge from Youtube music. Falling back to default behavior"
            );
            stream2 = await this.bridgeFromYT(query, track);
          }
          return stream2;
        } catch (error) {
          this.context.player.debug(
            "Unable to bridge from youtube music due to an error. Falling back to default behavior\n\n" + error
          );
          return await this.bridgeFromYT(query, track);
        }
      }
      default: {
        return await this.bridgeFromYT(query, track);
      }
    }
  }
  async bridgeFromYTMusic(query, track) {
    const musicSearch = await this.innerTube.music.search(query, {
      type: "song"
    });
    if (!musicSearch.songs) return null;
    if (!musicSearch.songs.contents || musicSearch.songs.contents.length === 0)
      return null;
    if (!musicSearch.songs.contents[0].id) return null;
    const info = await this.innerTube.music.getInfo(
      musicSearch.songs.contents[0].id
    );
    const metadata = new Track(this.context.player, {
      title: info.basic_info.title ?? "UNKNOWN TITLE",
      duration: Util.buildTimeCode(
        Util.parseMS((info.basic_info.duration || 0) * 1e3)
      ),
      author: info.basic_info.author ?? "UNKNOWN AUTHOR",
      views: info.basic_info.view_count,
      thumbnail: info.basic_info.thumbnail?.at(0)?.url,
      url: `https://youtube.com/watch?v=${info.basic_info.id}&dpymeta=ytmusic`,
      source: "youtube",
      queryType: "youtubeVideo",
      live: false
    });
    track.setMetadata(metadata);
    let format = info.chooseFormat({
      type: "audio",
      quality: "best",
      format: "mp4"
    });
    format.url = format.decipher(this.innerTube.session.player);
    return createNativeReadable(
      format.url,
      format.content_length,
      this.innerTube,
      info
    );
  }
  async bridgeFromYT(query, track) {
    const youtubeTrack = await this.handle(query, {
      type: QueryType.YOUTUBE_SEARCH,
      requestedBy: track.requestedBy
    });
    if (youtubeTrack.tracks.length === 0) return null;
    track.setMetadata({
      bridge: youtubeTrack.tracks[0]
    });
    return this.stream(youtubeTrack.tracks[0]);
  }
  async handle(query, context) {
    if (context.protocol === "ytsearch")
      context.type = QueryType.YOUTUBE_SEARCH;
    query = query.includes("youtube.com") ? query.replace(/(m(usic)?|gaming)\./, "") : query;
    switch (context.type) {
      case QueryType.YOUTUBE_PLAYLIST: {
        let playlist;
        const playlistUrl = new URL(query);
        const plId = playlistUrl.searchParams.get("list");
        const videoId = playlistUrl.searchParams.get("v");
        if (videoId && plId) {
          const endpoint = new YTNodes2.NavigationEndpoint({
            continuationCommand: {
              videoId,
              playlistId: plId
            }
          });
          const mixVidInfo = await this.innerTube.getInfo(endpoint);
          if (!mixVidInfo?.playlist)
            throw new Error("Mix playlist not found or invalid");
          if (this.options.slicePlaylist && mixVidInfo?.playlist?.current_index)
            mixVidInfo.playlist.contents.splice(
              0,
              mixVidInfo.playlist.current_index
            );
          playlist = {
            info: {
              title: mixVidInfo.playlist.title?.toString() ?? "UNKNOWN TITLE",
              thumbnails: mixVidInfo.playlist.contents?.[0]?.thumbnail ?? [],
              description: "",
              author: {
                name: mixVidInfo.playlist.author?.toString() ?? "UNKNOWN AUTHOR",
                url: ""
              }
            },
            channels: [
              {
                author: {
                  name: mixVidInfo.playlist.author?.toString() ?? "UNKNOWN AUTHOR",
                  url: ""
                }
              }
            ],
            videos: mixVidInfo.playlist.contents.map((item) => ({
              type: "PlaylistVideo",
              id: item.video_id,
              title: { text: item.title?.toString() ?? "UNKNOWN TITLE" },
              duration: { seconds: item.duration?.seconds ?? 0 },
              thumbnails: item.thumbnail?.map((t) => ({ url: t.url })) ?? [],
              author: { name: item.author ?? "UNKNOWN AUTHOR", url: "" },
              is_live: false
            })),
            has_continuation: false,
            async getContinuation() {
              throw new Error("Mixes do not support continuation");
            }
          };
        } else {
          playlist = await this.innerTube.getPlaylist(plId);
        }
        const pl = new Playlist(this.context.player, {
          title: playlist.info.title ?? "UNKNOWN PLAYLIST",
          thumbnail: playlist.info.thumbnails[0].url,
          description: playlist.info.description ?? playlist.info.title ?? "UNKNOWN DESCRIPTION",
          type: "playlist",
          author: {
            name: playlist?.channels[0]?.author?.name ?? playlist.info.author.name ?? "UNKNOWN AUTHOR",
            url: playlist?.channels[0]?.author?.url ?? playlist.info.author.url ?? "UNKNOWN AUTHOR"
          },
          tracks: [],
          id: plId,
          url: query,
          source: "youtube"
        });
        pl.tracks = [];
        let plTracks = playlist.videos.filter(
          (v) => v.type === "PlaylistVideo"
        ).map((v) => {
          const duration = Util.buildTimeCode(
            Util.parseMS(v.duration.seconds * 1e3)
          );
          const raw = {
            duration_ms: v.duration.seconds * 1e3,
            live: v.is_live,
            duration
          };
          return new Track(this.context.player, {
            title: v.title.text ?? "UNKNOWN TITLE",
            duration,
            thumbnail: v.thumbnails[0]?.url,
            author: v.author.name,
            requestedBy: context.requestedBy,
            url: `https://youtube.com/watch?v=${v.id}`,
            raw,
            playlist: pl,
            source: "youtube",
            queryType: "youtubeVideo",
            async requestMetadata() {
              return this.raw;
            },
            metadata: raw,
            live: v.is_live
          });
        });
        while (playlist.has_continuation) {
          playlist = await playlist.getContinuation();
          plTracks.push(
            ...playlist.videos.filter(
              (v) => v.type === "PlaylistVideo"
            ).map((v) => {
              const duration = Util.buildTimeCode(
                Util.parseMS(v.duration.seconds * 1e3)
              );
              const raw = {
                duration_ms: v.duration.seconds * 1e3,
                live: v.is_live,
                duration
              };
              return new Track(this.context.player, {
                title: v.title.text ?? "UNKNOWN TITLE",
                duration,
                thumbnail: v.thumbnails[0]?.url,
                author: v.author.name,
                requestedBy: context.requestedBy,
                url: `https://youtube.com/watch?v=${v.id}`,
                raw,
                playlist: pl,
                source: "youtube",
                queryType: "youtubeVideo",
                async requestMetadata() {
                  return this.raw;
                },
                metadata: raw,
                live: v.is_live
              });
            })
          );
        }
        pl.tracks = plTracks;
        return {
          playlist: pl,
          tracks: pl.tracks
        };
      }
      case QueryType.YOUTUBE_VIDEO: {
        let videoId = new URL(query).searchParams.get("v");
        if (!videoId) videoId = query.split("/").at(-1).split("?")[0];
        const vid = await this.innerTube.getBasicInfo(videoId);
        const duration = Util.buildTimeCode(
          Util.parseMS((vid.basic_info.duration ?? 0) * 1e3)
        );
        const uploadTime = vid.basic_info.start_timestamp;
        const formats = {
          fmt: vid.chooseFormat({
            quality: "best",
            format: "webm",
            type: "audio"
          }),
          sabrUrl: vid.page[0].streaming_data?.server_abr_streaming_url,
          uStreamConfig: vid.page[0].player_config?.media_common_config.media_ustreamer_request_config?.video_playback_ustreamer_config,
          durationMs: (vid.basic_info.duration ?? 0) * 1e3,
          executedAt: Date.now()
        };
        const raw = {
          duration_ms: vid.basic_info.duration * 1e3,
          live: vid.basic_info.is_live,
          duration,
          startTime: uploadTime,
          formats
        };
        return {
          playlist: null,
          tracks: [
            new Track(this.context.player, {
              title: vid.basic_info.title ?? "UNKNOWN TITLE",
              thumbnail: vid.basic_info.thumbnail?.at(0)?.url,
              description: vid.basic_info.short_description,
              author: vid.basic_info.channel?.name,
              requestedBy: context.requestedBy,
              url: `https://youtube.com/watch?v=${vid.basic_info.id}`,
              views: vid.basic_info.view_count,
              duration,
              raw,
              source: "youtube",
              queryType: "youtubeVideo",
              async requestMetadata() {
                return this.raw;
              },
              metadata: raw,
              live: vid.basic_info.is_live
            })
          ]
        };
      }
      default: {
        const search = await this.innerTube.search(query);
        const videos = search.videos.filter(
          (v) => v.type === "Video"
        );
        return {
          playlist: null,
          tracks: videos.map((v) => this.buildTrack(v, context))
        };
      }
    }
  }
  buildTrack(vid, context, pl) {
    const duration = Util.buildTimeCode(
      Util.parseMS(vid.duration.seconds * 1e3)
    );
    const raw = {
      duration_ms: vid.duration.seconds * 1e3,
      live: vid.is_live
    };
    const track = new Track(this.context.player, {
      title: vid.title.text ?? "UNKNOWN YOUTUBE VIDEO",
      thumbnail: vid.best_thumbnail?.url ?? vid.thumbnails[0]?.url ?? "",
      description: vid.description ?? vid.title ?? "UNKNOWN DESCRIPTION",
      author: vid.author?.name ?? "UNKNOWN AUTHOR",
      requestedBy: context.requestedBy,
      url: `https://youtube.com/watch?v=${vid.id}`,
      views: parseInt((vid.view_count?.text ?? "0").replaceAll(",", "")),
      duration,
      raw,
      playlist: pl,
      source: "youtube",
      queryType: "youtubeVideo",
      async requestMetadata() {
        return this.raw;
      },
      metadata: raw,
      live: vid.is_live
    });
    track.extractor = this;
    return track;
  }
  stream(info) {
    return this._stream(info, this);
  }
  async getRelatedTracks(track, history) {
    let id = new URL(track.url).searchParams.get("v");
    if (!id) id = track.url.split("/").at(-1)?.split("?").at(0);
    const videoInfo = await this.innerTube.getInfo(id);
    const next = videoInfo.watch_next_feed;
    const recommended = next.filter(
      (v) => !history.tracks.some(
        (x) => x.url === `https://youtube.com/watch?v=${v.id}`
      ) && v.type === "CompactVideo"
    );
    if (!recommended) {
      this.context.player.debug("Unable to fetch recommendations");
      return this.#emptyResponse();
    }
    const trackConstruct = recommended.map((v) => {
      const duration = Util.buildTimeCode(
        Util.parseMS(v.duration.seconds * 1e3)
      );
      const raw = {
        live: v.is_live,
        duration_ms: v.duration.seconds * 1e3,
        duration
      };
      return new Track(this.context.player, {
        title: v.title?.text ?? "UNKNOWN TITLE",
        thumbnail: v.best_thumbnail?.url ?? v.thumbnails[0]?.url,
        author: v.author?.name ?? "UNKNOWN AUTHOR",
        requestedBy: track.requestedBy,
        url: `https://youtube.com/watch?v=${v.id}`,
        views: parseInt((v.view_count?.text ?? "0").replaceAll(",", "")),
        duration,
        raw,
        source: "youtube",
        queryType: "youtubeVideo",
        metadata: raw,
        async requestMetadata() {
          return this.raw;
        },
        live: v.is_live
      });
    });
    return {
      playlist: null,
      tracks: trackConstruct
    };
  }
  #emptyResponse() {
    return {
      playlist: null,
      tracks: []
    };
  }
  static validateURL(link) {
    try {
      _YoutubeiExtractor.parseURL(link);
      return true;
    } catch {
      return false;
    }
  }
  // stolen from  YoutubeExtractor
  static parseURL(link) {
    const parsed = new URL(link.trim());
    let id = parsed.searchParams.get("v");
    if (validPathDomains.test(link.trim()) && !id) {
      const paths = parsed.pathname.split("/");
      id = parsed.host === "youtu.be" ? paths[1] : paths[2];
    } else if (parsed.hostname && !validQueryDomains.has(parsed.hostname)) {
      throw Error("Not a YouTube domain");
    }
    if (!id) {
      throw Error(`No video id found: "${link}"`);
    }
    id = id.substring(0, 11);
    if (!this.validateId(id)) {
      throw TypeError(
        `Video id (${id}) does not match expected format (${idRegex.toString()})`
      );
    }
    return id;
  }
  static validateId(id) {
    return idRegex.test(id.trim());
  }
};

// lib/common/getInstance.ts
function getYoutubeiInstance() {
  return YoutubeiExtractor.instance?.innerTube;
}

// lib/index.ts
var exit = (message, clean) => {
  if (clean) {
    console.log(message);
    process.exit(0);
  }
  throw new Error(message);
};
async function generateOauthTokens() {
  const youtube = await Innertube3.create({
    retrieve_player: false
  });
  youtube.session.on("auth-pending", (data) => {
    const { verification_url: verify, user_code } = data;
    console.log(
      `Follow this URL: ${verify} and enter this code: ${user_code}
Make sure you are using a throwaway account to login. Using your main account may result in ban or suspension`
    );
  });
  youtube.session.on("auth-error", (err) => {
    exit(err.message, false);
  });
  youtube.session.on("auth", (data) => {
    if (!data.credentials) exit("Something went wrong", false);
    console.log("Your cookies are printed down below");
    console.log(objectToToken(data.credentials));
    exit("Done Getting the credentials", true);
  });
  await youtube.session.signIn();
}
export {
  ChatMessageType,
  Errors,
  LiveChatEvents,
  YoutubeiExtractor,
  defaultFetch,
  defaultPeerUrlBuilder,
  generateOauthTokens,
  generateToken,
  getLiveChat,
  getYoutubeiInstance,
  objectToToken,
  stream,
  tokenToObject,
  validateURL
};
