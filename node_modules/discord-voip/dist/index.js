"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AudioPlayer: () => AudioPlayer,
  AudioPlayerError: () => AudioPlayerError,
  AudioPlayerStatus: () => AudioPlayerStatus,
  AudioResource: () => AudioResource,
  NoSubscriberBehavior: () => NoSubscriberBehavior,
  PlayerSubscription: () => PlayerSubscription,
  StreamType: () => StreamType,
  VoiceConnection: () => VoiceConnection,
  VoiceConnectionDisconnectReason: () => VoiceConnectionDisconnectReason,
  VoiceConnectionStatus: () => VoiceConnectionStatus,
  createAudioPlayer: () => createAudioPlayer,
  createAudioResource: () => createAudioResource,
  entersState: () => entersState,
  getGroups: () => getGroups,
  getVoiceConnection: () => getVoiceConnection,
  getVoiceConnections: () => getVoiceConnections,
  joinVoiceChannel: () => joinVoiceChannel,
  version: () => version
});
module.exports = __toCommonJS(src_exports);

// src/VoiceConnection.ts
var import_node_events4 = require("events");

// src/DataStore.ts
var import_v10 = require("discord-api-types/v10");
function createJoinVoiceChannelPayload(config) {
  return {
    op: import_v10.GatewayOpcodes.VoiceStateUpdate,
    // eslint-disable-next-line id-length
    d: {
      guild_id: config.guildId,
      channel_id: config.channelId,
      self_deaf: config.selfDeaf,
      self_mute: config.selfMute
    }
  };
}
__name(createJoinVoiceChannelPayload, "createJoinVoiceChannelPayload");
var groups = /* @__PURE__ */ new Map();
groups.set("default", /* @__PURE__ */ new Map());
function getOrCreateGroup(group) {
  const existing = groups.get(group);
  if (existing) return existing;
  const map = /* @__PURE__ */ new Map();
  groups.set(group, map);
  return map;
}
__name(getOrCreateGroup, "getOrCreateGroup");
function getGroups() {
  return groups;
}
__name(getGroups, "getGroups");
function getVoiceConnections(group = "default") {
  return groups.get(group);
}
__name(getVoiceConnections, "getVoiceConnections");
function getVoiceConnection(guildId, group = "default") {
  return getVoiceConnections(group)?.get(guildId);
}
__name(getVoiceConnection, "getVoiceConnection");
function untrackVoiceConnection(voiceConnection) {
  return getVoiceConnections(voiceConnection.joinConfig.group)?.delete(
    voiceConnection.joinConfig.guildId
  );
}
__name(untrackVoiceConnection, "untrackVoiceConnection");
function trackVoiceConnection(voiceConnection) {
  return getOrCreateGroup(voiceConnection.joinConfig.group).set(
    voiceConnection.joinConfig.guildId,
    voiceConnection
  );
}
__name(trackVoiceConnection, "trackVoiceConnection");
var FRAME_LENGTH = 20;
var audioCycleInterval;
var nextTime = -1;
var audioPlayers = [];
function audioCycleStep() {
  if (nextTime === -1) return;
  nextTime += FRAME_LENGTH;
  const available = audioPlayers.filter((player) => player.checkPlayable());
  for (const player of available) {
    player["_stepDispatch"]();
  }
  prepareNextAudioFrame(available);
}
__name(audioCycleStep, "audioCycleStep");
function prepareNextAudioFrame(players) {
  const nextPlayer = players.shift();
  if (!nextPlayer) {
    if (nextTime !== -1) {
      audioCycleInterval = setTimeout(
        () => audioCycleStep(),
        nextTime - Date.now()
      );
    }
    return;
  }
  nextPlayer["_stepPrepare"]();
  setImmediate(() => prepareNextAudioFrame(players));
}
__name(prepareNextAudioFrame, "prepareNextAudioFrame");
function hasAudioPlayer(target) {
  return audioPlayers.includes(target);
}
__name(hasAudioPlayer, "hasAudioPlayer");
function addAudioPlayer(player) {
  if (hasAudioPlayer(player)) return player;
  audioPlayers.push(player);
  if (audioPlayers.length === 1) {
    nextTime = Date.now();
    setImmediate(() => audioCycleStep());
  }
  return player;
}
__name(addAudioPlayer, "addAudioPlayer");
function deleteAudioPlayer(player) {
  const index = audioPlayers.indexOf(player);
  if (index === -1) return;
  audioPlayers.splice(index, 1);
  if (audioPlayers.length === 0) {
    nextTime = -1;
    if (audioCycleInterval !== void 0) clearTimeout(audioCycleInterval);
  }
}
__name(deleteAudioPlayer, "deleteAudioPlayer");

// src/networking/Networking.ts
var import_node_buffer3 = require("buffer");
var import_node_events3 = require("events");
var import_node_crypto = __toESM(require("crypto"));
var import_v42 = require("discord-api-types/voice/v4");

// src/util/Secretbox.ts
var import_node_buffer = require("buffer");
var libs = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  "sodium-native": /* @__PURE__ */ __name((sodium) => ({
    crypto_aead_xchacha20poly1305_ietf_encrypt: /* @__PURE__ */ __name((plaintext, additionalData, nonce2, key) => {
      const cipherText = import_node_buffer.Buffer.alloc(
        plaintext.length + sodium.crypto_aead_xchacha20poly1305_ietf_ABYTES
      );
      sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(
        cipherText,
        plaintext,
        additionalData,
        null,
        nonce2,
        key
      );
      return cipherText;
    }, "crypto_aead_xchacha20poly1305_ietf_encrypt")
  }), "sodium-native"),
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sodium: /* @__PURE__ */ __name((sodium) => ({
    crypto_aead_xchacha20poly1305_ietf_encrypt: /* @__PURE__ */ __name((plaintext, additionalData, nonce2, key) => {
      return sodium.api.crypto_aead_xchacha20poly1305_ietf_encrypt(
        plaintext,
        additionalData,
        null,
        nonce2,
        key
      );
    }, "crypto_aead_xchacha20poly1305_ietf_encrypt")
  }), "sodium"),
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  "libsodium-wrappers": /* @__PURE__ */ __name((sodium) => ({
    crypto_aead_xchacha20poly1305_ietf_encrypt: /* @__PURE__ */ __name((plaintext, additionalData, nonce2, key) => {
      return sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(
        plaintext,
        additionalData,
        null,
        nonce2,
        key
      );
    }, "crypto_aead_xchacha20poly1305_ietf_encrypt")
  }), "libsodium-wrappers"),
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  "@stablelib/xchacha20poly1305": /* @__PURE__ */ __name((stablelib) => ({
    crypto_aead_xchacha20poly1305_ietf_encrypt(cipherText, additionalData, nonce2, key) {
      const crypto2 = new stablelib.XChaCha20Poly1305(key);
      return crypto2.seal(nonce2, cipherText, additionalData);
    }
  }), "@stablelib/xchacha20poly1305"),
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  "@noble/ciphers/chacha": /* @__PURE__ */ __name((noble) => ({
    crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, additionalData, nonce2, key) {
      const chacha = noble.xchacha20poly1305(key, nonce2, additionalData);
      return chacha.encrypt(plaintext);
    }
  }), "@noble/ciphers/chacha")
};
libs["sodium-javascript"] = libs["sodium-native"];
var validLibs = Object.keys(libs);
var fallbackError = /* @__PURE__ */ __name(() => {
  throw new Error(
    `Cannot play audio as no valid encryption package is installed.
- Install one of the following packages: ${validLibs.join(", ")}
- Use the generateDependencyReport() function for more information.
`
  );
}, "fallbackError");
var methods = {
  crypto_aead_xchacha20poly1305_ietf_encrypt: fallbackError
};
void (async () => {
  for (const libName of Object.keys(libs)) {
    try {
      const lib = await import(libName);
      if (libName === "libsodium-wrappers" && lib.ready) await lib.ready;
      Object.assign(methods, libs[libName](lib));
      break;
    } catch {
    }
  }
})();

// src/util/util.ts
var noop = /* @__PURE__ */ __name(() => {
}, "noop");

// src/networking/VoiceUDPSocket.ts
var import_node_buffer2 = require("buffer");
var import_node_dgram = require("dgram");
var import_node_events = require("events");
var import_node_net = require("net");
function parseLocalPacket(message) {
  const packet = import_node_buffer2.Buffer.from(message);
  const ip = packet.slice(8, packet.indexOf(0, 8)).toString("utf8");
  if (!(0, import_node_net.isIPv4)(ip)) {
    throw new Error("Malformed IP address");
  }
  const port = packet.readUInt16BE(packet.length - 2);
  return { ip, port };
}
__name(parseLocalPacket, "parseLocalPacket");
var KEEP_ALIVE_INTERVAL = 5e3;
var MAX_COUNTER_VALUE = 2 ** 32 - 1;
var _VoiceUDPSocket = class _VoiceUDPSocket extends import_node_events.EventEmitter {
  /**
   * Creates a new VoiceUDPSocket.
   *
   * @param remote - Details of the remote socket
   */
  constructor(remote) {
    super();
    /**
     * The underlying network Socket for the VoiceUDPSocket.
     */
    __publicField(this, "socket");
    /**
     * The socket details for Discord (remote)
     */
    __publicField(this, "remote");
    /**
     * The counter used in the keep alive mechanism.
     */
    __publicField(this, "keepAliveCounter", 0);
    /**
     * The buffer used to write the keep alive counter into.
     */
    __publicField(this, "keepAliveBuffer");
    /**
     * The Node.js interval for the keep-alive mechanism.
     */
    __publicField(this, "keepAliveInterval");
    /**
     * The time taken to receive a response to keep alive messages.
     *
     * @deprecated This field is no longer updated as keep alive messages are no longer tracked.
     */
    __publicField(this, "ping");
    this.socket = (0, import_node_dgram.createSocket)("udp4");
    this.socket.on("error", (error) => this.emit("error", error));
    this.socket.on("message", (buffer) => this.onMessage(buffer));
    this.socket.on("close", () => this.emit("close"));
    this.remote = remote;
    this.keepAliveBuffer = import_node_buffer2.Buffer.alloc(8);
    this.keepAliveInterval = setInterval(
      () => this.keepAlive(),
      KEEP_ALIVE_INTERVAL
    );
    setImmediate(() => this.keepAlive());
  }
  /**
   * Called when a message is received on the UDP socket.
   *
   * @param buffer - The received buffer
   */
  onMessage(buffer) {
    this.emit("message", buffer);
  }
  /**
   * Called at a regular interval to check whether we are still able to send datagrams to Discord.
   */
  keepAlive() {
    this.keepAliveBuffer.writeUInt32LE(this.keepAliveCounter, 0);
    this.send(this.keepAliveBuffer);
    this.keepAliveCounter++;
    if (this.keepAliveCounter > MAX_COUNTER_VALUE) {
      this.keepAliveCounter = 0;
    }
  }
  /**
   * Sends a buffer to Discord.
   *
   * @param buffer - The buffer to send
   */
  send(buffer) {
    this.socket.send(buffer, this.remote.port, this.remote.ip);
  }
  /**
   * Closes the socket, the instance will not be able to be reused.
   */
  destroy() {
    try {
      this.socket.close();
    } catch {
    }
    clearInterval(this.keepAliveInterval);
  }
  /**
   * Performs IP discovery to discover the local address and port to be used for the voice connection.
   *
   * @param ssrc - The SSRC received from Discord
   */
  async performIPDiscovery(ssrc) {
    return new Promise((resolve, reject) => {
      const listener = /* @__PURE__ */ __name((message) => {
        try {
          if (message.readUInt16BE(0) !== 2) return;
          const packet = parseLocalPacket(message);
          this.socket.off("message", listener);
          resolve(packet);
        } catch {
        }
      }, "listener");
      this.socket.on("message", listener);
      this.socket.once(
        "close",
        () => reject(new Error("Cannot perform IP discovery - socket closed"))
      );
      const discoveryBuffer = import_node_buffer2.Buffer.alloc(74);
      discoveryBuffer.writeUInt16BE(1, 0);
      discoveryBuffer.writeUInt16BE(70, 2);
      discoveryBuffer.writeUInt32BE(ssrc, 4);
      this.send(discoveryBuffer);
    });
  }
};
__name(_VoiceUDPSocket, "VoiceUDPSocket");
var VoiceUDPSocket = _VoiceUDPSocket;

// src/networking/VoiceWebSocket.ts
var import_node_events2 = require("events");
var import_v4 = require("discord-api-types/voice/v4");
var import_ws = require("ws");
var _VoiceWebSocket = class _VoiceWebSocket extends import_node_events2.EventEmitter {
  /**
   * Creates a new VoiceWebSocket.
   *
   * @param address - The address to connect to
   */
  constructor(address, debug) {
    super();
    /**
     * The current heartbeat interval, if any.
     */
    __publicField(this, "heartbeatInterval");
    /**
     * The time (milliseconds since UNIX epoch) that the last heartbeat acknowledgement packet was received.
     * This is set to 0 if an acknowledgement packet hasn't been received yet.
     */
    __publicField(this, "lastHeartbeatAck");
    /**
     * The time (milliseconds since UNIX epoch) that the last heartbeat was sent. This is set to 0 if a heartbeat
     * hasn't been sent yet.
     */
    __publicField(this, "lastHeartbeatSend");
    /**
     * The number of consecutively missed heartbeats.
     */
    __publicField(this, "missedHeartbeats", 0);
    /**
     * The last recorded ping.
     */
    __publicField(this, "ping");
    /**
     * The debug logger function, if debugging is enabled.
     */
    __publicField(this, "debug");
    /**
     * The underlying WebSocket of this wrapper.
     */
    __publicField(this, "ws");
    this.ws = new import_ws.WebSocket(address);
    this.ws.onmessage = (err) => this.onMessage(err);
    this.ws.onopen = (err) => this.emit("open", err);
    this.ws.onerror = (err) => this.emit("error", err instanceof Error ? err : err.error);
    this.ws.onclose = (err) => this.emit("close", err);
    this.lastHeartbeatAck = 0;
    this.lastHeartbeatSend = 0;
    this.debug = debug ? (message) => this.emit("debug", message) : null;
  }
  /**
   * Destroys the VoiceWebSocket. The heartbeat interval is cleared, and the connection is closed.
   */
  destroy() {
    try {
      this.debug?.("destroyed");
      this.setHeartbeatInterval(-1);
      this.ws.close(1e3);
    } catch (error) {
      const err = error;
      this.emit("error", err);
    }
  }
  /**
   * Handles message events on the WebSocket. Attempts to JSON parse the messages and emit them
   * as packets.
   *
   * @param event - The message event
   */
  onMessage(event) {
    if (typeof event.data !== "string") return;
    this.debug?.(`<< ${event.data}`);
    let packet;
    try {
      packet = JSON.parse(event.data);
    } catch (error) {
      const err = error;
      this.emit("error", err);
      return;
    }
    if (packet.op === import_v4.VoiceOpcodes.HeartbeatAck) {
      this.lastHeartbeatAck = Date.now();
      this.missedHeartbeats = 0;
      this.ping = this.lastHeartbeatAck - this.lastHeartbeatSend;
    }
    this.emit("packet", packet);
  }
  /**
   * Sends a JSON-stringifiable packet over the WebSocket.
   *
   * @param packet - The packet to send
   */
  sendPacket(packet) {
    try {
      const stringified = JSON.stringify(packet);
      this.debug?.(`>> ${stringified}`);
      this.ws.send(stringified);
    } catch (error) {
      const err = error;
      this.emit("error", err);
    }
  }
  /**
   * Sends a heartbeat over the WebSocket.
   */
  sendHeartbeat() {
    this.lastHeartbeatSend = Date.now();
    this.missedHeartbeats++;
    const nonce2 = this.lastHeartbeatSend;
    this.sendPacket({
      op: import_v4.VoiceOpcodes.Heartbeat,
      // eslint-disable-next-line id-length
      d: nonce2
    });
  }
  /**
   * Sets/clears an interval to send heartbeats over the WebSocket.
   *
   * @param ms - The interval in milliseconds. If negative, the interval will be unset
   */
  setHeartbeatInterval(ms) {
    if (this.heartbeatInterval !== void 0)
      clearInterval(this.heartbeatInterval);
    if (ms > 0) {
      this.heartbeatInterval = setInterval(() => {
        if (this.lastHeartbeatSend !== 0 && this.missedHeartbeats >= 3) {
          this.ws.close();
          this.setHeartbeatInterval(-1);
        }
        this.sendHeartbeat();
      }, ms);
    }
  }
};
__name(_VoiceWebSocket, "VoiceWebSocket");
var VoiceWebSocket = _VoiceWebSocket;

// src/networking/Networking.ts
var CHANNELS = 2;
var TIMESTAMP_INC = 48e3 / 100 * CHANNELS;
var MAX_NONCE_SIZE = 2 ** 32 - 1;
var SUPPORTED_ENCRYPTION_MODES = ["aead_xchacha20_poly1305_rtpsize"];
if (import_node_crypto.default.getCiphers().includes("aes-256-gcm")) {
  SUPPORTED_ENCRYPTION_MODES.unshift("aead_aes256_gcm_rtpsize");
}
var nonce = import_node_buffer3.Buffer.alloc(24);
function stringifyState(state) {
  return JSON.stringify({
    ...state,
    ws: Reflect.has(state, "ws"),
    udp: Reflect.has(state, "udp")
  });
}
__name(stringifyState, "stringifyState");
function chooseEncryptionMode(options) {
  const option = options.find(
    (option2) => SUPPORTED_ENCRYPTION_MODES.includes(option2)
  );
  if (!option) {
    throw new Error(
      `No compatible encryption modes. Available include: ${options.join(
        ", "
      )}`
    );
  }
  return option;
}
__name(chooseEncryptionMode, "chooseEncryptionMode");
function randomNBit(numberOfBits) {
  return Math.floor(Math.random() * 2 ** numberOfBits);
}
__name(randomNBit, "randomNBit");
var _Networking = class _Networking extends import_node_events3.EventEmitter {
  /**
   * Creates a new Networking instance.
   */
  constructor(options, debug) {
    super();
    __publicField(this, "_state");
    /**
     * The debug logger function, if debugging is enabled.
     */
    __publicField(this, "debug");
    this.onWsOpen = this.onWsOpen.bind(this);
    this.onChildError = this.onChildError.bind(this);
    this.onWsPacket = this.onWsPacket.bind(this);
    this.onWsClose = this.onWsClose.bind(this);
    this.onWsDebug = this.onWsDebug.bind(this);
    this.onUdpDebug = this.onUdpDebug.bind(this);
    this.onUdpClose = this.onUdpClose.bind(this);
    this.debug = debug ? (message) => this.emit("debug", message) : null;
    this._state = {
      code: 0 /* OpeningWs */,
      ws: this.createWebSocket(options.endpoint),
      connectionOptions: options
    };
  }
  /**
   * Destroys the Networking instance, transitioning it into the Closed state.
   */
  destroy() {
    this.state = {
      code: 6 /* Closed */
    };
  }
  /**
   * The current state of the networking instance.
   */
  get state() {
    return this._state;
  }
  /**
   * Sets a new state for the networking instance, performing clean-up operations where necessary.
   */
  set state(newState) {
    const oldWs = Reflect.get(this._state, "ws");
    const newWs = Reflect.get(newState, "ws");
    if (oldWs && oldWs !== newWs) {
      oldWs.off("debug", this.onWsDebug);
      oldWs.on("error", noop);
      oldWs.off("error", this.onChildError);
      oldWs.off("open", this.onWsOpen);
      oldWs.off("packet", this.onWsPacket);
      oldWs.off("close", this.onWsClose);
      oldWs.destroy();
    }
    const oldUdp = Reflect.get(this._state, "udp");
    const newUdp = Reflect.get(newState, "udp");
    if (oldUdp && oldUdp !== newUdp) {
      oldUdp.on("error", noop);
      oldUdp.off("error", this.onChildError);
      oldUdp.off("close", this.onUdpClose);
      oldUdp.off("debug", this.onUdpDebug);
      oldUdp.destroy();
    }
    const oldState = this._state;
    this._state = newState;
    this.emit("stateChange", oldState, newState);
    this.debug?.(
      `state change:
from ${stringifyState(oldState)}
to ${stringifyState(
        newState
      )}`
    );
  }
  /**
   * Creates a new WebSocket to a Discord Voice gateway.
   *
   * @param endpoint - The endpoint to connect to
   */
  createWebSocket(endpoint) {
    const ws = new VoiceWebSocket(`wss://${endpoint}?v=4`, Boolean(this.debug));
    ws.on("error", this.onChildError);
    ws.once("open", this.onWsOpen);
    ws.on("packet", this.onWsPacket);
    ws.once("close", this.onWsClose);
    ws.on("debug", this.onWsDebug);
    return ws;
  }
  /**
   * Propagates errors from the children VoiceWebSocket and VoiceUDPSocket.
   *
   * @param error - The error that was emitted by a child
   */
  onChildError(error) {
    this.emit("error", error);
  }
  /**
   * Called when the WebSocket opens. Depending on the state that the instance is in,
   * it will either identify with a new session, or it will attempt to resume an existing session.
   */
  onWsOpen() {
    if (this.state.code === 0 /* OpeningWs */) {
      const packet = {
        op: import_v42.VoiceOpcodes.Identify,
        d: {
          server_id: this.state.connectionOptions.serverId,
          user_id: this.state.connectionOptions.userId,
          session_id: this.state.connectionOptions.sessionId,
          token: this.state.connectionOptions.token
        }
      };
      this.state.ws.sendPacket(packet);
      this.state = {
        ...this.state,
        code: 1 /* Identifying */
      };
    } else if (this.state.code === 5 /* Resuming */) {
      const packet = {
        op: import_v42.VoiceOpcodes.Resume,
        d: {
          server_id: this.state.connectionOptions.serverId,
          session_id: this.state.connectionOptions.sessionId,
          token: this.state.connectionOptions.token
        }
      };
      this.state.ws.sendPacket(packet);
    }
  }
  /**
   * Called when the WebSocket closes. Based on the reason for closing (given by the code parameter),
   * the instance will either attempt to resume, or enter the closed state and emit a 'close' event
   * with the close code, allowing the user to decide whether or not they would like to reconnect.
   *
   * @param code - The close code
   */
  onWsClose({ code }) {
    const canResume = code === 4015 || code < 4e3;
    if (canResume && this.state.code === 4 /* Ready */) {
      this.state = {
        ...this.state,
        code: 5 /* Resuming */,
        ws: this.createWebSocket(this.state.connectionOptions.endpoint)
      };
    } else if (this.state.code !== 6 /* Closed */) {
      this.destroy();
      this.emit("close", code);
    }
  }
  /**
   * Called when the UDP socket has closed itself if it has stopped receiving replies from Discord.
   */
  onUdpClose() {
    if (this.state.code === 4 /* Ready */) {
      this.state = {
        ...this.state,
        code: 5 /* Resuming */,
        ws: this.createWebSocket(this.state.connectionOptions.endpoint)
      };
    }
  }
  /**
   * Called when a packet is received on the connection's WebSocket.
   *
   * @param packet - The received packet
   */
  onWsPacket(packet) {
    if (packet.op === import_v42.VoiceOpcodes.Hello && this.state.code !== 6 /* Closed */) {
      this.state.ws.setHeartbeatInterval(packet.d.heartbeat_interval);
    } else if (packet.op === import_v42.VoiceOpcodes.Ready && this.state.code === 1 /* Identifying */) {
      const { ip, port, ssrc, modes } = packet.d;
      const udp = new VoiceUDPSocket({ ip, port });
      udp.on("error", this.onChildError);
      udp.on("debug", this.onUdpDebug);
      udp.once("close", this.onUdpClose);
      udp.performIPDiscovery(ssrc).then((localConfig) => {
        if (this.state.code !== 2 /* UdpHandshaking */) return;
        this.state.ws.sendPacket({
          op: import_v42.VoiceOpcodes.SelectProtocol,
          d: {
            protocol: "udp",
            data: {
              address: localConfig.ip,
              port: localConfig.port,
              mode: chooseEncryptionMode(modes)
            }
          }
        });
        this.state = {
          ...this.state,
          code: 3 /* SelectingProtocol */
        };
      }).catch((error) => this.emit("error", error));
      this.state = {
        ...this.state,
        code: 2 /* UdpHandshaking */,
        udp,
        connectionData: {
          ssrc
        }
      };
    } else if (packet.op === import_v42.VoiceOpcodes.SessionDescription && this.state.code === 3 /* SelectingProtocol */) {
      const { mode: encryptionMode, secret_key: secretKey } = packet.d;
      this.state = {
        ...this.state,
        code: 4 /* Ready */,
        connectionData: {
          ...this.state.connectionData,
          encryptionMode,
          secretKey: new Uint8Array(secretKey),
          sequence: randomNBit(16),
          timestamp: randomNBit(32),
          nonce: 0,
          nonceBuffer: encryptionMode === "aead_aes256_gcm_rtpsize" ? import_node_buffer3.Buffer.alloc(12) : import_node_buffer3.Buffer.alloc(24),
          speaking: false,
          packetsPlayed: 0
        }
      };
    } else if (packet.op === import_v42.VoiceOpcodes.Resumed && this.state.code === 5 /* Resuming */) {
      this.state = {
        ...this.state,
        code: 4 /* Ready */
      };
      this.state.connectionData.speaking = false;
    }
  }
  /**
   * Propagates debug messages from the child WebSocket.
   *
   * @param message - The emitted debug message
   */
  onWsDebug(message) {
    this.debug?.(`[WS] ${message}`);
  }
  /**
   * Propagates debug messages from the child UDPSocket.
   *
   * @param message - The emitted debug message
   */
  onUdpDebug(message) {
    this.debug?.(`[UDP] ${message}`);
  }
  /**
   * Prepares an Opus packet for playback. This includes attaching metadata to it and encrypting it.
   * It will be stored within the instance, and can be played by dispatchAudio()
   *
   * @remarks
   * Calling this method while there is already a prepared audio packet that has not yet been dispatched
   * will overwrite the existing audio packet. This should be avoided.
   * @param opusPacket - The Opus packet to encrypt
   * @returns The audio packet that was prepared
   */
  prepareAudioPacket(opusPacket) {
    const state = this.state;
    if (state.code !== 4 /* Ready */) return;
    state.preparedPacket = this.createAudioPacket(
      opusPacket,
      state.connectionData
    );
    return state.preparedPacket;
  }
  /**
   * Dispatches the audio packet previously prepared by prepareAudioPacket(opusPacket). The audio packet
   * is consumed and cannot be dispatched again.
   */
  dispatchAudio() {
    const state = this.state;
    if (state.code !== 4 /* Ready */) return false;
    if (state.preparedPacket !== void 0) {
      this.playAudioPacket(state.preparedPacket);
      state.preparedPacket = void 0;
      return true;
    }
    return false;
  }
  /**
   * Plays an audio packet, updating timing metadata used for playback.
   *
   * @param audioPacket - The audio packet to play
   */
  playAudioPacket(audioPacket) {
    const state = this.state;
    if (state.code !== 4 /* Ready */) return;
    const { connectionData } = state;
    connectionData.packetsPlayed++;
    connectionData.sequence++;
    connectionData.timestamp += TIMESTAMP_INC;
    if (connectionData.sequence >= 2 ** 16) connectionData.sequence = 0;
    if (connectionData.timestamp >= 2 ** 32) connectionData.timestamp = 0;
    this.setSpeaking(true);
    state.udp.send(audioPacket);
  }
  /**
   * Sends a packet to the voice gateway indicating that the client has start/stopped sending
   * audio.
   *
   * @param speaking - Whether or not the client should be shown as speaking
   */
  setSpeaking(speaking) {
    const state = this.state;
    if (state.code !== 4 /* Ready */) return;
    if (state.connectionData.speaking === speaking) return;
    state.connectionData.speaking = speaking;
    state.ws.sendPacket({
      op: import_v42.VoiceOpcodes.Speaking,
      d: {
        speaking: speaking ? 1 : 0,
        delay: 0,
        ssrc: state.connectionData.ssrc
      }
    });
  }
  /**
   * Creates a new audio packet from an Opus packet. This involves encrypting the packet,
   * then prepending a header that includes metadata.
   *
   * @param opusPacket - The Opus packet to prepare
   * @param connectionData - The current connection data of the instance
   */
  createAudioPacket(opusPacket, connectionData) {
    const packetBuffer = import_node_buffer3.Buffer.alloc(12);
    packetBuffer[0] = 128;
    packetBuffer[1] = 120;
    const { sequence, timestamp, ssrc } = connectionData;
    packetBuffer.writeUIntBE(sequence, 2, 2);
    packetBuffer.writeUIntBE(timestamp, 4, 4);
    packetBuffer.writeUIntBE(ssrc, 8, 4);
    packetBuffer.copy(nonce, 0, 0, 12);
    return import_node_buffer3.Buffer.concat(
      [
        // @ts-ignore
        packetBuffer,
        ...this.encryptOpusPacket(opusPacket, connectionData, packetBuffer)
      ]
    );
  }
  /**
   * Encrypts an Opus packet using the format agreed upon by the instance and Discord.
   *
   * @param opusPacket - The Opus packet to encrypt
   * @param connectionData - The current connection data of the instance
   */
  encryptOpusPacket(opusPacket, connectionData, data) {
    const { secretKey, encryptionMode } = connectionData;
    connectionData.nonce++;
    if (connectionData.nonce > MAX_NONCE_SIZE) connectionData.nonce = 0;
    connectionData.nonceBuffer.writeUInt32BE(connectionData.nonce, 0);
    const noncePadding = connectionData.nonceBuffer.subarray(0, 4);
    let encrypted;
    switch (encryptionMode) {
      case "aead_aes256_gcm_rtpsize": {
        const cipher = import_node_crypto.default.createCipheriv(
          "aes-256-gcm",
          secretKey,
          connectionData.nonceBuffer
        );
        cipher.setAAD(data);
        encrypted = import_node_buffer3.Buffer.concat(
          [
            cipher.update(opusPacket),
            cipher.final(),
            cipher.getAuthTag()
          ]
        );
        return [encrypted, noncePadding];
      }
      case "aead_xchacha20_poly1305_rtpsize": {
        encrypted = methods.crypto_aead_xchacha20poly1305_ietf_encrypt(
          opusPacket,
          data,
          connectionData.nonceBuffer,
          secretKey
        );
        return [encrypted, noncePadding];
      }
      default: {
        throw new RangeError(
          `Unsupported encryption method: ${encryptionMode}`
        );
      }
    }
  }
};
__name(_Networking, "Networking");
var Networking = _Networking;

// src/VoiceConnection.ts
var VoiceConnectionStatus = /* @__PURE__ */ ((VoiceConnectionStatus2) => {
  VoiceConnectionStatus2["Connecting"] = "connecting";
  VoiceConnectionStatus2["Destroyed"] = "destroyed";
  VoiceConnectionStatus2["Disconnected"] = "disconnected";
  VoiceConnectionStatus2["Ready"] = "ready";
  VoiceConnectionStatus2["Signalling"] = "signalling";
  return VoiceConnectionStatus2;
})(VoiceConnectionStatus || {});
var VoiceConnectionDisconnectReason = /* @__PURE__ */ ((VoiceConnectionDisconnectReason2) => {
  VoiceConnectionDisconnectReason2[VoiceConnectionDisconnectReason2["WebSocketClose"] = 0] = "WebSocketClose";
  VoiceConnectionDisconnectReason2[VoiceConnectionDisconnectReason2["AdapterUnavailable"] = 1] = "AdapterUnavailable";
  VoiceConnectionDisconnectReason2[VoiceConnectionDisconnectReason2["EndpointRemoved"] = 2] = "EndpointRemoved";
  VoiceConnectionDisconnectReason2[VoiceConnectionDisconnectReason2["Manual"] = 3] = "Manual";
  return VoiceConnectionDisconnectReason2;
})(VoiceConnectionDisconnectReason || {});
var _VoiceConnection = class _VoiceConnection extends import_node_events4.EventEmitter {
  /**
   * Creates a new voice connection.
   *
   * @param joinConfig - The data required to establish the voice connection
   * @param options - The options used to create this voice connection
   */
  constructor(joinConfig, options) {
    super();
    /**
     * The number of consecutive rejoin attempts. Initially 0, and increments for each rejoin.
     * When a connection is successfully established, it resets to 0.
     */
    __publicField(this, "rejoinAttempts");
    /**
     * The state of the voice connection.
     */
    __publicField(this, "_state");
    /**
     * A configuration storing all the data needed to reconnect to a Guild's voice server.
     *
     * @internal
     */
    __publicField(this, "joinConfig");
    /**
     * The two packets needed to successfully establish a voice connection. They are received
     * from the main Discord gateway after signalling to change the voice state.
     */
    __publicField(this, "packets");
    /**
     * The debug logger function, if debugging is enabled.
     */
    __publicField(this, "debug");
    this.debug = options.debug ? (message) => this.emit("debug", message) : null;
    this.rejoinAttempts = 0;
    this.onNetworkingClose = this.onNetworkingClose.bind(this);
    this.onNetworkingStateChange = this.onNetworkingStateChange.bind(this);
    this.onNetworkingError = this.onNetworkingError.bind(this);
    this.onNetworkingDebug = this.onNetworkingDebug.bind(this);
    const adapter = options.adapterCreator({
      onVoiceServerUpdate: /* @__PURE__ */ __name((data) => this.addServerPacket(data), "onVoiceServerUpdate"),
      onVoiceStateUpdate: /* @__PURE__ */ __name((data) => this.addStatePacket(data), "onVoiceStateUpdate"),
      destroy: /* @__PURE__ */ __name(() => this.destroy(false), "destroy")
    });
    this._state = { status: "signalling" /* Signalling */, adapter };
    this.packets = {
      server: void 0,
      state: void 0
    };
    this.joinConfig = joinConfig;
  }
  /**
   * The current state of the voice connection.
   */
  get state() {
    return this._state;
  }
  /**
   * Updates the state of the voice connection, performing clean-up operations where necessary.
   */
  set state(newState) {
    const oldState = this._state;
    const oldNetworking = Reflect.get(oldState, "networking");
    const newNetworking = Reflect.get(newState, "networking");
    const oldSubscription = Reflect.get(oldState, "subscription");
    const newSubscription = Reflect.get(newState, "subscription");
    if (oldNetworking !== newNetworking) {
      if (oldNetworking) {
        oldNetworking.on("error", noop);
        oldNetworking.off("debug", this.onNetworkingDebug);
        oldNetworking.off("error", this.onNetworkingError);
        oldNetworking.off("close", this.onNetworkingClose);
        oldNetworking.off("stateChange", this.onNetworkingStateChange);
        oldNetworking.destroy();
      }
    }
    if (newState.status === "ready" /* Ready */) {
      this.rejoinAttempts = 0;
    }
    if (oldState.status !== "destroyed" /* Destroyed */ && newState.status === "destroyed" /* Destroyed */) {
      oldState.adapter.destroy();
    }
    this._state = newState;
    if (oldSubscription && oldSubscription !== newSubscription) {
      oldSubscription.unsubscribe();
    }
    this.emit("stateChange", oldState, newState);
    if (oldState.status !== newState.status) {
      this.emit(newState.status, oldState, newState);
    }
  }
  /**
   * Registers a `VOICE_SERVER_UPDATE` packet to the voice connection. This will cause it to reconnect using the
   * new data provided in the packet.
   *
   * @param packet - The received `VOICE_SERVER_UPDATE` packet
   */
  addServerPacket(packet) {
    this.packets.server = packet;
    if (packet.endpoint) {
      this.configureNetworking();
    } else if (this.state.status !== "destroyed" /* Destroyed */) {
      this.state = {
        ...this.state,
        status: "disconnected" /* Disconnected */,
        reason: 2 /* EndpointRemoved */
      };
    }
  }
  /**
   * Registers a `VOICE_STATE_UPDATE` packet to the voice connection. Most importantly, it stores the id of the
   * channel that the client is connected to.
   *
   * @param packet - The received `VOICE_STATE_UPDATE` packet
   */
  addStatePacket(packet) {
    this.packets.state = packet;
    if (packet.self_deaf !== void 0)
      this.joinConfig.selfDeaf = packet.self_deaf;
    if (packet.self_mute !== void 0)
      this.joinConfig.selfMute = packet.self_mute;
    if (packet.channel_id) this.joinConfig.channelId = packet.channel_id;
  }
  /**
   * Attempts to configure a networking instance for this voice connection using the received packets.
   * Both packets are required, and any existing networking instance will be destroyed.
   *
   * @remarks
   * This is called when the voice server of the connection changes, e.g. if the bot is moved into a
   * different channel in the same guild but has a different voice server. In this instance, the connection
   * needs to be re-established to the new voice server.
   *
   * The connection will transition to the Connecting state when this is called.
   */
  configureNetworking() {
    const { server, state } = this.packets;
    if (!server || !state || this.state.status === "destroyed" /* Destroyed */ || !server.endpoint)
      return;
    const networking = new Networking(
      {
        endpoint: server.endpoint,
        serverId: server.guild_id,
        token: server.token,
        sessionId: state.session_id,
        userId: state.user_id
      },
      Boolean(this.debug)
    );
    networking.once("close", this.onNetworkingClose);
    networking.on("stateChange", this.onNetworkingStateChange);
    networking.on("error", this.onNetworkingError);
    networking.on("debug", this.onNetworkingDebug);
    this.state = {
      ...this.state,
      status: "connecting" /* Connecting */,
      networking
    };
  }
  /**
   * Called when the networking instance for this connection closes. If the close code is 4014 (do not reconnect),
   * the voice connection will transition to the Disconnected state which will store the close code. You can
   * decide whether or not to reconnect when this occurs by listening for the state change and calling reconnect().
   *
   * @remarks
   * If the close code was anything other than 4014, it is likely that the closing was not intended, and so the
   * VoiceConnection will signal to Discord that it would like to rejoin the channel. This automatically attempts
   * to re-establish the connection. This would be seen as a transition from the Ready state to the Signalling state.
   * @param code - The close code
   */
  onNetworkingClose(code) {
    if (this.state.status === "destroyed" /* Destroyed */) return;
    if (code === 4014) {
      this.state = {
        ...this.state,
        status: "disconnected" /* Disconnected */,
        reason: 0 /* WebSocketClose */,
        closeCode: code
      };
    } else {
      this.state = {
        ...this.state,
        status: "signalling" /* Signalling */
      };
      this.rejoinAttempts++;
      if (!this.state.adapter.sendPayload(
        createJoinVoiceChannelPayload(this.joinConfig)
      )) {
        this.state = {
          ...this.state,
          status: "disconnected" /* Disconnected */,
          reason: 1 /* AdapterUnavailable */
        };
      }
    }
  }
  /**
   * Called when the state of the networking instance changes. This is used to derive the state of the voice connection.
   *
   * @param oldState - The previous state
   * @param newState - The new state
   */
  onNetworkingStateChange(oldState, newState) {
    if (oldState.code === newState.code) return;
    if (this.state.status !== "connecting" /* Connecting */ && this.state.status !== "ready" /* Ready */)
      return;
    if (newState.code === 4 /* Ready */) {
      this.state = {
        ...this.state,
        status: "ready" /* Ready */
      };
    } else if (newState.code !== 6 /* Closed */) {
      this.state = {
        ...this.state,
        status: "connecting" /* Connecting */
      };
    }
  }
  /**
   * Propagates errors from the underlying network instance.
   *
   * @param error - The error to propagate
   */
  onNetworkingError(error) {
    this.emit("error", error);
  }
  /**
   * Propagates debug messages from the underlying network instance.
   *
   * @param message - The debug message to propagate
   */
  onNetworkingDebug(message) {
    this.debug?.(`[NW] ${message}`);
  }
  /**
   * Prepares an audio packet for dispatch.
   *
   * @param buffer - The Opus packet to prepare
   */
  prepareAudioPacket(buffer) {
    const state = this.state;
    if (state.status !== "ready" /* Ready */) return;
    return state.networking.prepareAudioPacket(buffer);
  }
  /**
   * Dispatches the previously prepared audio packet (if any)
   */
  dispatchAudio() {
    const state = this.state;
    if (state.status !== "ready" /* Ready */) return;
    return state.networking.dispatchAudio();
  }
  /**
   * Prepares an audio packet and dispatches it immediately.
   *
   * @param buffer - The Opus packet to play
   */
  playOpusPacket(buffer) {
    const state = this.state;
    if (state.status !== "ready" /* Ready */) return;
    state.networking.prepareAudioPacket(buffer);
    return state.networking.dispatchAudio();
  }
  /**
   * Destroys the VoiceConnection, preventing it from connecting to voice again.
   * This method should be called when you no longer require the VoiceConnection to
   * prevent memory leaks.
   *
   * @param adapterAvailable - Whether the adapter can be used
   */
  destroy(adapterAvailable = true) {
    if (this.state.status === "destroyed" /* Destroyed */) {
      throw new Error(
        "Cannot destroy VoiceConnection - it has already been destroyed"
      );
    }
    if (getVoiceConnection(this.joinConfig.guildId, this.joinConfig.group) === this) {
      untrackVoiceConnection(this);
    }
    if (adapterAvailable) {
      this.state.adapter.sendPayload(
        createJoinVoiceChannelPayload({ ...this.joinConfig, channelId: null })
      );
    }
    this.state = {
      status: "destroyed" /* Destroyed */
    };
  }
  /**
   * Disconnects the VoiceConnection, allowing the possibility of rejoining later on.
   *
   * @returns `true` if the connection was successfully disconnected
   */
  disconnect() {
    if (this.state.status === "destroyed" /* Destroyed */ || this.state.status === "signalling" /* Signalling */) {
      return false;
    }
    this.joinConfig.channelId = null;
    if (!this.state.adapter.sendPayload(
      createJoinVoiceChannelPayload(this.joinConfig)
    )) {
      this.state = {
        adapter: this.state.adapter,
        subscription: this.state.subscription,
        status: "disconnected" /* Disconnected */,
        reason: 1 /* AdapterUnavailable */
      };
      return false;
    }
    this.state = {
      adapter: this.state.adapter,
      reason: 3 /* Manual */,
      status: "disconnected" /* Disconnected */
    };
    return true;
  }
  /**
   * Attempts to rejoin (better explanation soon:tm:)
   *
   * @remarks
   * Calling this method successfully will automatically increment the `rejoinAttempts` counter,
   * which you can use to inform whether or not you'd like to keep attempting to reconnect your
   * voice connection.
   *
   * A state transition from Disconnected to Signalling will be observed when this is called.
   */
  rejoin(joinConfig) {
    if (this.state.status === "destroyed" /* Destroyed */) {
      return false;
    }
    const notReady = this.state.status !== "ready" /* Ready */;
    if (notReady) this.rejoinAttempts++;
    Object.assign(this.joinConfig, joinConfig);
    if (this.state.adapter.sendPayload(
      createJoinVoiceChannelPayload(this.joinConfig)
    )) {
      if (notReady) {
        this.state = {
          ...this.state,
          status: "signalling" /* Signalling */
        };
      }
      return true;
    }
    this.state = {
      adapter: this.state.adapter,
      subscription: this.state.subscription,
      status: "disconnected" /* Disconnected */,
      reason: 1 /* AdapterUnavailable */
    };
    return false;
  }
  /**
   * Updates the speaking status of the voice connection. This is used when audio players are done playing audio,
   * and need to signal that the connection is no longer playing audio.
   *
   * @param enabled - Whether or not to show as speaking
   */
  setSpeaking(enabled) {
    if (this.state.status !== "ready" /* Ready */) return false;
    return this.state.networking.setSpeaking(enabled);
  }
  /**
   * Subscribes to an audio player, allowing the player to play audio on this voice connection.
   *
   * @param player - The audio player to subscribe to
   * @returns The created subscription
   */
  subscribe(player) {
    if (this.state.status === "destroyed" /* Destroyed */) return;
    const subscription = player["subscribe"](this);
    this.state = {
      ...this.state,
      subscription
    };
    return subscription;
  }
  /**
   * The latest ping (in milliseconds) for the WebSocket connection and audio playback for this voice
   * connection, if this data is available.
   *
   * @remarks
   * For this data to be available, the VoiceConnection must be in the Ready state, and its underlying
   * WebSocket connection and UDP socket must have had at least one ping-pong exchange.
   */
  get ping() {
    if (this.state.status === "ready" /* Ready */ && this.state.networking.state.code === 4 /* Ready */) {
      return {
        ws: this.state.networking.state.ws.ping,
        udp: this.state.networking.state.udp.ping
      };
    }
    return {
      ws: void 0,
      udp: void 0
    };
  }
  /**
   * Called when a subscription of this voice connection to an audio player is removed.
   *
   * @param subscription - The removed subscription
   */
  onSubscriptionRemoved(subscription) {
    if (this.state.status !== "destroyed" /* Destroyed */ && this.state.subscription === subscription) {
      this.state = {
        ...this.state,
        subscription: void 0
      };
    }
  }
};
__name(_VoiceConnection, "VoiceConnection");
var VoiceConnection = _VoiceConnection;
function createVoiceConnection(joinConfig, options) {
  const payload = createJoinVoiceChannelPayload(joinConfig);
  const existing = getVoiceConnection(joinConfig.guildId, joinConfig.group);
  if (existing && existing.state.status !== "destroyed" /* Destroyed */) {
    if (existing.state.status === "disconnected" /* Disconnected */) {
      existing.rejoin({
        channelId: joinConfig.channelId,
        selfDeaf: joinConfig.selfDeaf,
        selfMute: joinConfig.selfMute
      });
    } else if (!existing.state.adapter.sendPayload(payload)) {
      existing.state = {
        ...existing.state,
        status: "disconnected" /* Disconnected */,
        reason: 1 /* AdapterUnavailable */
      };
    }
    return existing;
  }
  const voiceConnection = new VoiceConnection(joinConfig, options);
  trackVoiceConnection(voiceConnection);
  if (voiceConnection.state.status !== "destroyed" /* Destroyed */ && !voiceConnection.state.adapter.sendPayload(payload)) {
    voiceConnection.state = {
      ...voiceConnection.state,
      status: "disconnected" /* Disconnected */,
      reason: 1 /* AdapterUnavailable */
    };
  }
  return voiceConnection;
}
__name(createVoiceConnection, "createVoiceConnection");

// src/joinVoiceChannel.ts
function joinVoiceChannel(options) {
  const joinConfig = {
    selfDeaf: true,
    selfMute: false,
    group: "default",
    ...options
  };
  return createVoiceConnection(joinConfig, {
    adapterCreator: options.adapterCreator,
    debug: options.debug
  });
}
__name(joinVoiceChannel, "joinVoiceChannel");

// src/audio/AudioPlayer.ts
var import_node_buffer4 = require("buffer");
var import_node_events5 = require("events");

// src/audio/AudioPlayerError.ts
var _AudioPlayerError = class _AudioPlayerError extends Error {
  constructor(error, resource) {
    super(error.message);
    /**
     * The resource associated with the audio player at the time the error was thrown.
     */
    __publicField(this, "resource");
    this.resource = resource;
    this.name = error.name;
    this.stack = error.stack;
  }
};
__name(_AudioPlayerError, "AudioPlayerError");
var AudioPlayerError = _AudioPlayerError;

// src/audio/PlayerSubscription.ts
var _PlayerSubscription = class _PlayerSubscription {
  constructor(connection, player) {
    /**
     * The voice connection of this subscription.
     */
    __publicField(this, "connection");
    /**
     * The audio player of this subscription.
     */
    __publicField(this, "player");
    this.connection = connection;
    this.player = player;
  }
  /**
   * Unsubscribes the connection from the audio player, meaning that the
   * audio player cannot stream audio to it until a new subscription is made.
   */
  unsubscribe() {
    this.connection["onSubscriptionRemoved"](this);
    this.player["unsubscribe"](this);
  }
};
__name(_PlayerSubscription, "PlayerSubscription");
var PlayerSubscription = _PlayerSubscription;

// src/audio/AudioPlayer.ts
var SILENCE_FRAME = import_node_buffer4.Buffer.from([248, 255, 254]);
var NoSubscriberBehavior = /* @__PURE__ */ ((NoSubscriberBehavior2) => {
  NoSubscriberBehavior2["Pause"] = "pause";
  NoSubscriberBehavior2["Play"] = "play";
  NoSubscriberBehavior2["Stop"] = "stop";
  return NoSubscriberBehavior2;
})(NoSubscriberBehavior || {});
var AudioPlayerStatus = /* @__PURE__ */ ((AudioPlayerStatus2) => {
  AudioPlayerStatus2["AutoPaused"] = "autopaused";
  AudioPlayerStatus2["Buffering"] = "buffering";
  AudioPlayerStatus2["Idle"] = "idle";
  AudioPlayerStatus2["Paused"] = "paused";
  AudioPlayerStatus2["Playing"] = "playing";
  return AudioPlayerStatus2;
})(AudioPlayerStatus || {});
function stringifyState2(state) {
  return JSON.stringify({
    ...state,
    resource: Reflect.has(state, "resource"),
    stepTimeout: Reflect.has(state, "stepTimeout")
  });
}
__name(stringifyState2, "stringifyState");
var _AudioPlayer = class _AudioPlayer extends import_node_events5.EventEmitter {
  /**
   * Creates a new AudioPlayer.
   */
  constructor(options = {}) {
    super();
    /**
     * The state that the AudioPlayer is in.
     */
    __publicField(this, "_state");
    /**
     * A list of VoiceConnections that are registered to this AudioPlayer. The player will attempt to play audio
     * to the streams in this list.
     */
    __publicField(this, "subscribers", []);
    /**
     * The behavior that the player should follow when it enters certain situations.
     */
    __publicField(this, "behaviors");
    /**
     * The debug logger function, if debugging is enabled.
     */
    __publicField(this, "debug");
    this._state = { status: "idle" /* Idle */ };
    this.behaviors = {
      noSubscriber: "pause" /* Pause */,
      maxMissedFrames: 5,
      ...options.behaviors
    };
    this.debug = options.debug === false ? null : (message) => this.emit("debug", message);
  }
  /**
   * A list of subscribed voice connections that can currently receive audio to play.
   */
  get playable() {
    return this.subscribers.filter(
      ({ connection }) => connection.state.status === "ready" /* Ready */
    ).map(({ connection }) => connection);
  }
  /**
   * Subscribes a VoiceConnection to the audio player's play list. If the VoiceConnection is already subscribed,
   * then the existing subscription is used.
   *
   * @remarks
   * This method should not be directly called. Instead, use VoiceConnection#subscribe.
   * @param connection - The connection to subscribe
   * @returns The new subscription if the voice connection is not yet subscribed, otherwise the existing subscription
   */
  // @ts-ignore
  subscribe(connection) {
    const existingSubscription = this.subscribers.find(
      (subscription) => subscription.connection === connection
    );
    if (!existingSubscription) {
      const subscription = new PlayerSubscription(connection, this);
      this.subscribers.push(subscription);
      setImmediate(() => this.emit("subscribe", subscription));
      return subscription;
    }
    return existingSubscription;
  }
  /**
   * Unsubscribes a subscription - i.e. removes a voice connection from the play list of the audio player.
   *
   * @remarks
   * This method should not be directly called. Instead, use PlayerSubscription#unsubscribe.
   * @param subscription - The subscription to remove
   * @returns Whether or not the subscription existed on the player and was removed
   */
  // @ts-ignore
  unsubscribe(subscription) {
    const index = this.subscribers.indexOf(subscription);
    const exists = index !== -1;
    if (exists) {
      this.subscribers.splice(index, 1);
      subscription.connection.setSpeaking(false);
      this.emit("unsubscribe", subscription);
    }
    return exists;
  }
  /**
   * The state that the player is in.
   */
  get state() {
    return this._state;
  }
  /**
   * Sets a new state for the player, performing clean-up operations where necessary.
   */
  set state(newState) {
    const oldState = this._state;
    const newResource = Reflect.get(newState, "resource");
    if (oldState.status !== "idle" /* Idle */ && oldState.resource !== newResource) {
      oldState.resource.playStream.on("error", noop);
      oldState.resource.playStream.off("error", oldState.onStreamError);
      oldState.resource.audioPlayer = void 0;
      oldState.resource.playStream.destroy();
      oldState.resource.playStream.read();
    }
    if (oldState.status === "buffering" /* Buffering */ && (newState.status !== "buffering" /* Buffering */ || newState.resource !== oldState.resource)) {
      oldState.resource.playStream.off("end", oldState.onFailureCallback);
      oldState.resource.playStream.off("close", oldState.onFailureCallback);
      oldState.resource.playStream.off("finish", oldState.onFailureCallback);
      oldState.resource.playStream.off("readable", oldState.onReadableCallback);
    }
    if (newState.status === "idle" /* Idle */) {
      this._signalStopSpeaking();
      deleteAudioPlayer(this);
    }
    if (newResource) {
      addAudioPlayer(this);
    }
    const didChangeResources = oldState.status !== "idle" /* Idle */ && newState.status === "playing" /* Playing */ && oldState.resource !== newState.resource;
    this._state = newState;
    this.emit("stateChange", oldState, this._state);
    if (oldState.status !== newState.status || didChangeResources) {
      this.emit(newState.status, oldState, this._state);
    }
    this.debug?.(
      `state change:
from ${stringifyState2(oldState)}
to ${stringifyState2(
        newState
      )}`
    );
  }
  /**
   * Plays a new resource on the player. If the player is already playing a resource, the existing resource is destroyed
   * (it cannot be reused, even in another player) and is replaced with the new resource.
   *
   * @remarks
   * The player will transition to the Playing state once playback begins, and will return to the Idle state once
   * playback is ended.
   *
   * If the player was previously playing a resource and this method is called, the player will not transition to the
   * Idle state during the swap over.
   * @param resource - The resource to play
   * @throws Will throw if attempting to play an audio resource that has already ended, or is being played by another player
   */
  play(resource) {
    if (resource.ended) {
      throw new Error("Cannot play a resource that has already ended.");
    }
    if (resource.audioPlayer) {
      if (resource.audioPlayer === this) {
        return;
      }
      throw new Error(
        "Resource is already being played by another audio player."
      );
    }
    resource.audioPlayer = this;
    const onStreamError = /* @__PURE__ */ __name((error) => {
      if (this.state.status !== "idle" /* Idle */) {
        this.emit("error", new AudioPlayerError(error, this.state.resource));
      }
      if (this.state.status !== "idle" /* Idle */ && this.state.resource === resource) {
        this.state = {
          status: "idle" /* Idle */
        };
      }
    }, "onStreamError");
    resource.playStream.once("error", onStreamError);
    if (resource.started) {
      this.state = {
        status: "playing" /* Playing */,
        missedFrames: 0,
        playbackDuration: 0,
        resource,
        onStreamError
      };
    } else {
      const onReadableCallback = /* @__PURE__ */ __name(() => {
        if (this.state.status === "buffering" /* Buffering */ && this.state.resource === resource) {
          this.state = {
            status: "playing" /* Playing */,
            missedFrames: 0,
            playbackDuration: 0,
            resource,
            onStreamError
          };
        }
      }, "onReadableCallback");
      const onFailureCallback = /* @__PURE__ */ __name(() => {
        if (this.state.status === "buffering" /* Buffering */ && this.state.resource === resource) {
          this.state = {
            status: "idle" /* Idle */
          };
        }
      }, "onFailureCallback");
      resource.playStream.once("readable", onReadableCallback);
      resource.playStream.once("end", onFailureCallback);
      resource.playStream.once("close", onFailureCallback);
      resource.playStream.once("finish", onFailureCallback);
      this.state = {
        status: "buffering" /* Buffering */,
        resource,
        onReadableCallback,
        onFailureCallback,
        onStreamError
      };
    }
  }
  /**
   * Pauses playback of the current resource, if any.
   *
   * @param interpolateSilence - If true, the player will play 5 packets of silence after pausing to prevent audio glitches
   * @returns `true` if the player was successfully paused, otherwise `false`
   */
  pause(interpolateSilence = true) {
    if (this.state.status !== "playing" /* Playing */) return false;
    this.state = {
      ...this.state,
      status: "paused" /* Paused */,
      silencePacketsRemaining: interpolateSilence ? 5 : 0
    };
    return true;
  }
  /**
   * Unpauses playback of the current resource, if any.
   *
   * @returns `true` if the player was successfully unpaused, otherwise `false`
   */
  unpause() {
    if (this.state.status !== "paused" /* Paused */) return false;
    this.state = {
      ...this.state,
      status: "playing" /* Playing */,
      missedFrames: 0
    };
    return true;
  }
  /**
   * Stops playback of the current resource and destroys the resource. The player will either transition to the Idle state,
   * or remain in its current state until the silence padding frames of the resource have been played.
   *
   * @param force - If true, will force the player to enter the Idle state even if the resource has silence padding frames
   * @returns `true` if the player will come to a stop, otherwise `false`
   */
  stop(force = false) {
    if (this.state.status === "idle" /* Idle */) return false;
    if (force || this.state.resource.silencePaddingFrames === 0) {
      this.state = {
        status: "idle" /* Idle */
      };
    } else if (this.state.resource.silenceRemaining === -1) {
      this.state.resource.silenceRemaining = this.state.resource.silencePaddingFrames;
    }
    return true;
  }
  /**
   * Checks whether the underlying resource (if any) is playable (readable)
   *
   * @returns `true` if the resource is playable, otherwise `false`
   */
  checkPlayable() {
    const state = this._state;
    if (state.status === "idle" /* Idle */ || state.status === "buffering" /* Buffering */)
      return false;
    if (!state.resource.readable) {
      this.state = {
        status: "idle" /* Idle */
      };
      return false;
    }
    return true;
  }
  /**
   * Called roughly every 20ms by the global audio player timer. Dispatches any audio packets that are buffered
   * by the active connections of this audio player.
   */
  // @ts-ignore
  _stepDispatch() {
    const state = this._state;
    if (state.status === "idle" /* Idle */ || state.status === "buffering" /* Buffering */)
      return;
    for (const connection of this.playable) {
      connection.dispatchAudio();
    }
  }
  /**
   * Called roughly every 20ms by the global audio player timer. Attempts to read an audio packet from the
   * underlying resource of the stream, and then has all the active connections of the audio player prepare it
   * (encrypt it, append header data) so that it is ready to play at the start of the next cycle.
   */
  // @ts-ignore
  _stepPrepare() {
    const state = this._state;
    if (state.status === "idle" /* Idle */ || state.status === "buffering" /* Buffering */)
      return;
    const playable = this.playable;
    if (state.status === "autopaused" /* AutoPaused */ && playable.length > 0) {
      this.state = {
        ...state,
        status: "playing" /* Playing */,
        missedFrames: 0
      };
    }
    if (state.status === "paused" /* Paused */ || state.status === "autopaused" /* AutoPaused */) {
      if (state.silencePacketsRemaining > 0) {
        state.silencePacketsRemaining--;
        this._preparePacket(SILENCE_FRAME, playable, state);
        if (state.silencePacketsRemaining === 0) {
          this._signalStopSpeaking();
        }
      }
      return;
    }
    if (playable.length === 0) {
      if (this.behaviors.noSubscriber === "pause" /* Pause */) {
        this.state = {
          ...state,
          status: "autopaused" /* AutoPaused */,
          silencePacketsRemaining: 5
        };
        return;
      } else if (this.behaviors.noSubscriber === "stop" /* Stop */) {
        this.stop(true);
      }
    }
    const packet = state.resource.read();
    if (state.status === "playing" /* Playing */) {
      if (packet) {
        this._preparePacket(packet, playable, state);
        state.missedFrames = 0;
      } else {
        this._preparePacket(SILENCE_FRAME, playable, state);
        state.missedFrames++;
        if (state.missedFrames >= this.behaviors.maxMissedFrames) {
          this.stop();
        }
      }
    }
  }
  /**
   * Signals to all the subscribed connections that they should send a packet to Discord indicating
   * they are no longer speaking. Called once playback of a resource ends.
   */
  _signalStopSpeaking() {
    for (const { connection } of this.subscribers) {
      connection.setSpeaking(false);
    }
  }
  /**
   * Instructs the given connections to each prepare this packet to be played at the start of the
   * next cycle.
   *
   * @param packet - The Opus packet to be prepared by each receiver
   * @param receivers - The connections that should play this packet
   */
  _preparePacket(packet, receivers, state) {
    state.playbackDuration += 20;
    for (const connection of receivers) {
      connection.prepareAudioPacket(packet);
    }
  }
};
__name(_AudioPlayer, "AudioPlayer");
var AudioPlayer = _AudioPlayer;
function createAudioPlayer(options) {
  return new AudioPlayer(options);
}
__name(createAudioPlayer, "createAudioPlayer");

// src/audio/AudioResource.ts
var import_node_stream = require("stream");

// src/audio/TransformerGraph.ts
var import_opus = require("@discord-player/opus");
var import_ffmpeg = require("@discord-player/ffmpeg");
var import_equalizer = require("@discord-player/equalizer");
var FFMPEG_PCM_ARGUMENTS = (0, import_ffmpeg.createFFmpegArgs)({
  analyzeduration: "0",
  loglevel: "0",
  f: "s16le",
  ar: "48000",
  ac: "2"
});
var FFMPEG_OPUS_ARGUMENTS = (0, import_ffmpeg.createFFmpegArgs)({
  analyzeduration: "0",
  loglevel: "0",
  acodec: "libopus",
  f: "opus",
  ar: "48000",
  ac: "2"
});
var StreamType = /* @__PURE__ */ ((StreamType2) => {
  StreamType2["Arbitrary"] = "arbitrary";
  StreamType2["OggOpus"] = "ogg/opus";
  StreamType2["Opus"] = "opus";
  StreamType2["Raw"] = "raw";
  StreamType2["WebmOpus"] = "webm/opus";
  return StreamType2;
})(StreamType || {});
var _Node = class _Node {
  constructor(type) {
    /**
     * The outbound edges from this node.
     */
    __publicField(this, "edges", []);
    /**
     * The type of stream for this node.
     */
    __publicField(this, "type");
    this.type = type;
  }
  /**
   * Creates an outbound edge from this node.
   *
   * @param edge - The edge to create
   */
  addEdge(edge) {
    this.edges.push({ ...edge, from: this });
  }
};
__name(_Node, "Node");
var Node = _Node;
var NODES = null;
function canEnableFFmpegOptimizations() {
  return import_ffmpeg.FFmpeg.resolveSafe()?.result.includes("--enable-libopus") === true;
}
__name(canEnableFFmpegOptimizations, "canEnableFFmpegOptimizations");
function getNode(type) {
  const node = (NODES ?? (NODES = initializeNodes())).get(type);
  if (!node) throw new Error(`Node type '${type}' does not exist!`);
  return node;
}
__name(getNode, "getNode");
function initializeNodes() {
  const nodes = /* @__PURE__ */ new Map();
  for (const streamType of Object.values(StreamType)) {
    nodes.set(streamType, new Node(streamType));
  }
  nodes.get("raw" /* Raw */).addEdge({
    type: "opus encoder" /* OpusEncoder */,
    to: nodes.get("opus" /* Opus */),
    cost: 1.5,
    transformer: /* @__PURE__ */ __name(() => new import_opus.OpusEncoder({ rate: 48e3, channels: 2, frameSize: 960 }), "transformer")
  });
  nodes.get("opus" /* Opus */).addEdge({
    type: "opus decoder" /* OpusDecoder */,
    to: nodes.get("raw" /* Raw */),
    cost: 1.5,
    transformer: /* @__PURE__ */ __name(() => new import_opus.OpusDecoder({ rate: 48e3, channels: 2, frameSize: 960 }), "transformer")
  });
  nodes.get("ogg/opus" /* OggOpus */).addEdge({
    type: "ogg/opus demuxer" /* OggOpusDemuxer */,
    to: nodes.get("opus" /* Opus */),
    cost: 1,
    transformer: /* @__PURE__ */ __name(() => new import_opus.OggDemuxer(), "transformer")
  });
  nodes.get("webm/opus" /* WebmOpus */).addEdge({
    type: "webm/opus demuxer" /* WebmOpusDemuxer */,
    to: nodes.get("opus" /* Opus */),
    cost: 1,
    transformer: /* @__PURE__ */ __name(() => new import_opus.WebmDemuxer(), "transformer")
  });
  const FFMPEG_PCM_EDGE = {
    type: "ffmpeg pcm" /* FFmpegPCM */,
    to: nodes.get("raw" /* Raw */),
    cost: 2,
    transformer: /* @__PURE__ */ __name((input) => new import_ffmpeg.FFmpeg({
      args: [
        "-i",
        typeof input === "string" ? input : "-",
        ...FFMPEG_PCM_ARGUMENTS
      ]
    }), "transformer")
  };
  nodes.get("arbitrary" /* Arbitrary */).addEdge(FFMPEG_PCM_EDGE);
  nodes.get("ogg/opus" /* OggOpus */).addEdge(FFMPEG_PCM_EDGE);
  nodes.get("webm/opus" /* WebmOpus */).addEdge(FFMPEG_PCM_EDGE);
  nodes.get("raw" /* Raw */).addEdge({
    type: "volume transformer" /* InlineVolume */,
    to: nodes.get("raw" /* Raw */),
    cost: 0.5,
    transformer: /* @__PURE__ */ __name(() => new import_equalizer.VolumeTransformer({ type: "s16le" }), "transformer")
  });
  if (canEnableFFmpegOptimizations()) {
    const FFMPEG_OGG_EDGE = {
      type: "ffmpeg ogg" /* FFmpegOgg */,
      to: nodes.get("ogg/opus" /* OggOpus */),
      cost: 2,
      transformer: /* @__PURE__ */ __name((input) => new import_ffmpeg.FFmpeg({
        args: [
          "-i",
          typeof input === "string" ? input : "-",
          ...FFMPEG_OPUS_ARGUMENTS
        ]
      }), "transformer")
    };
    nodes.get("arbitrary" /* Arbitrary */).addEdge(FFMPEG_OGG_EDGE);
    nodes.get("ogg/opus" /* OggOpus */).addEdge(FFMPEG_OGG_EDGE);
    nodes.get("webm/opus" /* WebmOpus */).addEdge(FFMPEG_OGG_EDGE);
  }
  return nodes;
}
__name(initializeNodes, "initializeNodes");
function findPath(from, constraints, goal = getNode("opus" /* Opus */), path = [], depth = 5) {
  if (from === goal && constraints(path)) {
    return { cost: 0 };
  } else if (depth === 0) {
    return { cost: Number.POSITIVE_INFINITY };
  }
  let currentBest;
  for (const edge of from.edges) {
    if (currentBest && edge.cost > currentBest.cost) continue;
    const next = findPath(
      edge.to,
      constraints,
      goal,
      [...path, edge],
      depth - 1
    );
    const cost = edge.cost + next.cost;
    if (!currentBest || cost < currentBest.cost) {
      currentBest = { cost, edge, next };
    }
  }
  return currentBest ?? { cost: Number.POSITIVE_INFINITY };
}
__name(findPath, "findPath");
function constructPipeline(step) {
  const edges = [];
  let current = step;
  while (current?.edge) {
    edges.push(current.edge);
    current = current.next;
  }
  return edges;
}
__name(constructPipeline, "constructPipeline");
function findPipeline(from, constraint) {
  return constructPipeline(findPath(getNode(from), constraint));
}
__name(findPipeline, "findPipeline");

// src/audio/AudioResource.ts
var import_opus2 = require("@discord-player/opus");
var import_equalizer2 = require("@discord-player/equalizer");
var _AudioResource = class _AudioResource {
  constructor(edges, streams, metadata, silencePaddingFrames) {
    /**
     * An object-mode Readable stream that emits Opus packets. This is what is played by audio players.
     */
    __publicField(this, "playStream");
    /**
     * The pipeline used to convert the input stream into a playable format. For example, this may
     * contain an FFmpeg component for arbitrary inputs, and it may contain a VolumeTransformer component
     * for resources with inline volume transformation enabled.
     */
    __publicField(this, "edges");
    /**
     * Optional metadata that can be used to identify the resource.
     */
    __publicField(this, "metadata");
    /**
     * If the resource was created with inline volume transformation enabled, then this will be a
     * `@discord-player/equalizer` VolumeTransformer. You can use this to alter the volume of the stream.
     */
    __publicField(this, "volume");
    /**
     * If using an Opus encoder to create this audio resource, then this will be a`@discord-player/opus` opus.Encoder.
     * You can use this to control settings such as bitrate, FEC, PLP.
     */
    __publicField(this, "encoder");
    /**
     * The audio player that the resource is subscribed to, if any.
     */
    __publicField(this, "audioPlayer");
    /**
     * The playback duration of this audio resource, given in milliseconds.
     */
    __publicField(this, "playbackDuration", 0);
    /**
     * Whether or not the stream for this resource has started (data has become readable)
     */
    __publicField(this, "started", false);
    /**
     * The number of silence frames to append to the end of the resource's audio stream, to prevent interpolation glitches.
     */
    __publicField(this, "silencePaddingFrames");
    /**
     * The number of remaining silence frames to play. If -1, the frames have not yet started playing.
     */
    __publicField(this, "silenceRemaining", -1);
    this.edges = edges;
    this.playStream = streams.length > 1 ? (0, import_node_stream.pipeline)(streams, noop) : streams[0];
    this.metadata = metadata;
    this.silencePaddingFrames = silencePaddingFrames;
    for (const stream of streams) {
      if (stream instanceof import_equalizer2.VolumeTransformer) {
        this.volume = stream;
      } else if (stream instanceof import_opus2.OpusEncoder) {
        this.encoder = stream;
      }
    }
    this.playStream.once("readable", () => this.started = true);
  }
  /**
   * Whether this resource is readable. If the underlying resource is no longer readable, this will still return true
   * while there are silence padding frames left to play.
   */
  get readable() {
    if (this.silenceRemaining === 0) return false;
    const real = this.playStream.readable;
    if (!real) {
      if (this.silenceRemaining === -1)
        this.silenceRemaining = this.silencePaddingFrames;
      return this.silenceRemaining !== 0;
    }
    return real;
  }
  /**
   * Whether this resource has ended or not.
   */
  get ended() {
    return this.playStream.readableEnded || this.playStream.destroyed || this.silenceRemaining === 0;
  }
  /**
   * Attempts to read an Opus packet from the audio resource. If a packet is available, the playbackDuration
   * is incremented.
   *
   * @remarks
   * It is advisable to check that the playStream is readable before calling this method. While no runtime
   * errors will be thrown, you should check that the resource is still available before attempting to
   * read from it.
   * @internal
   */
  read() {
    if (this.silenceRemaining === 0) {
      return null;
    } else if (this.silenceRemaining > 0) {
      this.silenceRemaining--;
      return SILENCE_FRAME;
    }
    const packet = this.playStream.read();
    if (packet) {
      this.playbackDuration += 20;
    }
    return packet;
  }
};
__name(_AudioResource, "AudioResource");
var AudioResource = _AudioResource;
var VOLUME_CONSTRAINT = /* @__PURE__ */ __name((path) => path.some((edge) => edge.type === "volume transformer" /* InlineVolume */), "VOLUME_CONSTRAINT");
var NO_CONSTRAINT = /* @__PURE__ */ __name(() => true, "NO_CONSTRAINT");
function inferStreamType(stream) {
  if (stream instanceof import_opus2.OpusEncoder) {
    return { streamType: "opus" /* Opus */, hasVolume: false };
  } else if (stream instanceof import_opus2.OpusDecoder) {
    return { streamType: "raw" /* Raw */, hasVolume: false };
  } else if (stream instanceof import_equalizer2.VolumeTransformer) {
    return { streamType: "raw" /* Raw */, hasVolume: true };
  } else if (stream instanceof import_opus2.OggDemuxer) {
    return { streamType: "opus" /* Opus */, hasVolume: false };
  } else if (stream instanceof import_opus2.WebmDemuxer) {
    return { streamType: "opus" /* Opus */, hasVolume: false };
  }
  return { streamType: "arbitrary" /* Arbitrary */, hasVolume: false };
}
__name(inferStreamType, "inferStreamType");
function createAudioResource(input, options = {}) {
  let inputType = options.inputType;
  let needsInlineVolume = Boolean(options.inlineVolume);
  if (typeof input === "string") {
    inputType = "arbitrary" /* Arbitrary */;
  } else if (inputType === void 0) {
    const analysis = inferStreamType(input);
    inputType = analysis.streamType;
    needsInlineVolume = needsInlineVolume && !analysis.hasVolume;
  }
  const transformerPipeline = findPipeline(
    inputType,
    needsInlineVolume ? VOLUME_CONSTRAINT : NO_CONSTRAINT
  );
  if (transformerPipeline.length === 0) {
    if (typeof input === "string")
      throw new Error(
        `Invalid pipeline constructed for string resource '${input}'`
      );
    return new AudioResource(
      [],
      [input],
      options.metadata ?? null,
      options.silencePaddingFrames ?? 5
    );
  }
  const streams = transformerPipeline.map((edge) => edge.transformer(input));
  if (typeof input !== "string") streams.unshift(input);
  return new AudioResource(
    transformerPipeline,
    streams,
    options.metadata ?? null,
    options.silencePaddingFrames ?? 5
  );
}
__name(createAudioResource, "createAudioResource");

// src/util/entersState.ts
var import_node_events6 = require("events");

// src/util/abortAfter.ts
function abortAfter(delay) {
  const ac = new AbortController();
  const timeout = setTimeout(() => ac.abort(), delay);
  ac.signal.addEventListener("abort", () => clearTimeout(timeout));
  return [ac, ac.signal];
}
__name(abortAfter, "abortAfter");

// src/util/entersState.ts
async function entersState(target, status, timeoutOrSignal) {
  if (target.state.status !== status) {
    const [ac, signal] = typeof timeoutOrSignal === "number" ? abortAfter(timeoutOrSignal) : [void 0, timeoutOrSignal];
    try {
      await (0, import_node_events6.once)(target, status, { signal });
    } finally {
      ac?.abort();
    }
  }
  return target;
}
__name(entersState, "entersState");

// src/version.ts
var version = (
  /* @__MACRO__ getVersion */
  "7.1.0"
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AudioPlayer,
  AudioPlayerError,
  AudioPlayerStatus,
  AudioResource,
  NoSubscriberBehavior,
  PlayerSubscription,
  StreamType,
  VoiceConnection,
  VoiceConnectionDisconnectReason,
  VoiceConnectionStatus,
  createAudioPlayer,
  createAudioResource,
  entersState,
  getGroups,
  getVoiceConnection,
  getVoiceConnections,
  joinVoiceChannel,
  version
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9Wb2ljZUNvbm5lY3Rpb24udHMiLCAiLi4vc3JjL0RhdGFTdG9yZS50cyIsICIuLi9zcmMvbmV0d29ya2luZy9OZXR3b3JraW5nLnRzIiwgIi4uL3NyYy91dGlsL1NlY3JldGJveC50cyIsICIuLi9zcmMvdXRpbC91dGlsLnRzIiwgIi4uL3NyYy9uZXR3b3JraW5nL1ZvaWNlVURQU29ja2V0LnRzIiwgIi4uL3NyYy9uZXR3b3JraW5nL1ZvaWNlV2ViU29ja2V0LnRzIiwgIi4uL3NyYy9qb2luVm9pY2VDaGFubmVsLnRzIiwgIi4uL3NyYy9hdWRpby9BdWRpb1BsYXllci50cyIsICIuLi9zcmMvYXVkaW8vQXVkaW9QbGF5ZXJFcnJvci50cyIsICIuLi9zcmMvYXVkaW8vUGxheWVyU3Vic2NyaXB0aW9uLnRzIiwgIi4uL3NyYy9hdWRpby9BdWRpb1Jlc291cmNlLnRzIiwgIi4uL3NyYy9hdWRpby9UcmFuc2Zvcm1lckdyYXBoLnRzIiwgIi4uL3NyYy91dGlsL2VudGVyc1N0YXRlLnRzIiwgIi4uL3NyYy91dGlsL2Fib3J0QWZ0ZXIudHMiLCAiLi4vc3JjL3ZlcnNpb24udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG5leHBvcnQgKiBmcm9tICcuL2pvaW5Wb2ljZUNoYW5uZWwnO1xuZXhwb3J0ICogZnJvbSAnLi9hdWRpby9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWwvaW5kZXgnO1xuXG5leHBvcnQge1xuICBWb2ljZUNvbm5lY3Rpb24sXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uU3RhdGUsXG4gIFZvaWNlQ29ubmVjdGlvblN0YXR1cyxcbiAgdHlwZSBWb2ljZUNvbm5lY3Rpb25Db25uZWN0aW5nU3RhdGUsXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uRGVzdHJveWVkU3RhdGUsXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkU3RhdGUsXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkQmFzZVN0YXRlLFxuICB0eXBlIFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZE90aGVyU3RhdGUsXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkV2ViU29ja2V0U3RhdGUsXG4gIFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RSZWFzb24sXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uUmVhZHlTdGF0ZSxcbiAgdHlwZSBWb2ljZUNvbm5lY3Rpb25TaWduYWxsaW5nU3RhdGUgfSBmcm9tXG4nLi9Wb2ljZUNvbm5lY3Rpb24nO1xuXG5leHBvcnQge1xuICB0eXBlIEpvaW5Db25maWcsXG4gIGdldFZvaWNlQ29ubmVjdGlvbixcbiAgZ2V0Vm9pY2VDb25uZWN0aW9ucyxcbiAgZ2V0R3JvdXBzIH0gZnJvbVxuJy4vRGF0YVN0b3JlJztcblxuZXhwb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7IiwgIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2QsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZGVjbGFyYXRpb24tbWVyZ2luZyAqL1xuXG5pbXBvcnQgdHlwZSB7IEJ1ZmZlciB9IGZyb20gJ25vZGU6YnVmZmVyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ25vZGU6ZXZlbnRzJztcbmltcG9ydCB0eXBlIHtcbiAgR2F0ZXdheVZvaWNlU2VydmVyVXBkYXRlRGlzcGF0Y2hEYXRhLFxuICBHYXRld2F5Vm9pY2VTdGF0ZVVwZGF0ZURpc3BhdGNoRGF0YSB9IGZyb21cbidkaXNjb3JkLWFwaS10eXBlcy92MTAnO1xuaW1wb3J0IHR5cGUgeyBKb2luQ29uZmlnIH0gZnJvbSAnLi9EYXRhU3RvcmUnO1xuaW1wb3J0IHtcbiAgZ2V0Vm9pY2VDb25uZWN0aW9uLFxuICBjcmVhdGVKb2luVm9pY2VDaGFubmVsUGF5bG9hZCxcbiAgdHJhY2tWb2ljZUNvbm5lY3Rpb24sXG4gIHVudHJhY2tWb2ljZUNvbm5lY3Rpb24gfSBmcm9tXG4nLi9EYXRhU3RvcmUnO1xuaW1wb3J0IHR5cGUgeyBBdWRpb1BsYXllciB9IGZyb20gJy4vYXVkaW8vQXVkaW9QbGF5ZXInO1xuaW1wb3J0IHR5cGUgeyBQbGF5ZXJTdWJzY3JpcHRpb24gfSBmcm9tICcuL2F1ZGlvL1BsYXllclN1YnNjcmlwdGlvbic7XG5pbXBvcnQge1xuICBOZXR3b3JraW5nLFxuICBOZXR3b3JraW5nU3RhdHVzQ29kZSxcbiAgdHlwZSBOZXR3b3JraW5nU3RhdGUgfSBmcm9tXG4nLi9uZXR3b3JraW5nL05ldHdvcmtpbmcnO1xuaW1wb3J0IHR5cGUgeyBEaXNjb3JkR2F0ZXdheUFkYXB0ZXJJbXBsZW1lbnRlck1ldGhvZHMgfSBmcm9tICcuL3V0aWwvYWRhcHRlcic7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi91dGlsL3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBDcmVhdGVWb2ljZUNvbm5lY3Rpb25PcHRpb25zIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyB1bnNhZmUgfSBmcm9tICcuL2NvbW1vbi90eXBlcyc7XG5cbi8qKlxuICogVGhlIHZhcmlvdXMgc3RhdHVzIGNvZGVzIGEgdm9pY2UgY29ubmVjdGlvbiBjYW4gaG9sZCBhdCBhbnkgb25lIHRpbWUuXG4gKi9cbmV4cG9ydCBlbnVtIFZvaWNlQ29ubmVjdGlvblN0YXR1cyB7XG4gIC8qKlxuICAgKiBUaGUgYFZPSUNFX1NFUlZFUl9VUERBVEVgIGFuZCBgVk9JQ0VfU1RBVEVfVVBEQVRFYCBwYWNrZXRzIGhhdmUgYmVlbiByZWNlaXZlZCwgbm93IGF0dGVtcHRpbmcgdG8gZXN0YWJsaXNoIGEgdm9pY2UgY29ubmVjdGlvbi5cbiAgICovXG4gIENvbm5lY3RpbmcgPSAnY29ubmVjdGluZycsXG5cbiAgLyoqXG4gICAqIFRoZSB2b2ljZSBjb25uZWN0aW9uIGhhcyBiZWVuIGRlc3Ryb3llZCBhbmQgdW50cmFja2VkLCBpdCBjYW5ub3QgYmUgcmV1c2VkLlxuICAgKi9cbiAgRGVzdHJveWVkID0gJ2Rlc3Ryb3llZCcsXG5cbiAgLyoqXG4gICAqIFRoZSB2b2ljZSBjb25uZWN0aW9uIGhhcyBlaXRoZXIgYmVlbiBzZXZlcmVkIG9yIG5vdCBlc3RhYmxpc2hlZC5cbiAgICovXG4gIERpc2Nvbm5lY3RlZCA9ICdkaXNjb25uZWN0ZWQnLFxuXG4gIC8qKlxuICAgKiBBIHZvaWNlIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQsIGFuZCBpcyByZWFkeSB0byBiZSB1c2VkLlxuICAgKi9cbiAgUmVhZHkgPSAncmVhZHknLFxuXG4gIC8qKlxuICAgKiBTZW5kaW5nIGEgcGFja2V0IHRvIHRoZSBtYWluIERpc2NvcmQgZ2F0ZXdheSB0byBpbmRpY2F0ZSB3ZSB3YW50IHRvIGNoYW5nZSBvdXIgdm9pY2Ugc3RhdGUuXG4gICAqL1xuICBTaWduYWxsaW5nID0gJ3NpZ25hbGxpbmcnLFxufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSB0aGF0IGEgVm9pY2VDb25uZWN0aW9uIHdpbGwgYmUgaW4gd2hlbiBpdCBpcyB3YWl0aW5nIHRvIHJlY2VpdmUgYSBWT0lDRV9TRVJWRVJfVVBEQVRFIGFuZFxuICogVk9JQ0VfU1RBVEVfVVBEQVRFIHBhY2tldCBmcm9tIERpc2NvcmQsIHByb3ZpZGVkIGJ5IHRoZSBhZGFwdGVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvaWNlQ29ubmVjdGlvblNpZ25hbGxpbmdTdGF0ZSB7XG4gIGFkYXB0ZXI6IERpc2NvcmRHYXRld2F5QWRhcHRlckltcGxlbWVudGVyTWV0aG9kcztcbiAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuU2lnbmFsbGluZztcbiAgc3Vic2NyaXB0aW9uPzogUGxheWVyU3Vic2NyaXB0aW9uIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSByZWFzb25zIGEgdm9pY2UgY29ubmVjdGlvbiBjYW4gYmUgaW4gdGhlIGRpc2Nvbm5lY3RlZCBzdGF0ZS5cbiAqL1xuZXhwb3J0IGVudW0gVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdFJlYXNvbiB7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQuXG4gICAqL1xuICBXZWJTb2NrZXRDbG9zZSxcblxuICAvKipcbiAgICogV2hlbiB0aGUgYWRhcHRlciB3YXMgdW5hYmxlIHRvIHNlbmQgYSBtZXNzYWdlIHJlcXVlc3RlZCBieSB0aGUgVm9pY2VDb25uZWN0aW9uLlxuICAgKi9cbiAgQWRhcHRlclVuYXZhaWxhYmxlLFxuXG4gIC8qKlxuICAgKiBXaGVuIGEgVk9JQ0VfU0VSVkVSX1VQREFURSBwYWNrZXQgaXMgcmVjZWl2ZWQgd2l0aCBhIG51bGwgZW5kcG9pbnQsIGNhdXNpbmcgdGhlIGNvbm5lY3Rpb24gdG8gYmUgc2V2ZXJlZC5cbiAgICovXG4gIEVuZHBvaW50UmVtb3ZlZCxcblxuICAvKipcbiAgICogV2hlbiBhIG1hbnVhbCBkaXNjb25uZWN0IHdhcyByZXF1ZXN0ZWQuXG4gICAqL1xuICBNYW51YWwsXG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBWb2ljZUNvbm5lY3Rpb24gd2lsbCBiZSBpbiB3aGVuIGl0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYSBEaXNjb3JkIHZvaWNlIHNlcnZlciBub3IgaXNcbiAqIGl0IGF0dGVtcHRpbmcgdG8gY29ubmVjdC4gWW91IGNhbiBtYW51YWxseSBhdHRlbXB0IHRvIHJlY29ubmVjdCB1c2luZyBWb2ljZUNvbm5lY3Rpb24jcmVjb25uZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEJhc2VTdGF0ZSB7XG4gIGFkYXB0ZXI6IERpc2NvcmRHYXRld2F5QWRhcHRlckltcGxlbWVudGVyTWV0aG9kcztcbiAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGlzY29ubmVjdGVkO1xuICBzdWJzY3JpcHRpb24/OiBQbGF5ZXJTdWJzY3JpcHRpb24gfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBWb2ljZUNvbm5lY3Rpb24gd2lsbCBiZSBpbiB3aGVuIGl0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYSBEaXNjb3JkIHZvaWNlIHNlcnZlciBub3IgaXNcbiAqIGl0IGF0dGVtcHRpbmcgdG8gY29ubmVjdC4gWW91IGNhbiBtYW51YWxseSBhdHRlbXB0IHRvIHJlY29ubmVjdCB1c2luZyBWb2ljZUNvbm5lY3Rpb24jcmVjb25uZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZE90aGVyU3RhdGUgZXh0ZW5kc1xuICBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0ZWRCYXNlU3RhdGUge1xuICByZWFzb246IEV4Y2x1ZGU8XG4gICAgVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdFJlYXNvbixcbiAgICBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLldlYlNvY2tldENsb3NlPjtcblxufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSB0aGF0IGEgVm9pY2VDb25uZWN0aW9uIHdpbGwgYmUgaW4gd2hlbiBpdHMgV2ViU29ja2V0IGNvbm5lY3Rpb24gd2FzIGNsb3NlZC5cbiAqIFlvdSBjYW4gbWFudWFsbHkgYXR0ZW1wdCB0byByZWNvbm5lY3QgdXNpbmcgVm9pY2VDb25uZWN0aW9uI3JlY29ubmVjdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0ZWRXZWJTb2NrZXRTdGF0ZSBleHRlbmRzXG4gIFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEJhc2VTdGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgY2xvc2UgY29kZSBvZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIERpc2NvcmQgdm9pY2Ugc2VydmVyLlxuICAgKi9cbiAgY2xvc2VDb2RlOiBudW1iZXI7XG5cbiAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLldlYlNvY2tldENsb3NlO1xufVxuXG4vKipcbiAqIFRoZSBzdGF0ZXMgdGhhdCBhIFZvaWNlQ29ubmVjdGlvbiBjYW4gYmUgaW4gd2hlbiBpdCBpcyBub3QgY29ubmVjdGVkIHRvIGEgRGlzY29yZCB2b2ljZSBzZXJ2ZXIgbm9yIGlzXG4gKiBpdCBhdHRlbXB0aW5nIHRvIGNvbm5lY3QuIFlvdSBjYW4gbWFudWFsbHkgYXR0ZW1wdCB0byBjb25uZWN0IHVzaW5nIFZvaWNlQ29ubmVjdGlvbiNyZWNvbm5lY3QuXG4gKi9cbmV4cG9ydCB0eXBlIFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZFN0YXRlID1cblZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZE90aGVyU3RhdGUgfFxuVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkV2ViU29ja2V0U3RhdGU7XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBWb2ljZUNvbm5lY3Rpb24gd2lsbCBiZSBpbiB3aGVuIGl0IGlzIGVzdGFibGlzaGluZyBhIGNvbm5lY3Rpb24gdG8gYSBEaXNjb3JkXG4gKiB2b2ljZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVm9pY2VDb25uZWN0aW9uQ29ubmVjdGluZ1N0YXRlIHtcbiAgYWRhcHRlcjogRGlzY29yZEdhdGV3YXlBZGFwdGVySW1wbGVtZW50ZXJNZXRob2RzO1xuICBuZXR3b3JraW5nOiBOZXR3b3JraW5nO1xuICBzdGF0dXM6IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5Db25uZWN0aW5nO1xuICBzdWJzY3JpcHRpb24/OiBQbGF5ZXJTdWJzY3JpcHRpb24gfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBWb2ljZUNvbm5lY3Rpb24gd2lsbCBiZSBpbiB3aGVuIGl0IGhhcyBhbiBhY3RpdmUgY29ubmVjdGlvbiB0byBhIERpc2NvcmRcbiAqIHZvaWNlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWb2ljZUNvbm5lY3Rpb25SZWFkeVN0YXRlIHtcbiAgYWRhcHRlcjogRGlzY29yZEdhdGV3YXlBZGFwdGVySW1wbGVtZW50ZXJNZXRob2RzO1xuICBuZXR3b3JraW5nOiBOZXR3b3JraW5nO1xuICBzdGF0dXM6IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5SZWFkeTtcbiAgc3Vic2NyaXB0aW9uPzogUGxheWVyU3Vic2NyaXB0aW9uIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSB0aGF0IGEgVm9pY2VDb25uZWN0aW9uIHdpbGwgYmUgaW4gd2hlbiBpdCBoYXMgYmVlbiBwZXJtYW5lbnRseSBiZWVuIGRlc3Ryb3llZCBieSB0aGVcbiAqIHVzZXIgYW5kIHVudHJhY2tlZCBieSB0aGUgbGlicmFyeS4gSXQgY2Fubm90IGJlIHJlY29ubmVjdGVkLCBpbnN0ZWFkLCBhIG5ldyBWb2ljZUNvbm5lY3Rpb25cbiAqIG5lZWRzIHRvIGJlIGVzdGFibGlzaGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvaWNlQ29ubmVjdGlvbkRlc3Ryb3llZFN0YXRlIHtcbiAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGVzdHJveWVkO1xufVxuXG4vKipcbiAqIFRoZSB2YXJpb3VzIHN0YXRlcyB0aGF0IGEgdm9pY2UgY29ubmVjdGlvbiBjYW4gYmUgaW4uXG4gKi9cbmV4cG9ydCB0eXBlIFZvaWNlQ29ubmVjdGlvblN0YXRlID1cblZvaWNlQ29ubmVjdGlvbkNvbm5lY3RpbmdTdGF0ZSB8XG5Wb2ljZUNvbm5lY3Rpb25EZXN0cm95ZWRTdGF0ZSB8XG5Wb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0ZWRTdGF0ZSB8XG5Wb2ljZUNvbm5lY3Rpb25SZWFkeVN0YXRlIHxcblZvaWNlQ29ubmVjdGlvblNpZ25hbGxpbmdTdGF0ZTtcblxuZXhwb3J0IGludGVyZmFjZSBWb2ljZUNvbm5lY3Rpb24gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGVtaXR0ZWQgZnJvbSB0aGUgdm9pY2UgY29ubmVjdGlvblxuICAgKlxuICAgKiBAZXZlbnRQcm9wZXJ0eVxuICAgKi9cbiAgb24oZXZlbnQ6ICdlcnJvcicsIGxpc3RlbmVyOiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkKTogdGhpcztcbiAgLyoqXG4gICAqIEVtaXR0ZWQgZGVidWdnaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2b2ljZSBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBldmVudFByb3BlcnR5XG4gICAqL1xuICBvbihldmVudDogJ2RlYnVnJywgbGlzdGVuZXI6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpOiB0aGlzO1xuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIHRoZSBzdGF0ZSBvZiB0aGUgdm9pY2UgY29ubmVjdGlvbiBjaGFuZ2VzXG4gICAqXG4gICAqIEBldmVudFByb3BlcnR5XG4gICAqL1xuICBvbihcbiAgZXZlbnQ6ICdzdGF0ZUNoYW5nZScsXG4gIGxpc3RlbmVyOiAoXG4gIG9sZFN0YXRlOiBWb2ljZUNvbm5lY3Rpb25TdGF0ZSxcbiAgbmV3U3RhdGU6IFZvaWNlQ29ubmVjdGlvblN0YXRlKVxuICA9PiB2b2lkKVxuICA6IHRoaXM7XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSB2b2ljZSBjb25uZWN0aW9uIGNoYW5nZXMgdG8gYSBzcGVjaWZpYyBzdGF0dXNcbiAgICpcbiAgICogQGV2ZW50UHJvcGVydHlcbiAgICovXG4gIG9uPEV2ZW50IGV4dGVuZHMgVm9pY2VDb25uZWN0aW9uU3RhdHVzPihcbiAgZXZlbnQ6IEV2ZW50LFxuICBsaXN0ZW5lcjogKFxuICBvbGRTdGF0ZTogVm9pY2VDb25uZWN0aW9uU3RhdGUsXG4gIG5ld1N0YXRlOiBWb2ljZUNvbm5lY3Rpb25TdGF0ZSAmIHtzdGF0dXM6IEV2ZW50O30pXG4gID0+IHZvaWQpXG4gIDogdGhpcztcbn1cblxuLyoqXG4gKiBBIGNvbm5lY3Rpb24gdG8gdGhlIHZvaWNlIHNlcnZlciBvZiBhIEd1aWxkLCBjYW4gYmUgdXNlZCB0byBwbGF5IGF1ZGlvIGluIHZvaWNlIGNoYW5uZWxzLlxuICovXG5leHBvcnQgY2xhc3MgVm9pY2VDb25uZWN0aW9uIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgY29uc2VjdXRpdmUgcmVqb2luIGF0dGVtcHRzLiBJbml0aWFsbHkgMCwgYW5kIGluY3JlbWVudHMgZm9yIGVhY2ggcmVqb2luLlxuICAgKiBXaGVuIGEgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQsIGl0IHJlc2V0cyB0byAwLlxuICAgKi9cbiAgcHVibGljIHJlam9pbkF0dGVtcHRzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBzdGF0ZSBvZiB0aGUgdm9pY2UgY29ubmVjdGlvbi5cbiAgICovXG4gIHByaXZhdGUgX3N0YXRlOiBWb2ljZUNvbm5lY3Rpb25TdGF0ZTtcblxuICAvKipcbiAgICogQSBjb25maWd1cmF0aW9uIHN0b3JpbmcgYWxsIHRoZSBkYXRhIG5lZWRlZCB0byByZWNvbm5lY3QgdG8gYSBHdWlsZCdzIHZvaWNlIHNlcnZlci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgam9pbkNvbmZpZzogSm9pbkNvbmZpZztcblxuICAvKipcbiAgICogVGhlIHR3byBwYWNrZXRzIG5lZWRlZCB0byBzdWNjZXNzZnVsbHkgZXN0YWJsaXNoIGEgdm9pY2UgY29ubmVjdGlvbi4gVGhleSBhcmUgcmVjZWl2ZWRcbiAgICogZnJvbSB0aGUgbWFpbiBEaXNjb3JkIGdhdGV3YXkgYWZ0ZXIgc2lnbmFsbGluZyB0byBjaGFuZ2UgdGhlIHZvaWNlIHN0YXRlLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBwYWNrZXRzOiB7XG4gICAgc2VydmVyOiBHYXRld2F5Vm9pY2VTZXJ2ZXJVcGRhdGVEaXNwYXRjaERhdGEgfCB1bmRlZmluZWQ7XG4gICAgc3RhdGU6IEdhdGV3YXlWb2ljZVN0YXRlVXBkYXRlRGlzcGF0Y2hEYXRhIHwgdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZGVidWcgbG9nZ2VyIGZ1bmN0aW9uLCBpZiBkZWJ1Z2dpbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgZGVidWc6ICgobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdm9pY2UgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGpvaW5Db25maWcgLSBUaGUgZGF0YSByZXF1aXJlZCB0byBlc3RhYmxpc2ggdGhlIHZvaWNlIGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGlzIHZvaWNlIGNvbm5lY3Rpb25cbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgam9pbkNvbmZpZzogSm9pbkNvbmZpZyxcbiAgb3B0aW9uczogQ3JlYXRlVm9pY2VDb25uZWN0aW9uT3B0aW9ucylcbiAge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZyA/XG4gICAgKG1lc3NhZ2U6IHN0cmluZykgPT4gdGhpcy5lbWl0KCdkZWJ1ZycsIG1lc3NhZ2UpIDpcbiAgICBudWxsO1xuICAgIHRoaXMucmVqb2luQXR0ZW1wdHMgPSAwO1xuXG4gICAgdGhpcy5vbk5ldHdvcmtpbmdDbG9zZSA9IHRoaXMub25OZXR3b3JraW5nQ2xvc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTmV0d29ya2luZ1N0YXRlQ2hhbmdlID0gdGhpcy5vbk5ldHdvcmtpbmdTdGF0ZUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25OZXR3b3JraW5nRXJyb3IgPSB0aGlzLm9uTmV0d29ya2luZ0Vycm9yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbk5ldHdvcmtpbmdEZWJ1ZyA9IHRoaXMub25OZXR3b3JraW5nRGVidWcuYmluZCh0aGlzKTtcblxuICAgIGNvbnN0IGFkYXB0ZXIgPSBvcHRpb25zLmFkYXB0ZXJDcmVhdG9yKHtcbiAgICAgIG9uVm9pY2VTZXJ2ZXJVcGRhdGU6IChkYXRhKSA9PiB0aGlzLmFkZFNlcnZlclBhY2tldChkYXRhKSxcbiAgICAgIG9uVm9pY2VTdGF0ZVVwZGF0ZTogKGRhdGEpID0+IHRoaXMuYWRkU3RhdGVQYWNrZXQoZGF0YSksXG4gICAgICBkZXN0cm95OiAoKSA9PiB0aGlzLmRlc3Ryb3koZmFsc2UpXG4gICAgfSk7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IHsgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuU2lnbmFsbGluZywgYWRhcHRlciB9O1xuXG4gICAgdGhpcy5wYWNrZXRzID0ge1xuICAgICAgc2VydmVyOiB1bmRlZmluZWQsXG4gICAgICBzdGF0ZTogdW5kZWZpbmVkXG4gICAgfTtcblxuICAgIHRoaXMuam9pbkNvbmZpZyA9IGpvaW5Db25maWc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHZvaWNlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgdm9pY2UgY29ubmVjdGlvbiwgcGVyZm9ybWluZyBjbGVhbi11cCBvcGVyYXRpb25zIHdoZXJlIG5lY2Vzc2FyeS5cbiAgICovXG4gIHB1YmxpYyBzZXQgc3RhdGUobmV3U3RhdGU6IFZvaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBjb25zdCBvbGROZXR3b3JraW5nID0gUmVmbGVjdC5nZXQob2xkU3RhdGUsICduZXR3b3JraW5nJykgYXNcbiAgICBOZXR3b3JraW5nIHxcbiAgICB1bmRlZmluZWQ7XG4gICAgY29uc3QgbmV3TmV0d29ya2luZyA9IFJlZmxlY3QuZ2V0KG5ld1N0YXRlLCAnbmV0d29ya2luZycpIGFzXG4gICAgTmV0d29ya2luZyB8XG4gICAgdW5kZWZpbmVkO1xuXG4gICAgY29uc3Qgb2xkU3Vic2NyaXB0aW9uID0gUmVmbGVjdC5nZXQob2xkU3RhdGUsICdzdWJzY3JpcHRpb24nKSBhc1xuICAgIFBsYXllclN1YnNjcmlwdGlvbiB8XG4gICAgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5ld1N1YnNjcmlwdGlvbiA9IFJlZmxlY3QuZ2V0KG5ld1N0YXRlLCAnc3Vic2NyaXB0aW9uJykgYXNcbiAgICBQbGF5ZXJTdWJzY3JpcHRpb24gfFxuICAgIHVuZGVmaW5lZDtcblxuICAgIGlmIChvbGROZXR3b3JraW5nICE9PSBuZXdOZXR3b3JraW5nKSB7XG4gICAgICBpZiAob2xkTmV0d29ya2luZykge1xuICAgICAgICBvbGROZXR3b3JraW5nLm9uKCdlcnJvcicsIG5vb3ApO1xuICAgICAgICBvbGROZXR3b3JraW5nLm9mZignZGVidWcnLCB0aGlzLm9uTmV0d29ya2luZ0RlYnVnKTtcbiAgICAgICAgb2xkTmV0d29ya2luZy5vZmYoJ2Vycm9yJywgdGhpcy5vbk5ldHdvcmtpbmdFcnJvcik7XG4gICAgICAgIG9sZE5ldHdvcmtpbmcub2ZmKCdjbG9zZScsIHRoaXMub25OZXR3b3JraW5nQ2xvc2UpO1xuICAgICAgICBvbGROZXR3b3JraW5nLm9mZignc3RhdGVDaGFuZ2UnLCB0aGlzLm9uTmV0d29ya2luZ1N0YXRlQ2hhbmdlKTtcbiAgICAgICAgb2xkTmV0d29ya2luZy5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld1N0YXRlLnN0YXR1cyA9PT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLlJlYWR5KSB7XG4gICAgICB0aGlzLnJlam9pbkF0dGVtcHRzID0gMDtcbiAgICB9XG5cbiAgICAvLyBJZiBkZXN0cm95ZWQsIHRoZSBhZGFwdGVyIGNhbiBhbHNvIGJlIGRlc3Ryb3llZCBzbyBpdCBjYW4gYmUgY2xlYW5lZCB1cCBieSB0aGUgdXNlclxuICAgIGlmIChcbiAgICBvbGRTdGF0ZS5zdGF0dXMgIT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQgJiZcbiAgICBuZXdTdGF0ZS5zdGF0dXMgPT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQpXG4gICAge1xuICAgICAgb2xkU3RhdGUuYWRhcHRlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcblxuICAgIGlmIChvbGRTdWJzY3JpcHRpb24gJiYgb2xkU3Vic2NyaXB0aW9uICE9PSBuZXdTdWJzY3JpcHRpb24pIHtcbiAgICAgIG9sZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2UnLCBvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgIGlmIChvbGRTdGF0ZS5zdGF0dXMgIT09IG5ld1N0YXRlLnN0YXR1cykge1xuICAgICAgdGhpcy5lbWl0KG5ld1N0YXRlLnN0YXR1cywgb2xkU3RhdGUsIG5ld1N0YXRlIGFzIHVuc2FmZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGBWT0lDRV9TRVJWRVJfVVBEQVRFYCBwYWNrZXQgdG8gdGhlIHZvaWNlIGNvbm5lY3Rpb24uIFRoaXMgd2lsbCBjYXVzZSBpdCB0byByZWNvbm5lY3QgdXNpbmcgdGhlXG4gICAqIG5ldyBkYXRhIHByb3ZpZGVkIGluIHRoZSBwYWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBwYWNrZXQgLSBUaGUgcmVjZWl2ZWQgYFZPSUNFX1NFUlZFUl9VUERBVEVgIHBhY2tldFxuICAgKi9cbiAgcHJpdmF0ZSBhZGRTZXJ2ZXJQYWNrZXQocGFja2V0OiBHYXRld2F5Vm9pY2VTZXJ2ZXJVcGRhdGVEaXNwYXRjaERhdGEpIHtcbiAgICB0aGlzLnBhY2tldHMuc2VydmVyID0gcGFja2V0O1xuICAgIGlmIChwYWNrZXQuZW5kcG9pbnQpIHtcbiAgICAgIHRoaXMuY29uZmlndXJlTmV0d29ya2luZygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgIT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZCxcbiAgICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLkVuZHBvaW50UmVtb3ZlZFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgYFZPSUNFX1NUQVRFX1VQREFURWAgcGFja2V0IHRvIHRoZSB2b2ljZSBjb25uZWN0aW9uLiBNb3N0IGltcG9ydGFudGx5LCBpdCBzdG9yZXMgdGhlIGlkIG9mIHRoZVxuICAgKiBjaGFubmVsIHRoYXQgdGhlIGNsaWVudCBpcyBjb25uZWN0ZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSBwYWNrZXQgLSBUaGUgcmVjZWl2ZWQgYFZPSUNFX1NUQVRFX1VQREFURWAgcGFja2V0XG4gICAqL1xuICBwcml2YXRlIGFkZFN0YXRlUGFja2V0KHBhY2tldDogR2F0ZXdheVZvaWNlU3RhdGVVcGRhdGVEaXNwYXRjaERhdGEpIHtcbiAgICB0aGlzLnBhY2tldHMuc3RhdGUgPSBwYWNrZXQ7XG5cbiAgICBpZiAocGFja2V0LnNlbGZfZGVhZiAhPT0gdW5kZWZpbmVkKVxuICAgIHRoaXMuam9pbkNvbmZpZy5zZWxmRGVhZiA9IHBhY2tldC5zZWxmX2RlYWY7XG4gICAgaWYgKHBhY2tldC5zZWxmX211dGUgIT09IHVuZGVmaW5lZClcbiAgICB0aGlzLmpvaW5Db25maWcuc2VsZk11dGUgPSBwYWNrZXQuc2VsZl9tdXRlO1xuICAgIGlmIChwYWNrZXQuY2hhbm5lbF9pZCkgdGhpcy5qb2luQ29uZmlnLmNoYW5uZWxJZCA9IHBhY2tldC5jaGFubmVsX2lkO1xuICAgIC8qXG4gICAgdGhlIGNoYW5uZWxfaWQgYmVpbmcgbnVsbCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1lYW4gaXQgd2FzIGludGVuZGVkIGZvciB0aGUgY2xpZW50IHRvIGxlYXZlIHRoZSB2b2ljZSBjaGFubmVsXG4gICAgYXMgaXQgbWF5IGhhdmUgZGlzY29ubmVjdGVkIGR1ZSB0byBuZXR3b3JrIGZhaWx1cmUuIFRoaXMgd2lsbCBiZSBncmFjZWZ1bGx5IGhhbmRsZWQgb25jZSB0aGUgdm9pY2Ugd2Vic29ja2V0XG4gICAgZGllcywgYW5kIHRoZW4gaXQgaXMgdXAgdG8gdGhlIHVzZXIgdG8gZGVjaWRlIGhvdyB0aGV5IHdpc2ggdG8gaGFuZGxlIHRoaXMuXG4gICAgKi9cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBjb25maWd1cmUgYSBuZXR3b3JraW5nIGluc3RhbmNlIGZvciB0aGlzIHZvaWNlIGNvbm5lY3Rpb24gdXNpbmcgdGhlIHJlY2VpdmVkIHBhY2tldHMuXG4gICAqIEJvdGggcGFja2V0cyBhcmUgcmVxdWlyZWQsIGFuZCBhbnkgZXhpc3RpbmcgbmV0d29ya2luZyBpbnN0YW5jZSB3aWxsIGJlIGRlc3Ryb3llZC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgdm9pY2Ugc2VydmVyIG9mIHRoZSBjb25uZWN0aW9uIGNoYW5nZXMsIGUuZy4gaWYgdGhlIGJvdCBpcyBtb3ZlZCBpbnRvIGFcbiAgICogZGlmZmVyZW50IGNoYW5uZWwgaW4gdGhlIHNhbWUgZ3VpbGQgYnV0IGhhcyBhIGRpZmZlcmVudCB2b2ljZSBzZXJ2ZXIuIEluIHRoaXMgaW5zdGFuY2UsIHRoZSBjb25uZWN0aW9uXG4gICAqIG5lZWRzIHRvIGJlIHJlLWVzdGFibGlzaGVkIHRvIHRoZSBuZXcgdm9pY2Ugc2VydmVyLlxuICAgKlxuICAgKiBUaGUgY29ubmVjdGlvbiB3aWxsIHRyYW5zaXRpb24gdG8gdGhlIENvbm5lY3Rpbmcgc3RhdGUgd2hlbiB0aGlzIGlzIGNhbGxlZC5cbiAgICovXG4gIHB1YmxpYyBjb25maWd1cmVOZXR3b3JraW5nKCkge1xuICAgIGNvbnN0IHsgc2VydmVyLCBzdGF0ZSB9ID0gdGhpcy5wYWNrZXRzO1xuICAgIGlmIChcbiAgICAhc2VydmVyIHx8XG4gICAgIXN0YXRlIHx8XG4gICAgdGhpcy5zdGF0ZS5zdGF0dXMgPT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQgfHxcbiAgICAhc2VydmVyLmVuZHBvaW50KVxuXG4gICAgcmV0dXJuO1xuXG4gICAgY29uc3QgbmV0d29ya2luZyA9IG5ldyBOZXR3b3JraW5nKFxuICAgICAge1xuICAgICAgICBlbmRwb2ludDogc2VydmVyLmVuZHBvaW50LFxuICAgICAgICBzZXJ2ZXJJZDogc2VydmVyLmd1aWxkX2lkLFxuICAgICAgICB0b2tlbjogc2VydmVyLnRva2VuLFxuICAgICAgICBzZXNzaW9uSWQ6IHN0YXRlLnNlc3Npb25faWQsXG4gICAgICAgIHVzZXJJZDogc3RhdGUudXNlcl9pZFxuICAgICAgfSxcbiAgICAgIEJvb2xlYW4odGhpcy5kZWJ1ZylcbiAgICApO1xuXG4gICAgbmV0d29ya2luZy5vbmNlKCdjbG9zZScsIHRoaXMub25OZXR3b3JraW5nQ2xvc2UpO1xuICAgIG5ldHdvcmtpbmcub24oJ3N0YXRlQ2hhbmdlJywgdGhpcy5vbk5ldHdvcmtpbmdTdGF0ZUNoYW5nZSk7XG4gICAgbmV0d29ya2luZy5vbignZXJyb3InLCB0aGlzLm9uTmV0d29ya2luZ0Vycm9yKTtcbiAgICBuZXR3b3JraW5nLm9uKCdkZWJ1ZycsIHRoaXMub25OZXR3b3JraW5nRGVidWcpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICBzdGF0dXM6IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5Db25uZWN0aW5nLFxuICAgICAgbmV0d29ya2luZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIG5ldHdvcmtpbmcgaW5zdGFuY2UgZm9yIHRoaXMgY29ubmVjdGlvbiBjbG9zZXMuIElmIHRoZSBjbG9zZSBjb2RlIGlzIDQwMTQgKGRvIG5vdCByZWNvbm5lY3QpLFxuICAgKiB0aGUgdm9pY2UgY29ubmVjdGlvbiB3aWxsIHRyYW5zaXRpb24gdG8gdGhlIERpc2Nvbm5lY3RlZCBzdGF0ZSB3aGljaCB3aWxsIHN0b3JlIHRoZSBjbG9zZSBjb2RlLiBZb3UgY2FuXG4gICAqIGRlY2lkZSB3aGV0aGVyIG9yIG5vdCB0byByZWNvbm5lY3Qgd2hlbiB0aGlzIG9jY3VycyBieSBsaXN0ZW5pbmcgZm9yIHRoZSBzdGF0ZSBjaGFuZ2UgYW5kIGNhbGxpbmcgcmVjb25uZWN0KCkuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIElmIHRoZSBjbG9zZSBjb2RlIHdhcyBhbnl0aGluZyBvdGhlciB0aGFuIDQwMTQsIGl0IGlzIGxpa2VseSB0aGF0IHRoZSBjbG9zaW5nIHdhcyBub3QgaW50ZW5kZWQsIGFuZCBzbyB0aGVcbiAgICogVm9pY2VDb25uZWN0aW9uIHdpbGwgc2lnbmFsIHRvIERpc2NvcmQgdGhhdCBpdCB3b3VsZCBsaWtlIHRvIHJlam9pbiB0aGUgY2hhbm5lbC4gVGhpcyBhdXRvbWF0aWNhbGx5IGF0dGVtcHRzXG4gICAqIHRvIHJlLWVzdGFibGlzaCB0aGUgY29ubmVjdGlvbi4gVGhpcyB3b3VsZCBiZSBzZWVuIGFzIGEgdHJhbnNpdGlvbiBmcm9tIHRoZSBSZWFkeSBzdGF0ZSB0byB0aGUgU2lnbmFsbGluZyBzdGF0ZS5cbiAgICogQHBhcmFtIGNvZGUgLSBUaGUgY2xvc2UgY29kZVxuICAgKi9cbiAgcHJpdmF0ZSBvbk5ldHdvcmtpbmdDbG9zZShjb2RlOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQpIHJldHVybjtcbiAgICAvLyBJZiBuZXR3b3JraW5nIGNsb3NlcywgdHJ5IHRvIGNvbm5lY3QgdG8gdGhlIHZvaWNlIGNoYW5uZWwgYWdhaW4uXG4gICAgaWYgKGNvZGUgPT09IDRfMDE0KSB7XG4gICAgICAvLyBEaXNjb25uZWN0ZWQgLSBuZXR3b3JraW5nIGlzIGFscmVhZHkgZGVzdHJveWVkIGhlcmVcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZCxcbiAgICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLldlYlNvY2tldENsb3NlLFxuICAgICAgICBjbG9zZUNvZGU6IGNvZGVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLlNpZ25hbGxpbmdcbiAgICAgIH07XG4gICAgICB0aGlzLnJlam9pbkF0dGVtcHRzKys7XG4gICAgICBpZiAoXG4gICAgICAhdGhpcy5zdGF0ZS5hZGFwdGVyLnNlbmRQYXlsb2FkKFxuICAgICAgICBjcmVhdGVKb2luVm9pY2VDaGFubmVsUGF5bG9hZCh0aGlzLmpvaW5Db25maWcpXG4gICAgICApKVxuICAgICAge1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgICAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGlzY29ubmVjdGVkLFxuICAgICAgICAgIHJlYXNvbjogVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdFJlYXNvbi5BZGFwdGVyVW5hdmFpbGFibGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBuZXR3b3JraW5nIGluc3RhbmNlIGNoYW5nZXMuIFRoaXMgaXMgdXNlZCB0byBkZXJpdmUgdGhlIHN0YXRlIG9mIHRoZSB2b2ljZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gb2xkU3RhdGUgLSBUaGUgcHJldmlvdXMgc3RhdGVcbiAgICogQHBhcmFtIG5ld1N0YXRlIC0gVGhlIG5ldyBzdGF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBvbk5ldHdvcmtpbmdTdGF0ZUNoYW5nZShcbiAgb2xkU3RhdGU6IE5ldHdvcmtpbmdTdGF0ZSxcbiAgbmV3U3RhdGU6IE5ldHdvcmtpbmdTdGF0ZSlcbiAge1xuICAgIGlmIChvbGRTdGF0ZS5jb2RlID09PSBuZXdTdGF0ZS5jb2RlKSByZXR1cm47XG4gICAgaWYgKFxuICAgIHRoaXMuc3RhdGUuc3RhdHVzICE9PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuQ29ubmVjdGluZyAmJlxuICAgIHRoaXMuc3RhdGUuc3RhdHVzICE9PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuUmVhZHkpXG5cbiAgICByZXR1cm47XG5cbiAgICBpZiAobmV3U3RhdGUuY29kZSA9PT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVhZHkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLlJlYWR5XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobmV3U3RhdGUuY29kZSAhPT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuQ2xvc2VkKSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICBzdGF0dXM6IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5Db25uZWN0aW5nXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9wYWdhdGVzIGVycm9ycyBmcm9tIHRoZSB1bmRlcmx5aW5nIG5ldHdvcmsgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBwcm9wYWdhdGVcbiAgICovXG4gIHByaXZhdGUgb25OZXR3b3JraW5nRXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9wYWdhdGVzIGRlYnVnIG1lc3NhZ2VzIGZyb20gdGhlIHVuZGVybHlpbmcgbmV0d29yayBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZGVidWcgbWVzc2FnZSB0byBwcm9wYWdhdGVcbiAgICovXG4gIHByaXZhdGUgb25OZXR3b3JraW5nRGVidWcobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgdGhpcy5kZWJ1Zz8uKGBbTlddICR7bWVzc2FnZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyBhbiBhdWRpbyBwYWNrZXQgZm9yIGRpc3BhdGNoLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gVGhlIE9wdXMgcGFja2V0IHRvIHByZXBhcmVcbiAgICovXG4gIHB1YmxpYyBwcmVwYXJlQXVkaW9QYWNrZXQoYnVmZmVyOiBCdWZmZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLnN0YXR1cyAhPT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLlJlYWR5KSByZXR1cm47XG4gICAgcmV0dXJuIHN0YXRlLm5ldHdvcmtpbmcucHJlcGFyZUF1ZGlvUGFja2V0KGJ1ZmZlcik7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB0aGUgcHJldmlvdXNseSBwcmVwYXJlZCBhdWRpbyBwYWNrZXQgKGlmIGFueSlcbiAgICovXG4gIHB1YmxpYyBkaXNwYXRjaEF1ZGlvKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuUmVhZHkpIHJldHVybjtcbiAgICByZXR1cm4gc3RhdGUubmV0d29ya2luZy5kaXNwYXRjaEF1ZGlvKCk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZXMgYW4gYXVkaW8gcGFja2V0IGFuZCBkaXNwYXRjaGVzIGl0IGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gVGhlIE9wdXMgcGFja2V0IHRvIHBsYXlcbiAgICovXG4gIHB1YmxpYyBwbGF5T3B1c1BhY2tldChidWZmZXI6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuUmVhZHkpIHJldHVybjtcbiAgICBzdGF0ZS5uZXR3b3JraW5nLnByZXBhcmVBdWRpb1BhY2tldChidWZmZXIpO1xuICAgIHJldHVybiBzdGF0ZS5uZXR3b3JraW5nLmRpc3BhdGNoQXVkaW8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgVm9pY2VDb25uZWN0aW9uLCBwcmV2ZW50aW5nIGl0IGZyb20gY29ubmVjdGluZyB0byB2b2ljZSBhZ2Fpbi5cbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHlvdSBubyBsb25nZXIgcmVxdWlyZSB0aGUgVm9pY2VDb25uZWN0aW9uIHRvXG4gICAqIHByZXZlbnQgbWVtb3J5IGxlYWtzLlxuICAgKlxuICAgKiBAcGFyYW0gYWRhcHRlckF2YWlsYWJsZSAtIFdoZXRoZXIgdGhlIGFkYXB0ZXIgY2FuIGJlIHVzZWRcbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KGFkYXB0ZXJBdmFpbGFibGUgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgZGVzdHJveSBWb2ljZUNvbm5lY3Rpb24gLSBpdCBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgIGdldFZvaWNlQ29ubmVjdGlvbih0aGlzLmpvaW5Db25maWcuZ3VpbGRJZCwgdGhpcy5qb2luQ29uZmlnLmdyb3VwKSA9PT1cbiAgICB0aGlzKVxuICAgIHtcbiAgICAgIHVudHJhY2tWb2ljZUNvbm5lY3Rpb24odGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGFkYXB0ZXJBdmFpbGFibGUpIHtcbiAgICAgIHRoaXMuc3RhdGUuYWRhcHRlci5zZW5kUGF5bG9hZChcbiAgICAgICAgY3JlYXRlSm9pblZvaWNlQ2hhbm5lbFBheWxvYWQoeyAuLi50aGlzLmpvaW5Db25maWcsIGNoYW5uZWxJZDogbnVsbCB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGVzdHJveWVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgVm9pY2VDb25uZWN0aW9uLCBhbGxvd2luZyB0aGUgcG9zc2liaWxpdHkgb2YgcmVqb2luaW5nIGxhdGVyIG9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbm5lY3Rpb24gd2FzIHN1Y2Nlc3NmdWxseSBkaXNjb25uZWN0ZWRcbiAgICovXG4gIHB1YmxpYyBkaXNjb25uZWN0KCkge1xuICAgIGlmIChcbiAgICB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRlc3Ryb3llZCB8fFxuICAgIHRoaXMuc3RhdGUuc3RhdHVzID09PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuU2lnbmFsbGluZylcbiAgICB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5qb2luQ29uZmlnLmNoYW5uZWxJZCA9IG51bGw7XG4gICAgaWYgKFxuICAgICF0aGlzLnN0YXRlLmFkYXB0ZXIuc2VuZFBheWxvYWQoXG4gICAgICBjcmVhdGVKb2luVm9pY2VDaGFubmVsUGF5bG9hZCh0aGlzLmpvaW5Db25maWcpXG4gICAgKSlcbiAgICB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBhZGFwdGVyOiB0aGlzLnN0YXRlLmFkYXB0ZXIsXG4gICAgICAgIHN1YnNjcmlwdGlvbjogdGhpcy5zdGF0ZS5zdWJzY3JpcHRpb24sXG4gICAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZCxcbiAgICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLkFkYXB0ZXJVbmF2YWlsYWJsZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYWRhcHRlcjogdGhpcy5zdGF0ZS5hZGFwdGVyLFxuICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLk1hbnVhbCxcbiAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZFxuICAgIH07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcmVqb2luIChiZXR0ZXIgZXhwbGFuYXRpb24gc29vbjp0bTopXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIENhbGxpbmcgdGhpcyBtZXRob2Qgc3VjY2Vzc2Z1bGx5IHdpbGwgYXV0b21hdGljYWxseSBpbmNyZW1lbnQgdGhlIGByZWpvaW5BdHRlbXB0c2AgY291bnRlcixcbiAgICogd2hpY2ggeW91IGNhbiB1c2UgdG8gaW5mb3JtIHdoZXRoZXIgb3Igbm90IHlvdSdkIGxpa2UgdG8ga2VlcCBhdHRlbXB0aW5nIHRvIHJlY29ubmVjdCB5b3VyXG4gICAqIHZvaWNlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEEgc3RhdGUgdHJhbnNpdGlvbiBmcm9tIERpc2Nvbm5lY3RlZCB0byBTaWduYWxsaW5nIHdpbGwgYmUgb2JzZXJ2ZWQgd2hlbiB0aGlzIGlzIGNhbGxlZC5cbiAgICovXG4gIHB1YmxpYyByZWpvaW4oam9pbkNvbmZpZz86IE9taXQ8Sm9pbkNvbmZpZywgJ2dyb3VwJyB8ICdndWlsZElkJz4pIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBub3RSZWFkeSA9IHRoaXMuc3RhdGUuc3RhdHVzICE9PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuUmVhZHk7XG5cbiAgICBpZiAobm90UmVhZHkpIHRoaXMucmVqb2luQXR0ZW1wdHMrKztcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuam9pbkNvbmZpZywgam9pbkNvbmZpZyk7XG4gICAgaWYgKFxuICAgIHRoaXMuc3RhdGUuYWRhcHRlci5zZW5kUGF5bG9hZChcbiAgICAgIGNyZWF0ZUpvaW5Wb2ljZUNoYW5uZWxQYXlsb2FkKHRoaXMuam9pbkNvbmZpZylcbiAgICApKVxuICAgIHtcbiAgICAgIGlmIChub3RSZWFkeSkge1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgICAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuU2lnbmFsbGluZ1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYWRhcHRlcjogdGhpcy5zdGF0ZS5hZGFwdGVyLFxuICAgICAgc3Vic2NyaXB0aW9uOiB0aGlzLnN0YXRlLnN1YnNjcmlwdGlvbixcbiAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZCxcbiAgICAgIHJlYXNvbjogVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdFJlYXNvbi5BZGFwdGVyVW5hdmFpbGFibGVcbiAgICB9O1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzcGVha2luZyBzdGF0dXMgb2YgdGhlIHZvaWNlIGNvbm5lY3Rpb24uIFRoaXMgaXMgdXNlZCB3aGVuIGF1ZGlvIHBsYXllcnMgYXJlIGRvbmUgcGxheWluZyBhdWRpbyxcbiAgICogYW5kIG5lZWQgdG8gc2lnbmFsIHRoYXQgdGhlIGNvbm5lY3Rpb24gaXMgbm8gbG9uZ2VyIHBsYXlpbmcgYXVkaW8uXG4gICAqXG4gICAqIEBwYXJhbSBlbmFibGVkIC0gV2hldGhlciBvciBub3QgdG8gc2hvdyBhcyBzcGVha2luZ1xuICAgKi9cbiAgcHVibGljIHNldFNwZWFraW5nKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgIT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5SZWFkeSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tY29uZnVzaW5nLXZvaWQtZXhwcmVzc2lvblxuICAgIHJldHVybiB0aGlzLnN0YXRlLm5ldHdvcmtpbmcuc2V0U3BlYWtpbmcoZW5hYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyB0byBhbiBhdWRpbyBwbGF5ZXIsIGFsbG93aW5nIHRoZSBwbGF5ZXIgdG8gcGxheSBhdWRpbyBvbiB0aGlzIHZvaWNlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBwbGF5ZXIgLSBUaGUgYXVkaW8gcGxheWVyIHRvIHN1YnNjcmliZSB0b1xuICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBzdWJzY3JpcHRpb25cbiAgICovXG4gIHB1YmxpYyBzdWJzY3JpYmUocGxheWVyOiBBdWRpb1BsYXllcikge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyA9PT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9kb3Qtbm90YXRpb25cbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBwbGF5ZXJbJ3N1YnNjcmliZSddKHRoaXMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9O1xuXG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGF0ZXN0IHBpbmcgKGluIG1pbGxpc2Vjb25kcykgZm9yIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBhbmQgYXVkaW8gcGxheWJhY2sgZm9yIHRoaXMgdm9pY2VcbiAgICogY29ubmVjdGlvbiwgaWYgdGhpcyBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogRm9yIHRoaXMgZGF0YSB0byBiZSBhdmFpbGFibGUsIHRoZSBWb2ljZUNvbm5lY3Rpb24gbXVzdCBiZSBpbiB0aGUgUmVhZHkgc3RhdGUsIGFuZCBpdHMgdW5kZXJseWluZ1xuICAgKiBXZWJTb2NrZXQgY29ubmVjdGlvbiBhbmQgVURQIHNvY2tldCBtdXN0IGhhdmUgaGFkIGF0IGxlYXN0IG9uZSBwaW5nLXBvbmcgZXhjaGFuZ2UuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBpbmcoKSB7XG4gICAgaWYgKFxuICAgIHRoaXMuc3RhdGUuc3RhdHVzID09PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuUmVhZHkgJiZcbiAgICB0aGlzLnN0YXRlLm5ldHdvcmtpbmcuc3RhdGUuY29kZSA9PT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVhZHkpXG4gICAge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3M6IHRoaXMuc3RhdGUubmV0d29ya2luZy5zdGF0ZS53cy5waW5nLFxuICAgICAgICB1ZHA6IHRoaXMuc3RhdGUubmV0d29ya2luZy5zdGF0ZS51ZHAucGluZ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd3M6IHVuZGVmaW5lZCxcbiAgICAgIHVkcDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHN1YnNjcmlwdGlvbiBvZiB0aGlzIHZvaWNlIGNvbm5lY3Rpb24gdG8gYW4gYXVkaW8gcGxheWVyIGlzIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzdWJzY3JpcHRpb24gLSBUaGUgcmVtb3ZlZCBzdWJzY3JpcHRpb25cbiAgICovXG4gIHByb3RlY3RlZCBvblN1YnNjcmlwdGlvblJlbW92ZWQoc3Vic2NyaXB0aW9uOiBQbGF5ZXJTdWJzY3JpcHRpb24pIHtcbiAgICBpZiAoXG4gICAgdGhpcy5zdGF0ZS5zdGF0dXMgIT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQgJiZcbiAgICB0aGlzLnN0YXRlLnN1YnNjcmlwdGlvbiA9PT0gc3Vic2NyaXB0aW9uKVxuICAgIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgIHN1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdm9pY2UgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gam9pbkNvbmZpZyAtIFRoZSBkYXRhIHJlcXVpcmVkIHRvIGVzdGFibGlzaCB0aGUgdm9pY2UgY29ubmVjdGlvblxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBqb2luaW5nIHRoZSB2b2ljZSBjaGFubmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWb2ljZUNvbm5lY3Rpb24oXG5qb2luQ29uZmlnOiBKb2luQ29uZmlnLFxub3B0aW9uczogQ3JlYXRlVm9pY2VDb25uZWN0aW9uT3B0aW9ucylcbntcbiAgY29uc3QgcGF5bG9hZCA9IGNyZWF0ZUpvaW5Wb2ljZUNoYW5uZWxQYXlsb2FkKGpvaW5Db25maWcpO1xuICBjb25zdCBleGlzdGluZyA9IGdldFZvaWNlQ29ubmVjdGlvbihqb2luQ29uZmlnLmd1aWxkSWQsIGpvaW5Db25maWcuZ3JvdXApO1xuICBpZiAoZXhpc3RpbmcgJiYgZXhpc3Rpbmcuc3RhdGUuc3RhdHVzICE9PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGVzdHJveWVkKSB7XG4gICAgaWYgKGV4aXN0aW5nLnN0YXRlLnN0YXR1cyA9PT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgZXhpc3RpbmcucmVqb2luKHtcbiAgICAgICAgY2hhbm5lbElkOiBqb2luQ29uZmlnLmNoYW5uZWxJZCxcbiAgICAgICAgc2VsZkRlYWY6IGpvaW5Db25maWcuc2VsZkRlYWYsXG4gICAgICAgIHNlbGZNdXRlOiBqb2luQ29uZmlnLnNlbGZNdXRlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFleGlzdGluZy5zdGF0ZS5hZGFwdGVyLnNlbmRQYXlsb2FkKHBheWxvYWQpKSB7XG4gICAgICBleGlzdGluZy5zdGF0ZSA9IHtcbiAgICAgICAgLi4uZXhpc3Rpbmcuc3RhdGUsXG4gICAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZCxcbiAgICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLkFkYXB0ZXJVbmF2YWlsYWJsZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH1cblxuICBjb25zdCB2b2ljZUNvbm5lY3Rpb24gPSBuZXcgVm9pY2VDb25uZWN0aW9uKGpvaW5Db25maWcsIG9wdGlvbnMpO1xuICB0cmFja1ZvaWNlQ29ubmVjdGlvbih2b2ljZUNvbm5lY3Rpb24pO1xuICBpZiAoXG4gIHZvaWNlQ29ubmVjdGlvbi5zdGF0ZS5zdGF0dXMgIT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQgJiZcbiAgIXZvaWNlQ29ubmVjdGlvbi5zdGF0ZS5hZGFwdGVyLnNlbmRQYXlsb2FkKHBheWxvYWQpKVxuICB7XG4gICAgdm9pY2VDb25uZWN0aW9uLnN0YXRlID0ge1xuICAgICAgLi4udm9pY2VDb25uZWN0aW9uLnN0YXRlLFxuICAgICAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGlzY29ubmVjdGVkLFxuICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLkFkYXB0ZXJVbmF2YWlsYWJsZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdm9pY2VDb25uZWN0aW9uO1xufSIsICIvLyBDb3B5cmlnaHQgZGlzY29yZC1wbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIExpY2Vuc2UuXG4vLyBDb3B5cmlnaHQgZGlzY29yZC5qcyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBBcGFjaGUgTGljZW5zZSAyLjBcblxuaW1wb3J0IHsgR2F0ZXdheU9wY29kZXMgfSBmcm9tICdkaXNjb3JkLWFwaS10eXBlcy92MTAnO1xuaW1wb3J0IHR5cGUgeyBWb2ljZUNvbm5lY3Rpb24gfSBmcm9tICcuL1ZvaWNlQ29ubmVjdGlvbic7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvUGxheWVyIH0gZnJvbSAnLi9hdWRpby9pbmRleCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSm9pbkNvbmZpZyB7XG4gIGNoYW5uZWxJZDogc3RyaW5nIHwgbnVsbDtcbiAgZ3JvdXA6IHN0cmluZztcbiAgZ3VpbGRJZDogc3RyaW5nO1xuICBzZWxmRGVhZjogYm9vbGVhbjtcbiAgc2VsZk11dGU6IGJvb2xlYW47XG59XG5cbi8qKlxuICogU2VuZHMgYSB2b2ljZSBzdGF0ZSB1cGRhdGUgdG8gdGhlIG1haW4gd2Vic29ja2V0IHNoYXJkIG9mIGEgZ3VpbGQsIHRvIGluZGljYXRlIGpvaW5pbmcvbGVhdmluZy9tb3ZpbmcgYWNyb3NzXG4gKiB2b2ljZSBjaGFubmVscy5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gdG8gdXNlIHdoZW4gam9pbmluZyB0aGUgdm9pY2UgY2hhbm5lbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSm9pblZvaWNlQ2hhbm5lbFBheWxvYWQoY29uZmlnOiBKb2luQ29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgb3A6IEdhdGV3YXlPcGNvZGVzLlZvaWNlU3RhdGVVcGRhdGUsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGlkLWxlbmd0aFxuICAgIGQ6IHtcbiAgICAgIGd1aWxkX2lkOiBjb25maWcuZ3VpbGRJZCxcbiAgICAgIGNoYW5uZWxfaWQ6IGNvbmZpZy5jaGFubmVsSWQsXG4gICAgICBzZWxmX2RlYWY6IGNvbmZpZy5zZWxmRGVhZixcbiAgICAgIHNlbGZfbXV0ZTogY29uZmlnLnNlbGZNdXRlXG4gICAgfVxuICB9O1xufVxuXG4vLyBWb2ljZSBDb25uZWN0aW9uc1xuY29uc3QgZ3JvdXBzID0gbmV3IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIFZvaWNlQ29ubmVjdGlvbj4+KCk7XG5ncm91cHMuc2V0KCdkZWZhdWx0JywgbmV3IE1hcCgpKTtcblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVHcm91cChncm91cDogc3RyaW5nKSB7XG4gIGNvbnN0IGV4aXN0aW5nID0gZ3JvdXBzLmdldChncm91cCk7XG4gIGlmIChleGlzdGluZykgcmV0dXJuIGV4aXN0aW5nO1xuICBjb25zdCBtYXAgPSBuZXcgTWFwPHN0cmluZywgVm9pY2VDb25uZWN0aW9uPigpO1xuICBncm91cHMuc2V0KGdyb3VwLCBtYXApO1xuICByZXR1cm4gbWFwO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbWFwIG9mIGdyb3VwIG5hbWVzIHRvIG1hcHMgb2Ygdm9pY2UgY29ubmVjdGlvbnMuIEJ5IGRlZmF1bHQsIGFsbCB2b2ljZSBjb25uZWN0aW9uc1xuICogYXJlIGNyZWF0ZWQgdW5kZXIgdGhlICdkZWZhdWx0JyBncm91cC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZ3JvdXAgbWFwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcm91cHMoKSB7XG4gIHJldHVybiBncm91cHM7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIGFsbCB0aGUgdm9pY2UgY29ubmVjdGlvbnMgdW5kZXIgdGhlICdkZWZhdWx0JyBncm91cC5cbiAqXG4gKiBAcGFyYW0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gbG9vayB1cFxuICogQHJldHVybnMgVGhlIG1hcCBvZiB2b2ljZSBjb25uZWN0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Vm9pY2VDb25uZWN0aW9ucyhcbmdyb3VwPzogJ2RlZmF1bHQnKVxuOiBNYXA8c3RyaW5nLCBWb2ljZUNvbm5lY3Rpb24+O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbGwgdGhlIHZvaWNlIGNvbm5lY3Rpb25zIHVuZGVyIHRoZSBnaXZlbiBncm91cCBuYW1lLlxuICpcbiAqIEBwYXJhbSBncm91cCAtIFRoZSBncm91cCB0byBsb29rIHVwXG4gKiBAcmV0dXJucyBUaGUgbWFwIG9mIHZvaWNlIGNvbm5lY3Rpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWb2ljZUNvbm5lY3Rpb25zKFxuZ3JvdXA6IHN0cmluZylcbjogTWFwPHN0cmluZywgVm9pY2VDb25uZWN0aW9uPiB8IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYWxsIHRoZSB2b2ljZSBjb25uZWN0aW9ucyB1bmRlciB0aGUgZ2l2ZW4gZ3JvdXAgbmFtZS4gRGVmYXVsdHMgdG8gdGhlICdkZWZhdWx0JyBncm91cC5cbiAqXG4gKiBAcGFyYW0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gbG9vayB1cFxuICogQHJldHVybnMgVGhlIG1hcCBvZiB2b2ljZSBjb25uZWN0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Vm9pY2VDb25uZWN0aW9ucyhncm91cCA9ICdkZWZhdWx0Jykge1xuICByZXR1cm4gZ3JvdXBzLmdldChncm91cCk7XG59XG5cbi8qKlxuICogRmluZHMgYSB2b2ljZSBjb25uZWN0aW9uIHdpdGggdGhlIGdpdmVuIGd1aWxkIGlkIGFuZCBncm91cC4gRGVmYXVsdHMgdG8gdGhlICdkZWZhdWx0JyBncm91cC5cbiAqXG4gKiBAcGFyYW0gZ3VpbGRJZCAtIFRoZSBndWlsZCBpZCBvZiB0aGUgdm9pY2UgY29ubmVjdGlvblxuICogQHBhcmFtIGdyb3VwIC0gdGhlIGdyb3VwIHRoYXQgdGhlIHZvaWNlIGNvbm5lY3Rpb24gd2FzIHJlZ2lzdGVyZWQgd2l0aFxuICogQHJldHVybnMgVGhlIHZvaWNlIGNvbm5lY3Rpb24sIGlmIGl0IGV4aXN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Vm9pY2VDb25uZWN0aW9uKGd1aWxkSWQ6IHN0cmluZywgZ3JvdXAgPSAnZGVmYXVsdCcpIHtcbiAgcmV0dXJuIGdldFZvaWNlQ29ubmVjdGlvbnMoZ3JvdXApPy5nZXQoZ3VpbGRJZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnRyYWNrVm9pY2VDb25uZWN0aW9uKHZvaWNlQ29ubmVjdGlvbjogVm9pY2VDb25uZWN0aW9uKSB7XG4gIHJldHVybiBnZXRWb2ljZUNvbm5lY3Rpb25zKHZvaWNlQ29ubmVjdGlvbi5qb2luQ29uZmlnLmdyb3VwKT8uZGVsZXRlKFxuICAgIHZvaWNlQ29ubmVjdGlvbi5qb2luQ29uZmlnLmd1aWxkSWRcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrVm9pY2VDb25uZWN0aW9uKHZvaWNlQ29ubmVjdGlvbjogVm9pY2VDb25uZWN0aW9uKSB7XG4gIHJldHVybiBnZXRPckNyZWF0ZUdyb3VwKHZvaWNlQ29ubmVjdGlvbi5qb2luQ29uZmlnLmdyb3VwKS5zZXQoXG4gICAgdm9pY2VDb25uZWN0aW9uLmpvaW5Db25maWcuZ3VpbGRJZCxcbiAgICB2b2ljZUNvbm5lY3Rpb25cbiAgKTtcbn1cblxuLy8gQXVkaW8gUGxheWVyc1xuXG4vLyBFYWNoIGF1ZGlvIHBhY2tldCBpcyAyMG1zIGxvbmdcbmNvbnN0IEZSQU1FX0xFTkdUSCA9IDIwO1xuXG5sZXQgYXVkaW9DeWNsZUludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZDtcbmxldCBuZXh0VGltZSA9IC0xO1xuXG4vKipcbiAqIEEgbGlzdCBvZiBjcmVhdGVkIGF1ZGlvIHBsYXllcnMgdGhhdCBhcmUgc3RpbGwgYWN0aXZlIGFuZCBoYXZlbid0IGJlZW4gZGVzdHJveWVkLlxuICovXG5jb25zdCBhdWRpb1BsYXllcnM6IEF1ZGlvUGxheWVyW10gPSBbXTtcblxuLyoqXG4gKiBDYWxsZWQgcm91Z2hseSBldmVyeSAyMCBtaWxsaXNlY29uZHMuIERpc3BhdGNoZXMgYXVkaW8gZnJvbSBhbGwgcGxheWVycywgYW5kIHRoZW4gZ2V0cyB0aGUgcGxheWVycyB0byBwcmVwYXJlXG4gKiB0aGUgbmV4dCBhdWRpbyBmcmFtZS5cbiAqL1xuZnVuY3Rpb24gYXVkaW9DeWNsZVN0ZXAoKSB7XG4gIGlmIChuZXh0VGltZSA9PT0gLTEpIHJldHVybjtcblxuICBuZXh0VGltZSArPSBGUkFNRV9MRU5HVEg7XG4gIGNvbnN0IGF2YWlsYWJsZSA9IGF1ZGlvUGxheWVycy5maWx0ZXIoKHBsYXllcikgPT4gcGxheWVyLmNoZWNrUGxheWFibGUoKSk7XG5cbiAgZm9yIChjb25zdCBwbGF5ZXIgb2YgYXZhaWxhYmxlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9kb3Qtbm90YXRpb25cbiAgICBwbGF5ZXJbJ19zdGVwRGlzcGF0Y2gnXSgpO1xuICB9XG5cbiAgcHJlcGFyZU5leHRBdWRpb0ZyYW1lKGF2YWlsYWJsZSk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZ2V0cyB0aGUgcGxheWVycyB0aGF0IGhhdmUgYmVlbiBwYXNzZWQgYXMgcGFyYW1ldGVycyB0byBwcmVwYXJlIGF1ZGlvIGZyYW1lcyB0aGF0IGNhbiBiZSBwbGF5ZWRcbiAqIGF0IHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjeWNsZS5cbiAqL1xuZnVuY3Rpb24gcHJlcGFyZU5leHRBdWRpb0ZyYW1lKHBsYXllcnM6IEF1ZGlvUGxheWVyW10pIHtcbiAgY29uc3QgbmV4dFBsYXllciA9IHBsYXllcnMuc2hpZnQoKTtcblxuICBpZiAoIW5leHRQbGF5ZXIpIHtcbiAgICBpZiAobmV4dFRpbWUgIT09IC0xKSB7XG4gICAgICBhdWRpb0N5Y2xlSW50ZXJ2YWwgPSBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PiBhdWRpb0N5Y2xlU3RlcCgpLFxuICAgICAgICBuZXh0VGltZSAtIERhdGUubm93KClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9kb3Qtbm90YXRpb25cbiAgbmV4dFBsYXllclsnX3N0ZXBQcmVwYXJlJ10oKTtcblxuICAvLyBzZXRJbW1lZGlhdGUgdG8gYXZvaWQgbG9uZyBhdWRpbyBwbGF5ZXIgY2hhaW5zIGJsb2NraW5nIG90aGVyIHNjaGVkdWxlZCB0YXNrc1xuICBzZXRJbW1lZGlhdGUoKCkgPT4gcHJlcGFyZU5leHRBdWRpb0ZyYW1lKHBsYXllcnMpKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIGF1ZGlvIHBsYXllciBpcyBiZWluZyBkcml2ZW4gYnkgdGhlIGRhdGEgc3RvcmUgY2xvY2suXG4gKlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgdG8gdGVzdCBmb3JcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBpdCBpcyBiZWluZyB0cmFja2VkLCBgZmFsc2VgIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQXVkaW9QbGF5ZXIodGFyZ2V0OiBBdWRpb1BsYXllcikge1xuICByZXR1cm4gYXVkaW9QbGF5ZXJzLmluY2x1ZGVzKHRhcmdldCk7XG59XG5cbi8qKlxuICogQWRkcyBhbiBhdWRpbyBwbGF5ZXIgdG8gdGhlIGRhdGEgc3RvcmUgdHJhY2tpbmcgbGlzdCwgaWYgaXQgaXNuJ3QgYWxyZWFkeSB0aGVyZS5cbiAqXG4gKiBAcGFyYW0gcGxheWVyIC0gVGhlIHBsYXllciB0byB0cmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQXVkaW9QbGF5ZXIocGxheWVyOiBBdWRpb1BsYXllcikge1xuICBpZiAoaGFzQXVkaW9QbGF5ZXIocGxheWVyKSkgcmV0dXJuIHBsYXllcjtcbiAgYXVkaW9QbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgaWYgKGF1ZGlvUGxheWVycy5sZW5ndGggPT09IDEpIHtcbiAgICBuZXh0VGltZSA9IERhdGUubm93KCk7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IGF1ZGlvQ3ljbGVTdGVwKCkpO1xuICB9XG5cbiAgcmV0dXJuIHBsYXllcjtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFuIGF1ZGlvIHBsYXllciBmcm9tIHRoZSBkYXRhIHN0b3JlIHRyYWNraW5nIGxpc3QsIGlmIGl0IGlzIHByZXNlbnQgdGhlcmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVBdWRpb1BsYXllcihwbGF5ZXI6IEF1ZGlvUGxheWVyKSB7XG4gIGNvbnN0IGluZGV4ID0gYXVkaW9QbGF5ZXJzLmluZGV4T2YocGxheWVyKTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuICBhdWRpb1BsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKGF1ZGlvUGxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICBuZXh0VGltZSA9IC0xO1xuICAgIGlmIChhdWRpb0N5Y2xlSW50ZXJ2YWwgIT09IHVuZGVmaW5lZCkgY2xlYXJUaW1lb3V0KGF1ZGlvQ3ljbGVJbnRlcnZhbCk7XG4gIH1cbn0iLCAiLy8gQ29weXJpZ2h0IGRpc2NvcmQtcGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBMaWNlbnNlLlxuLy8gQ29weXJpZ2h0IGRpc2NvcmQuanMgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gQXBhY2hlIExpY2Vuc2UgMi4wXG5cbi8qIGVzbGludC1kaXNhYmxlIGlkLWxlbmd0aCAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmcgKi9cbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ25vZGU6YnVmZmVyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ25vZGU6ZXZlbnRzJztcbmltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuaW1wb3J0IHsgVm9pY2VPcGNvZGVzIH0gZnJvbSAnZGlzY29yZC1hcGktdHlwZXMvdm9pY2UvdjQnO1xuaW1wb3J0ICogYXMgc2VjcmV0Ym94IGZyb20gJy4uL3V0aWwvU2VjcmV0Ym94JztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgVm9pY2VVRFBTb2NrZXQgfSBmcm9tICcuL1ZvaWNlVURQU29ja2V0JztcbmltcG9ydCB7IFZvaWNlV2ViU29ja2V0IH0gZnJvbSAnLi9Wb2ljZVdlYlNvY2tldCc7XG5pbXBvcnQgeyB1bnNhZmUgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnO1xuXG4vLyBUaGUgbnVtYmVyIG9mIGF1ZGlvIGNoYW5uZWxzIHJlcXVpcmVkIGJ5IERpc2NvcmRcbmNvbnN0IENIQU5ORUxTID0gMjtcbmNvbnN0IFRJTUVTVEFNUF9JTkMgPSA0OF8wMDAgLyAxMDAgKiBDSEFOTkVMUztcbmNvbnN0IE1BWF9OT05DRV9TSVpFID0gMiAqKiAzMiAtIDE7XG5cbmV4cG9ydCBjb25zdCBTVVBQT1JURURfRU5DUllQVElPTl9NT0RFUyA9IFsnYWVhZF94Y2hhY2hhMjBfcG9seTEzMDVfcnRwc2l6ZSddO1xuXG4vLyBKdXN0IGluIGNhc2UgdGhlcmUncyBzb21lIHN5c3RlbSB0aGF0IGRvZXNuJ3QgY29tZSB3aXRoIGFlcy0yNTYtZ2NtLCBjb25kaXRpb25hbGx5IGFkZCBpdCBhcyBzdXBwb3J0ZWRcbmlmIChjcnlwdG8uZ2V0Q2lwaGVycygpLmluY2x1ZGVzKCdhZXMtMjU2LWdjbScpKSB7XG4gIFNVUFBPUlRFRF9FTkNSWVBUSU9OX01PREVTLnVuc2hpZnQoJ2FlYWRfYWVzMjU2X2djbV9ydHBzaXplJyk7XG59XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCBzdGF0dXNlcyB0aGF0IGEgbmV0d29ya2luZyBpbnN0YW5jZSBjYW4gaG9sZC4gVGhlIG9yZGVyXG4gKiBvZiB0aGUgc3RhdGVzIGJldHdlZW4gT3BlbmluZ1dzIGFuZCBSZWFkeSBpcyBjaHJvbm9sb2dpY2FsIChmaXJzdCB0aGVcbiAqIGluc3RhbmNlIGVudGVycyBPcGVuaW5nV3MsIHRoZW4gaXQgZW50ZXJzIElkZW50aWZ5aW5nIGV0Yy4pXG4gKi9cbmV4cG9ydCBlbnVtIE5ldHdvcmtpbmdTdGF0dXNDb2RlIHtcbiAgT3BlbmluZ1dzLFxuICBJZGVudGlmeWluZyxcbiAgVWRwSGFuZHNoYWtpbmcsXG4gIFNlbGVjdGluZ1Byb3RvY29sLFxuICBSZWFkeSxcbiAgUmVzdW1pbmcsXG4gIENsb3NlZCxcbn1cblxuLyoqXG4gKiBUaGUgaW5pdGlhbCBOZXR3b3JraW5nIHN0YXRlLiBJbnN0YW5jZXMgd2lsbCBiZSBpbiB0aGlzIHN0YXRlIHdoZW4gYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byBhIERpc2NvcmRcbiAqIHZvaWNlIGdhdGV3YXkgaXMgYmVpbmcgb3BlbmVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtpbmdPcGVuaW5nV3NTdGF0ZSB7XG4gIGNvZGU6IE5ldHdvcmtpbmdTdGF0dXNDb2RlLk9wZW5pbmdXcztcbiAgY29ubmVjdGlvbk9wdGlvbnM6IENvbm5lY3Rpb25PcHRpb25zO1xuICB3czogVm9pY2VXZWJTb2NrZXQ7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBOZXR3b3JraW5nIGluc3RhbmNlIHdpbGwgYmUgaW4gd2hlbiBpdCBpcyBhdHRlbXB0aW5nIHRvIGF1dGhvcml6ZSBpdHNlbGYuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya2luZ0lkZW50aWZ5aW5nU3RhdGUge1xuICBjb2RlOiBOZXR3b3JraW5nU3RhdHVzQ29kZS5JZGVudGlmeWluZztcbiAgY29ubmVjdGlvbk9wdGlvbnM6IENvbm5lY3Rpb25PcHRpb25zO1xuICB3czogVm9pY2VXZWJTb2NrZXQ7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBOZXR3b3JraW5nIGluc3RhbmNlIHdpbGwgYmUgaW4gd2hlbiBvcGVuaW5nIGEgVURQIGNvbm5lY3Rpb24gdG8gdGhlIElQIGFuZCBwb3J0IHByb3ZpZGVkXG4gKiBieSBEaXNjb3JkLCBhcyB3ZWxsIGFzIHBlcmZvcm1pbmcgSVAgZGlzY292ZXJ5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtpbmdVZHBIYW5kc2hha2luZ1N0YXRlIHtcbiAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuVWRwSGFuZHNoYWtpbmc7XG4gIGNvbm5lY3Rpb25EYXRhOiBQaWNrPENvbm5lY3Rpb25EYXRhLCAnc3NyYyc+O1xuICBjb25uZWN0aW9uT3B0aW9uczogQ29ubmVjdGlvbk9wdGlvbnM7XG4gIHVkcDogVm9pY2VVRFBTb2NrZXQ7XG4gIHdzOiBWb2ljZVdlYlNvY2tldDtcbn1cblxuLyoqXG4gKiBUaGUgc3RhdGUgdGhhdCBhIE5ldHdvcmtpbmcgaW5zdGFuY2Ugd2lsbCBiZSBpbiB3aGVuIHNlbGVjdGluZyBhbiBlbmNyeXB0aW9uIHByb3RvY29sIGZvciBhdWRpbyBwYWNrZXRzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtpbmdTZWxlY3RpbmdQcm90b2NvbFN0YXRlIHtcbiAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuU2VsZWN0aW5nUHJvdG9jb2w7XG4gIGNvbm5lY3Rpb25EYXRhOiBQaWNrPENvbm5lY3Rpb25EYXRhLCAnc3NyYyc+O1xuICBjb25uZWN0aW9uT3B0aW9uczogQ29ubmVjdGlvbk9wdGlvbnM7XG4gIHVkcDogVm9pY2VVRFBTb2NrZXQ7XG4gIHdzOiBWb2ljZVdlYlNvY2tldDtcbn1cblxuLyoqXG4gKiBUaGUgc3RhdGUgdGhhdCBhIE5ldHdvcmtpbmcgaW5zdGFuY2Ugd2lsbCBiZSBpbiB3aGVuIGl0IGhhcyBhIGZ1bGx5IGVzdGFibGlzaGVkIGNvbm5lY3Rpb24gdG8gYSBEaXNjb3JkXG4gKiB2b2ljZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya2luZ1JlYWR5U3RhdGUge1xuICBjb2RlOiBOZXR3b3JraW5nU3RhdHVzQ29kZS5SZWFkeTtcbiAgY29ubmVjdGlvbkRhdGE6IENvbm5lY3Rpb25EYXRhO1xuICBjb25uZWN0aW9uT3B0aW9uczogQ29ubmVjdGlvbk9wdGlvbnM7XG4gIHByZXBhcmVkUGFja2V0PzogQnVmZmVyIHwgdW5kZWZpbmVkO1xuICB1ZHA6IFZvaWNlVURQU29ja2V0O1xuICB3czogVm9pY2VXZWJTb2NrZXQ7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBOZXR3b3JraW5nIGluc3RhbmNlIHdpbGwgYmUgaW4gd2hlbiBpdHMgY29ubmVjdGlvbiBoYXMgYmVlbiBkcm9wcGVkIHVuZXhwZWN0ZWRseSwgYW5kIGl0XG4gKiBpcyBhdHRlbXB0aW5nIHRvIHJlc3VtZSBhbiBleGlzdGluZyBzZXNzaW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtpbmdSZXN1bWluZ1N0YXRlIHtcbiAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVzdW1pbmc7XG4gIGNvbm5lY3Rpb25EYXRhOiBDb25uZWN0aW9uRGF0YTtcbiAgY29ubmVjdGlvbk9wdGlvbnM6IENvbm5lY3Rpb25PcHRpb25zO1xuICBwcmVwYXJlZFBhY2tldD86IEJ1ZmZlciB8IHVuZGVmaW5lZDtcbiAgdWRwOiBWb2ljZVVEUFNvY2tldDtcbiAgd3M6IFZvaWNlV2ViU29ja2V0O1xufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSB0aGF0IGEgTmV0d29ya2luZyBpbnN0YW5jZSB3aWxsIGJlIGluIHdoZW4gaXQgaGFzIGJlZW4gZGVzdHJveWVkLiBJdCBjYW5ub3QgYmUgcmVjb3ZlcmVkIGZyb20gdGhpc1xuICogc3RhdGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya2luZ0Nsb3NlZFN0YXRlIHtcbiAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuQ2xvc2VkO1xufVxuXG4vKipcbiAqIFRoZSB2YXJpb3VzIHN0YXRlcyB0aGF0IGEgbmV0d29ya2luZyBpbnN0YW5jZSBjYW4gYmUgaW4uXG4gKi9cbmV4cG9ydCB0eXBlIE5ldHdvcmtpbmdTdGF0ZSA9XG5OZXR3b3JraW5nQ2xvc2VkU3RhdGUgfFxuTmV0d29ya2luZ0lkZW50aWZ5aW5nU3RhdGUgfFxuTmV0d29ya2luZ09wZW5pbmdXc1N0YXRlIHxcbk5ldHdvcmtpbmdSZWFkeVN0YXRlIHxcbk5ldHdvcmtpbmdSZXN1bWluZ1N0YXRlIHxcbk5ldHdvcmtpbmdTZWxlY3RpbmdQcm90b2NvbFN0YXRlIHxcbk5ldHdvcmtpbmdVZHBIYW5kc2hha2luZ1N0YXRlO1xuXG4vKipcbiAqIERldGFpbHMgcmVxdWlyZWQgdG8gY29ubmVjdCB0byB0aGUgRGlzY29yZCB2b2ljZSBnYXRld2F5LiBUaGVzZSBkZXRhaWxzXG4gKiBhcmUgZmlyc3QgcmVjZWl2ZWQgb24gdGhlIG1haW4gYm90IGdhdGV3YXksIGluIHRoZSBmb3JtIG9mIFZPSUNFX1NFUlZFUl9VUERBVEVcbiAqIGFuZCBWT0lDRV9TVEFURV9VUERBVEUgcGFja2V0cy5cbiAqL1xuaW50ZXJmYWNlIENvbm5lY3Rpb25PcHRpb25zIHtcbiAgZW5kcG9pbnQ6IHN0cmluZztcbiAgc2VydmVySWQ6IHN0cmluZztcbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIHRva2VuOiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xufVxuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGNvbm5lY3Rpb24sIGUuZy4gd2hpY2ggZW5jcnlwdGlvbiBtb2RlIGlzIHRvIGJlIHVzZWQgb25cbiAqIHRoZSBjb25uZWN0aW9uLCB0aW1pbmcgaW5mb3JtYXRpb24gZm9yIHBsYXliYWNrIG9mIHN0cmVhbXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdGlvbkRhdGEge1xuICBlbmNyeXB0aW9uTW9kZTogc3RyaW5nO1xuICBub25jZTogbnVtYmVyO1xuICBub25jZUJ1ZmZlcjogQnVmZmVyO1xuICBwYWNrZXRzUGxheWVkOiBudW1iZXI7XG4gIHNlY3JldEtleTogVWludDhBcnJheTtcbiAgc2VxdWVuY2U6IG51bWJlcjtcbiAgc3BlYWtpbmc6IGJvb2xlYW47XG4gIHNzcmM6IG51bWJlcjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbi8qKlxuICogQW4gZW1wdHkgYnVmZmVyIHRoYXQgaXMgcmV1c2VkIGluIHBhY2tldCBlbmNyeXB0aW9uIGJ5IG1hbnkgZGlmZmVyZW50IG5ldHdvcmtpbmcgaW5zdGFuY2VzLlxuICovXG5jb25zdCBub25jZSA9IEJ1ZmZlci5hbGxvYygyNCk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya2luZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBEZWJ1ZyBldmVudCBmb3IgTmV0d29ya2luZy5cbiAgICpcbiAgICogQGV2ZW50UHJvcGVydHlcbiAgICovXG4gIG9uKGV2ZW50OiAnZGVidWcnLCBsaXN0ZW5lcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCk6IHRoaXM7XG4gIG9uKGV2ZW50OiAnZXJyb3InLCBsaXN0ZW5lcjogKGVycm9yOiBFcnJvcikgPT4gdm9pZCk6IHRoaXM7XG4gIG9uKFxuICBldmVudDogJ3N0YXRlQ2hhbmdlJyxcbiAgbGlzdGVuZXI6IChvbGRTdGF0ZTogTmV0d29ya2luZ1N0YXRlLCBuZXdTdGF0ZTogTmV0d29ya2luZ1N0YXRlKSA9PiB2b2lkKVxuICA6IHRoaXM7XG4gIG9uKGV2ZW50OiAnY2xvc2UnLCBsaXN0ZW5lcjogKGNvZGU6IG51bWJlcikgPT4gdm9pZCk6IHRoaXM7XG59XG5cbi8qKlxuICogU3RyaW5naWZpZXMgYSBOZXR3b3JraW5nU3RhdGUuXG4gKlxuICogQHBhcmFtIHN0YXRlIC0gVGhlIHN0YXRlIHRvIHN0cmluZ2lmeVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTdGF0ZShzdGF0ZTogTmV0d29ya2luZ1N0YXRlKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgLi4uc3RhdGUsXG4gICAgd3M6IFJlZmxlY3QuaGFzKHN0YXRlLCAnd3MnKSxcbiAgICB1ZHA6IFJlZmxlY3QuaGFzKHN0YXRlLCAndWRwJylcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hvb3NlcyBhbiBlbmNyeXB0aW9uIG1vZGUgZnJvbSBhIGxpc3Qgb2YgZ2l2ZW4gb3B0aW9ucy4gQ2hvb3NlcyB0aGUgbW9zdCBwcmVmZXJyZWQgb3B0aW9uLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGF2YWlsYWJsZSBlbmNyeXB0aW9uIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY2hvb3NlRW5jcnlwdGlvbk1vZGUob3B0aW9uczogc3RyaW5nW10pOiBzdHJpbmcge1xuICBjb25zdCBvcHRpb24gPSBvcHRpb25zLmZpbmQoKG9wdGlvbikgPT5cbiAgU1VQUE9SVEVEX0VOQ1JZUFRJT05fTU9ERVMuaW5jbHVkZXMob3B0aW9uKVxuICApO1xuICBpZiAoIW9wdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBObyBjb21wYXRpYmxlIGVuY3J5cHRpb24gbW9kZXMuIEF2YWlsYWJsZSBpbmNsdWRlOiAke29wdGlvbnMuam9pbihcbiAgICAgICAgJywgJ1xuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb247XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgdGhhdCBpcyBpbiB0aGUgcmFuZ2Ugb2YgbiBiaXRzLlxuICpcbiAqIEBwYXJhbSBudW1iZXJPZkJpdHMgLSBUaGUgbnVtYmVyIG9mIGJpdHNcbiAqL1xuZnVuY3Rpb24gcmFuZG9tTkJpdChudW1iZXJPZkJpdHM6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMiAqKiBudW1iZXJPZkJpdHMpO1xufVxuXG4vKipcbiAqIE1hbmFnZXMgdGhlIG5ldHdvcmtpbmcgcmVxdWlyZWQgdG8gbWFpbnRhaW4gYSB2b2ljZSBjb25uZWN0aW9uIGFuZCBkaXNwYXRjaCBhdWRpbyBwYWNrZXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXR3b3JraW5nIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSBfc3RhdGU6IE5ldHdvcmtpbmdTdGF0ZTtcblxuICAvKipcbiAgICogVGhlIGRlYnVnIGxvZ2dlciBmdW5jdGlvbiwgaWYgZGVidWdnaW5nIGlzIGVuYWJsZWQuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGRlYnVnOiAoKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCkgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE5ldHdvcmtpbmcgaW5zdGFuY2UuXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Iob3B0aW9uczogQ29ubmVjdGlvbk9wdGlvbnMsIGRlYnVnOiBib29sZWFuKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub25Xc09wZW4gPSB0aGlzLm9uV3NPcGVuLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkNoaWxkRXJyb3IgPSB0aGlzLm9uQ2hpbGRFcnJvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Xc1BhY2tldCA9IHRoaXMub25Xc1BhY2tldC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Xc0Nsb3NlID0gdGhpcy5vbldzQ2xvc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uV3NEZWJ1ZyA9IHRoaXMub25Xc0RlYnVnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblVkcERlYnVnID0gdGhpcy5vblVkcERlYnVnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblVkcENsb3NlID0gdGhpcy5vblVkcENsb3NlLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmRlYnVnID0gZGVidWcgP1xuICAgIChtZXNzYWdlOiBzdHJpbmcpID0+IHRoaXMuZW1pdCgnZGVidWcnLCBtZXNzYWdlKSA6XG4gICAgbnVsbDtcblxuICAgIHRoaXMuX3N0YXRlID0ge1xuICAgICAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuT3BlbmluZ1dzLFxuICAgICAgd3M6IHRoaXMuY3JlYXRlV2ViU29ja2V0KG9wdGlvbnMuZW5kcG9pbnQpLFxuICAgICAgY29ubmVjdGlvbk9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBOZXR3b3JraW5nIGluc3RhbmNlLCB0cmFuc2l0aW9uaW5nIGl0IGludG8gdGhlIENsb3NlZCBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBjb2RlOiBOZXR3b3JraW5nU3RhdHVzQ29kZS5DbG9zZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBuZXR3b3JraW5nIGluc3RhbmNlLlxuICAgKi9cbiAgcHVibGljIGdldCBzdGF0ZSgpOiBOZXR3b3JraW5nU3RhdGUge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IHN0YXRlIGZvciB0aGUgbmV0d29ya2luZyBpbnN0YW5jZSwgcGVyZm9ybWluZyBjbGVhbi11cCBvcGVyYXRpb25zIHdoZXJlIG5lY2Vzc2FyeS5cbiAgICovXG4gIHB1YmxpYyBzZXQgc3RhdGUobmV3U3RhdGU6IE5ldHdvcmtpbmdTdGF0ZSkge1xuICAgIGNvbnN0IG9sZFdzID0gUmVmbGVjdC5nZXQodGhpcy5fc3RhdGUsICd3cycpIGFzIFZvaWNlV2ViU29ja2V0IHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5ld1dzID0gUmVmbGVjdC5nZXQobmV3U3RhdGUsICd3cycpIGFzIFZvaWNlV2ViU29ja2V0IHwgdW5kZWZpbmVkO1xuICAgIGlmIChvbGRXcyAmJiBvbGRXcyAhPT0gbmV3V3MpIHtcbiAgICAgIC8vIFRoZSBvbGQgV2ViU29ja2V0IGlzIGJlaW5nIGZyZWVkIC0gcmVtb3ZlIGFsbCBoYW5kbGVycyBmcm9tIGl0XG4gICAgICBvbGRXcy5vZmYoJ2RlYnVnJywgdGhpcy5vbldzRGVidWcpO1xuICAgICAgb2xkV3Mub24oJ2Vycm9yJywgbm9vcCk7XG4gICAgICBvbGRXcy5vZmYoJ2Vycm9yJywgdGhpcy5vbkNoaWxkRXJyb3IpO1xuICAgICAgb2xkV3Mub2ZmKCdvcGVuJywgdGhpcy5vbldzT3Blbik7XG4gICAgICBvbGRXcy5vZmYoJ3BhY2tldCcsIHRoaXMub25Xc1BhY2tldCk7XG4gICAgICBvbGRXcy5vZmYoJ2Nsb3NlJywgdGhpcy5vbldzQ2xvc2UpO1xuICAgICAgb2xkV3MuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZFVkcCA9IFJlZmxlY3QuZ2V0KHRoaXMuX3N0YXRlLCAndWRwJykgYXNcbiAgICBWb2ljZVVEUFNvY2tldCB8XG4gICAgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5ld1VkcCA9IFJlZmxlY3QuZ2V0KG5ld1N0YXRlLCAndWRwJykgYXMgVm9pY2VVRFBTb2NrZXQgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAob2xkVWRwICYmIG9sZFVkcCAhPT0gbmV3VWRwKSB7XG4gICAgICBvbGRVZHAub24oJ2Vycm9yJywgbm9vcCk7XG4gICAgICBvbGRVZHAub2ZmKCdlcnJvcicsIHRoaXMub25DaGlsZEVycm9yKTtcbiAgICAgIG9sZFVkcC5vZmYoJ2Nsb3NlJywgdGhpcy5vblVkcENsb3NlKTtcbiAgICAgIG9sZFVkcC5vZmYoJ2RlYnVnJywgdGhpcy5vblVkcERlYnVnKTtcbiAgICAgIG9sZFVkcC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2UnLCBvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuXG4gICAgdGhpcy5kZWJ1Zz8uKFxuICAgICAgYHN0YXRlIGNoYW5nZTpcXG5mcm9tICR7c3RyaW5naWZ5U3RhdGUob2xkU3RhdGUpfVxcbnRvICR7c3RyaW5naWZ5U3RhdGUoXG4gICAgICAgIG5ld1N0YXRlXG4gICAgICApfWBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgV2ViU29ja2V0IHRvIGEgRGlzY29yZCBWb2ljZSBnYXRld2F5LlxuICAgKlxuICAgKiBAcGFyYW0gZW5kcG9pbnQgLSBUaGUgZW5kcG9pbnQgdG8gY29ubmVjdCB0b1xuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVXZWJTb2NrZXQoZW5kcG9pbnQ6IHN0cmluZykge1xuICAgIGNvbnN0IHdzID0gbmV3IFZvaWNlV2ViU29ja2V0KGB3c3M6Ly8ke2VuZHBvaW50fT92PTRgLCBCb29sZWFuKHRoaXMuZGVidWcpKTtcblxuICAgIHdzLm9uKCdlcnJvcicsIHRoaXMub25DaGlsZEVycm9yKTtcbiAgICB3cy5vbmNlKCdvcGVuJywgdGhpcy5vbldzT3Blbik7XG4gICAgd3Mub24oJ3BhY2tldCcsIHRoaXMub25Xc1BhY2tldCk7XG4gICAgd3Mub25jZSgnY2xvc2UnLCB0aGlzLm9uV3NDbG9zZSk7XG4gICAgd3Mub24oJ2RlYnVnJywgdGhpcy5vbldzRGVidWcpO1xuXG4gICAgcmV0dXJuIHdzO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZXMgZXJyb3JzIGZyb20gdGhlIGNoaWxkcmVuIFZvaWNlV2ViU29ja2V0IGFuZCBWb2ljZVVEUFNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRoYXQgd2FzIGVtaXR0ZWQgYnkgYSBjaGlsZFxuICAgKi9cbiAgcHJpdmF0ZSBvbkNoaWxkRXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IG9wZW5zLiBEZXBlbmRpbmcgb24gdGhlIHN0YXRlIHRoYXQgdGhlIGluc3RhbmNlIGlzIGluLFxuICAgKiBpdCB3aWxsIGVpdGhlciBpZGVudGlmeSB3aXRoIGEgbmV3IHNlc3Npb24sIG9yIGl0IHdpbGwgYXR0ZW1wdCB0byByZXN1bWUgYW4gZXhpc3Rpbmcgc2Vzc2lvbi5cbiAgICovXG4gIHByaXZhdGUgb25Xc09wZW4oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuY29kZSA9PT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuT3BlbmluZ1dzKSB7XG4gICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgIG9wOiBWb2ljZU9wY29kZXMuSWRlbnRpZnksXG4gICAgICAgIGQ6IHtcbiAgICAgICAgICBzZXJ2ZXJfaWQ6IHRoaXMuc3RhdGUuY29ubmVjdGlvbk9wdGlvbnMuc2VydmVySWQsXG4gICAgICAgICAgdXNlcl9pZDogdGhpcy5zdGF0ZS5jb25uZWN0aW9uT3B0aW9ucy51c2VySWQsXG4gICAgICAgICAgc2Vzc2lvbl9pZDogdGhpcy5zdGF0ZS5jb25uZWN0aW9uT3B0aW9ucy5zZXNzaW9uSWQsXG4gICAgICAgICAgdG9rZW46IHRoaXMuc3RhdGUuY29ubmVjdGlvbk9wdGlvbnMudG9rZW5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGUud3Muc2VuZFBhY2tldChwYWNrZXQpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuSWRlbnRpZnlpbmdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmNvZGUgPT09IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlJlc3VtaW5nKSB7XG4gICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgIG9wOiBWb2ljZU9wY29kZXMuUmVzdW1lLFxuICAgICAgICBkOiB7XG4gICAgICAgICAgc2VydmVyX2lkOiB0aGlzLnN0YXRlLmNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcklkLFxuICAgICAgICAgIHNlc3Npb25faWQ6IHRoaXMuc3RhdGUuY29ubmVjdGlvbk9wdGlvbnMuc2Vzc2lvbklkLFxuICAgICAgICAgIHRva2VuOiB0aGlzLnN0YXRlLmNvbm5lY3Rpb25PcHRpb25zLnRva2VuXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlLndzLnNlbmRQYWNrZXQocGFja2V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIFdlYlNvY2tldCBjbG9zZXMuIEJhc2VkIG9uIHRoZSByZWFzb24gZm9yIGNsb3NpbmcgKGdpdmVuIGJ5IHRoZSBjb2RlIHBhcmFtZXRlciksXG4gICAqIHRoZSBpbnN0YW5jZSB3aWxsIGVpdGhlciBhdHRlbXB0IHRvIHJlc3VtZSwgb3IgZW50ZXIgdGhlIGNsb3NlZCBzdGF0ZSBhbmQgZW1pdCBhICdjbG9zZScgZXZlbnRcbiAgICogd2l0aCB0aGUgY2xvc2UgY29kZSwgYWxsb3dpbmcgdGhlIHVzZXIgdG8gZGVjaWRlIHdoZXRoZXIgb3Igbm90IHRoZXkgd291bGQgbGlrZSB0byByZWNvbm5lY3QuXG4gICAqXG4gICAqIEBwYXJhbSBjb2RlIC0gVGhlIGNsb3NlIGNvZGVcbiAgICovXG4gIHByaXZhdGUgb25Xc0Nsb3NlKHsgY29kZSB9OiBDbG9zZUV2ZW50KSB7XG4gICAgY29uc3QgY2FuUmVzdW1lID0gY29kZSA9PT0gNF8wMTUgfHwgY29kZSA8IDRfMDAwO1xuICAgIGlmIChjYW5SZXN1bWUgJiYgdGhpcy5zdGF0ZS5jb2RlID09PSBOZXR3b3JraW5nU3RhdHVzQ29kZS5SZWFkeSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVzdW1pbmcsXG4gICAgICAgIHdzOiB0aGlzLmNyZWF0ZVdlYlNvY2tldCh0aGlzLnN0YXRlLmNvbm5lY3Rpb25PcHRpb25zLmVuZHBvaW50KVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuY29kZSAhPT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuQ2xvc2VkKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIFVEUCBzb2NrZXQgaGFzIGNsb3NlZCBpdHNlbGYgaWYgaXQgaGFzIHN0b3BwZWQgcmVjZWl2aW5nIHJlcGxpZXMgZnJvbSBEaXNjb3JkLlxuICAgKi9cbiAgcHJpdmF0ZSBvblVkcENsb3NlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmNvZGUgPT09IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlJlYWR5KSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICBjb2RlOiBOZXR3b3JraW5nU3RhdHVzQ29kZS5SZXN1bWluZyxcbiAgICAgICAgd3M6IHRoaXMuY3JlYXRlV2ViU29ja2V0KHRoaXMuc3RhdGUuY29ubmVjdGlvbk9wdGlvbnMuZW5kcG9pbnQpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHBhY2tldCBpcyByZWNlaXZlZCBvbiB0aGUgY29ubmVjdGlvbidzIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHBhY2tldCAtIFRoZSByZWNlaXZlZCBwYWNrZXRcbiAgICovXG4gIHByaXZhdGUgb25Xc1BhY2tldChwYWNrZXQ6IHVuc2FmZSkge1xuICAgIGlmIChcbiAgICBwYWNrZXQub3AgPT09IFZvaWNlT3Bjb2Rlcy5IZWxsbyAmJlxuICAgIHRoaXMuc3RhdGUuY29kZSAhPT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuQ2xvc2VkKVxuICAgIHtcbiAgICAgIHRoaXMuc3RhdGUud3Muc2V0SGVhcnRiZWF0SW50ZXJ2YWwocGFja2V0LmQuaGVhcnRiZWF0X2ludGVydmFsKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgIHBhY2tldC5vcCA9PT0gVm9pY2VPcGNvZGVzLlJlYWR5ICYmXG4gICAgdGhpcy5zdGF0ZS5jb2RlID09PSBOZXR3b3JraW5nU3RhdHVzQ29kZS5JZGVudGlmeWluZylcbiAgICB7XG4gICAgICBjb25zdCB7IGlwLCBwb3J0LCBzc3JjLCBtb2RlcyB9ID0gcGFja2V0LmQ7XG5cbiAgICAgIGNvbnN0IHVkcCA9IG5ldyBWb2ljZVVEUFNvY2tldCh7IGlwLCBwb3J0IH0pO1xuICAgICAgdWRwLm9uKCdlcnJvcicsIHRoaXMub25DaGlsZEVycm9yKTtcbiAgICAgIHVkcC5vbignZGVidWcnLCB0aGlzLm9uVWRwRGVidWcpO1xuICAgICAgdWRwLm9uY2UoJ2Nsb3NlJywgdGhpcy5vblVkcENsb3NlKTtcbiAgICAgIHVkcC5cbiAgICAgIHBlcmZvcm1JUERpc2NvdmVyeShzc3JjKS5cbiAgICAgIHRoZW4oKGxvY2FsQ29uZmlnKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNvZGUgIT09IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlVkcEhhbmRzaGFraW5nKSByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhdGUud3Muc2VuZFBhY2tldCh7XG4gICAgICAgICAgb3A6IFZvaWNlT3Bjb2Rlcy5TZWxlY3RQcm90b2NvbCxcbiAgICAgICAgICBkOiB7XG4gICAgICAgICAgICBwcm90b2NvbDogJ3VkcCcsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGFkZHJlc3M6IGxvY2FsQ29uZmlnLmlwLFxuICAgICAgICAgICAgICBwb3J0OiBsb2NhbENvbmZpZy5wb3J0LFxuICAgICAgICAgICAgICBtb2RlOiBjaG9vc2VFbmNyeXB0aW9uTW9kZShtb2RlcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgICAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuU2VsZWN0aW5nUHJvdG9jb2xcbiAgICAgICAgfTtcbiAgICAgIH0pLlxuICAgICAgY2F0Y2goKGVycm9yOiBFcnJvcikgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKSk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgIGNvZGU6IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlVkcEhhbmRzaGFraW5nLFxuICAgICAgICB1ZHAsXG4gICAgICAgIGNvbm5lY3Rpb25EYXRhOiB7XG4gICAgICAgICAgc3NyY1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgcGFja2V0Lm9wID09PSBWb2ljZU9wY29kZXMuU2Vzc2lvbkRlc2NyaXB0aW9uICYmXG4gICAgdGhpcy5zdGF0ZS5jb2RlID09PSBOZXR3b3JraW5nU3RhdHVzQ29kZS5TZWxlY3RpbmdQcm90b2NvbClcbiAgICB7XG4gICAgICBjb25zdCB7IG1vZGU6IGVuY3J5cHRpb25Nb2RlLCBzZWNyZXRfa2V5OiBzZWNyZXRLZXkgfSA9IHBhY2tldC5kO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVhZHksXG4gICAgICAgIGNvbm5lY3Rpb25EYXRhOiB7XG4gICAgICAgICAgLi4udGhpcy5zdGF0ZS5jb25uZWN0aW9uRGF0YSxcbiAgICAgICAgICBlbmNyeXB0aW9uTW9kZSxcbiAgICAgICAgICBzZWNyZXRLZXk6IG5ldyBVaW50OEFycmF5KHNlY3JldEtleSksXG4gICAgICAgICAgc2VxdWVuY2U6IHJhbmRvbU5CaXQoMTYpLFxuICAgICAgICAgIHRpbWVzdGFtcDogcmFuZG9tTkJpdCgzMiksXG4gICAgICAgICAgbm9uY2U6IDAsXG4gICAgICAgICAgbm9uY2VCdWZmZXI6XG4gICAgICAgICAgZW5jcnlwdGlvbk1vZGUgPT09ICdhZWFkX2FlczI1Nl9nY21fcnRwc2l6ZScgP1xuICAgICAgICAgIEJ1ZmZlci5hbGxvYygxMikgOlxuICAgICAgICAgIEJ1ZmZlci5hbGxvYygyNCksXG4gICAgICAgICAgc3BlYWtpbmc6IGZhbHNlLFxuICAgICAgICAgIHBhY2tldHNQbGF5ZWQ6IDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKFxuICAgIHBhY2tldC5vcCA9PT0gVm9pY2VPcGNvZGVzLlJlc3VtZWQgJiZcbiAgICB0aGlzLnN0YXRlLmNvZGUgPT09IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlJlc3VtaW5nKVxuICAgIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgIGNvZGU6IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlJlYWR5XG4gICAgICB9O1xuICAgICAgdGhpcy5zdGF0ZS5jb25uZWN0aW9uRGF0YS5zcGVha2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9wYWdhdGVzIGRlYnVnIG1lc3NhZ2VzIGZyb20gdGhlIGNoaWxkIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZW1pdHRlZCBkZWJ1ZyBtZXNzYWdlXG4gICAqL1xuICBwcml2YXRlIG9uV3NEZWJ1ZyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmRlYnVnPy4oYFtXU10gJHttZXNzYWdlfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZXMgZGVidWcgbWVzc2FnZXMgZnJvbSB0aGUgY2hpbGQgVURQU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlbWl0dGVkIGRlYnVnIG1lc3NhZ2VcbiAgICovXG4gIHByaXZhdGUgb25VZHBEZWJ1ZyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmRlYnVnPy4oYFtVRFBdICR7bWVzc2FnZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyBhbiBPcHVzIHBhY2tldCBmb3IgcGxheWJhY2suIFRoaXMgaW5jbHVkZXMgYXR0YWNoaW5nIG1ldGFkYXRhIHRvIGl0IGFuZCBlbmNyeXB0aW5nIGl0LlxuICAgKiBJdCB3aWxsIGJlIHN0b3JlZCB3aXRoaW4gdGhlIGluc3RhbmNlLCBhbmQgY2FuIGJlIHBsYXllZCBieSBkaXNwYXRjaEF1ZGlvKClcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aGlsZSB0aGVyZSBpcyBhbHJlYWR5IGEgcHJlcGFyZWQgYXVkaW8gcGFja2V0IHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBkaXNwYXRjaGVkXG4gICAqIHdpbGwgb3ZlcndyaXRlIHRoZSBleGlzdGluZyBhdWRpbyBwYWNrZXQuIFRoaXMgc2hvdWxkIGJlIGF2b2lkZWQuXG4gICAqIEBwYXJhbSBvcHVzUGFja2V0IC0gVGhlIE9wdXMgcGFja2V0IHRvIGVuY3J5cHRcbiAgICogQHJldHVybnMgVGhlIGF1ZGlvIHBhY2tldCB0aGF0IHdhcyBwcmVwYXJlZFxuICAgKi9cbiAgcHVibGljIHByZXBhcmVBdWRpb1BhY2tldChvcHVzUGFja2V0OiBCdWZmZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLmNvZGUgIT09IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlJlYWR5KSByZXR1cm47XG4gICAgc3RhdGUucHJlcGFyZWRQYWNrZXQgPSB0aGlzLmNyZWF0ZUF1ZGlvUGFja2V0KFxuICAgICAgb3B1c1BhY2tldCxcbiAgICAgIHN0YXRlLmNvbm5lY3Rpb25EYXRhXG4gICAgKTtcbiAgICByZXR1cm4gc3RhdGUucHJlcGFyZWRQYWNrZXQ7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB0aGUgYXVkaW8gcGFja2V0IHByZXZpb3VzbHkgcHJlcGFyZWQgYnkgcHJlcGFyZUF1ZGlvUGFja2V0KG9wdXNQYWNrZXQpLiBUaGUgYXVkaW8gcGFja2V0XG4gICAqIGlzIGNvbnN1bWVkIGFuZCBjYW5ub3QgYmUgZGlzcGF0Y2hlZCBhZ2Fpbi5cbiAgICovXG4gIHB1YmxpYyBkaXNwYXRjaEF1ZGlvKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuY29kZSAhPT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVhZHkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc3RhdGUucHJlcGFyZWRQYWNrZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5wbGF5QXVkaW9QYWNrZXQoc3RhdGUucHJlcGFyZWRQYWNrZXQpO1xuICAgICAgc3RhdGUucHJlcGFyZWRQYWNrZXQgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUGxheXMgYW4gYXVkaW8gcGFja2V0LCB1cGRhdGluZyB0aW1pbmcgbWV0YWRhdGEgdXNlZCBmb3IgcGxheWJhY2suXG4gICAqXG4gICAqIEBwYXJhbSBhdWRpb1BhY2tldCAtIFRoZSBhdWRpbyBwYWNrZXQgdG8gcGxheVxuICAgKi9cbiAgcHJpdmF0ZSBwbGF5QXVkaW9QYWNrZXQoYXVkaW9QYWNrZXQ6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuY29kZSAhPT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVhZHkpIHJldHVybjtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25EYXRhIH0gPSBzdGF0ZTtcbiAgICBjb25uZWN0aW9uRGF0YS5wYWNrZXRzUGxheWVkKys7XG4gICAgY29ubmVjdGlvbkRhdGEuc2VxdWVuY2UrKztcbiAgICBjb25uZWN0aW9uRGF0YS50aW1lc3RhbXAgKz0gVElNRVNUQU1QX0lOQztcbiAgICBpZiAoY29ubmVjdGlvbkRhdGEuc2VxdWVuY2UgPj0gMiAqKiAxNikgY29ubmVjdGlvbkRhdGEuc2VxdWVuY2UgPSAwO1xuICAgIGlmIChjb25uZWN0aW9uRGF0YS50aW1lc3RhbXAgPj0gMiAqKiAzMikgY29ubmVjdGlvbkRhdGEudGltZXN0YW1wID0gMDtcbiAgICB0aGlzLnNldFNwZWFraW5nKHRydWUpO1xuICAgIHN0YXRlLnVkcC5zZW5kKGF1ZGlvUGFja2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBhY2tldCB0byB0aGUgdm9pY2UgZ2F0ZXdheSBpbmRpY2F0aW5nIHRoYXQgdGhlIGNsaWVudCBoYXMgc3RhcnQvc3RvcHBlZCBzZW5kaW5nXG4gICAqIGF1ZGlvLlxuICAgKlxuICAgKiBAcGFyYW0gc3BlYWtpbmcgLSBXaGV0aGVyIG9yIG5vdCB0aGUgY2xpZW50IHNob3VsZCBiZSBzaG93biBhcyBzcGVha2luZ1xuICAgKi9cbiAgcHVibGljIHNldFNwZWFraW5nKHNwZWFraW5nOiBib29sZWFuKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5jb2RlICE9PSBOZXR3b3JraW5nU3RhdHVzQ29kZS5SZWFkeSkgcmV0dXJuO1xuICAgIGlmIChzdGF0ZS5jb25uZWN0aW9uRGF0YS5zcGVha2luZyA9PT0gc3BlYWtpbmcpIHJldHVybjtcbiAgICBzdGF0ZS5jb25uZWN0aW9uRGF0YS5zcGVha2luZyA9IHNwZWFraW5nO1xuICAgIHN0YXRlLndzLnNlbmRQYWNrZXQoe1xuICAgICAgb3A6IFZvaWNlT3Bjb2Rlcy5TcGVha2luZyxcbiAgICAgIGQ6IHtcbiAgICAgICAgc3BlYWtpbmc6IHNwZWFraW5nID8gMSA6IDAsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBzc3JjOiBzdGF0ZS5jb25uZWN0aW9uRGF0YS5zc3JjXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBhdWRpbyBwYWNrZXQgZnJvbSBhbiBPcHVzIHBhY2tldC4gVGhpcyBpbnZvbHZlcyBlbmNyeXB0aW5nIHRoZSBwYWNrZXQsXG4gICAqIHRoZW4gcHJlcGVuZGluZyBhIGhlYWRlciB0aGF0IGluY2x1ZGVzIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gb3B1c1BhY2tldCAtIFRoZSBPcHVzIHBhY2tldCB0byBwcmVwYXJlXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uRGF0YSAtIFRoZSBjdXJyZW50IGNvbm5lY3Rpb24gZGF0YSBvZiB0aGUgaW5zdGFuY2VcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlQXVkaW9QYWNrZXQoXG4gIG9wdXNQYWNrZXQ6IEJ1ZmZlcixcbiAgY29ubmVjdGlvbkRhdGE6IENvbm5lY3Rpb25EYXRhKVxuICB7XG4gICAgY29uc3QgcGFja2V0QnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgICBwYWNrZXRCdWZmZXJbMF0gPSAweDgwO1xuICAgIHBhY2tldEJ1ZmZlclsxXSA9IDB4Nzg7XG5cbiAgICBjb25zdCB7IHNlcXVlbmNlLCB0aW1lc3RhbXAsIHNzcmMgfSA9IGNvbm5lY3Rpb25EYXRhO1xuXG4gICAgcGFja2V0QnVmZmVyLndyaXRlVUludEJFKHNlcXVlbmNlLCAyLCAyKTtcbiAgICBwYWNrZXRCdWZmZXIud3JpdGVVSW50QkUodGltZXN0YW1wLCA0LCA0KTtcbiAgICBwYWNrZXRCdWZmZXIud3JpdGVVSW50QkUoc3NyYywgOCwgNCk7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcGFja2V0QnVmZmVyLmNvcHkobm9uY2UsIDAsIDAsIDEyKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBhY2tldEJ1ZmZlcixcbiAgICAuLi50aGlzLmVuY3J5cHRPcHVzUGFja2V0KG9wdXNQYWNrZXQsIGNvbm5lY3Rpb25EYXRhLCBwYWNrZXRCdWZmZXIpXVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRW5jcnlwdHMgYW4gT3B1cyBwYWNrZXQgdXNpbmcgdGhlIGZvcm1hdCBhZ3JlZWQgdXBvbiBieSB0aGUgaW5zdGFuY2UgYW5kIERpc2NvcmQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHVzUGFja2V0IC0gVGhlIE9wdXMgcGFja2V0IHRvIGVuY3J5cHRcbiAgICogQHBhcmFtIGNvbm5lY3Rpb25EYXRhIC0gVGhlIGN1cnJlbnQgY29ubmVjdGlvbiBkYXRhIG9mIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBlbmNyeXB0T3B1c1BhY2tldChcbiAgb3B1c1BhY2tldDogQnVmZmVyLFxuICBjb25uZWN0aW9uRGF0YTogQ29ubmVjdGlvbkRhdGEsXG4gIGRhdGE6IEJ1ZmZlcilcbiAge1xuICAgIGNvbnN0IHsgc2VjcmV0S2V5LCBlbmNyeXB0aW9uTW9kZSB9ID0gY29ubmVjdGlvbkRhdGE7XG5cbiAgICAvLyBCb3RoIHN1cHBvcnRlZCBlbmNyeXB0aW9uIG1ldGhvZHMgd2FudCB0aGUgbm9uY2UgdG8gYmUgYW4gaW5jcmVtZW50YWwgaW50ZWdlclxuICAgIGNvbm5lY3Rpb25EYXRhLm5vbmNlKys7XG4gICAgaWYgKGNvbm5lY3Rpb25EYXRhLm5vbmNlID4gTUFYX05PTkNFX1NJWkUpIGNvbm5lY3Rpb25EYXRhLm5vbmNlID0gMDtcbiAgICBjb25uZWN0aW9uRGF0YS5ub25jZUJ1ZmZlci53cml0ZVVJbnQzMkJFKGNvbm5lY3Rpb25EYXRhLm5vbmNlLCAwKTtcblxuICAgIC8vIDQgZXh0cmEgYnl0ZXMgb2YgcGFkZGluZyBvbiB0aGUgZW5kIG9mIHRoZSBlbmNyeXB0ZWQgcGFja2V0XG4gICAgY29uc3Qgbm9uY2VQYWRkaW5nID0gY29ubmVjdGlvbkRhdGEubm9uY2VCdWZmZXIuc3ViYXJyYXkoMCwgNCk7XG5cbiAgICBsZXQgZW5jcnlwdGVkO1xuICAgIHN3aXRjaCAoZW5jcnlwdGlvbk1vZGUpIHtcbiAgICAgIGNhc2UgJ2FlYWRfYWVzMjU2X2djbV9ydHBzaXplJzp7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihcbiAgICAgICAgICAgICdhZXMtMjU2LWdjbScsXG4gICAgICAgICAgICBzZWNyZXRLZXksXG4gICAgICAgICAgICBjb25uZWN0aW9uRGF0YS5ub25jZUJ1ZmZlclxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGNpcGhlci5zZXRBQUQoZGF0YSk7XG5cbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgZW5jcnlwdGVkID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgY2lwaGVyLnVwZGF0ZShvcHVzUGFja2V0KSxcbiAgICAgICAgICBjaXBoZXIuZmluYWwoKSxcbiAgICAgICAgICBjaXBoZXIuZ2V0QXV0aFRhZygpXVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICByZXR1cm4gW2VuY3J5cHRlZCwgbm9uY2VQYWRkaW5nXTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnYWVhZF94Y2hhY2hhMjBfcG9seTEzMDVfcnRwc2l6ZSc6e1xuICAgICAgICAgIGVuY3J5cHRlZCA9XG4gICAgICAgICAgc2VjcmV0Ym94Lm1ldGhvZHMuY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9lbmNyeXB0KFxuICAgICAgICAgICAgb3B1c1BhY2tldCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBjb25uZWN0aW9uRGF0YS5ub25jZUJ1ZmZlcixcbiAgICAgICAgICAgIHNlY3JldEtleVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICByZXR1cm4gW2VuY3J5cHRlZCwgbm9uY2VQYWRkaW5nXTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDp7XG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiBPdXIgZW5jcnlwdGlvbiBtb2RlIGlzIGNob3NlbiBmcm9tIGEgbGlzdCBnaXZlbiB0byB1cyBieSB0aGUgZ2F0ZXdheSBhbmQgY2hlY2tlZCB3aXRoIHRoZSBvbmVzIHdlIHN1cHBvcnQuXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICBgVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBtZXRob2Q6ICR7ZW5jcnlwdGlvbk1vZGV9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnbm9kZTpidWZmZXInO1xuXG5pbnRlcmZhY2UgTWV0aG9kcyB7XG4gIGNyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdChcbiAgcGxhaW50ZXh0OiBCdWZmZXIsXG4gIGFkZGl0aW9uYWxEYXRhOiBCdWZmZXIsXG4gIG5vbmNlOiBCdWZmZXIsXG4gIGtleTogQXJyYXlCdWZmZXJMaWtlKVxuICA6IEJ1ZmZlcjtcbn1cblxuY29uc3QgbGlicyA9IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgJ3NvZGl1bS1uYXRpdmUnOiAoc29kaXVtOiBhbnkpOiBNZXRob2RzID0+ICh7XG4gICAgY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9lbmNyeXB0OiAoXG4gICAgcGxhaW50ZXh0OiBCdWZmZXIsXG4gICAgYWRkaXRpb25hbERhdGE6IEJ1ZmZlcixcbiAgICBub25jZTogQnVmZmVyLFxuICAgIGtleTogQXJyYXlCdWZmZXJMaWtlKSA9PlxuICAgIHtcbiAgICAgIGNvbnN0IGNpcGhlclRleHQgPSBCdWZmZXIuYWxsb2MoXG4gICAgICAgIHBsYWludGV4dC5sZW5ndGggKyBzb2RpdW0uY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9BQllURVNcbiAgICAgICk7XG4gICAgICBzb2RpdW0uY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9lbmNyeXB0KFxuICAgICAgICBjaXBoZXJUZXh0LFxuICAgICAgICBwbGFpbnRleHQsXG4gICAgICAgIGFkZGl0aW9uYWxEYXRhLFxuICAgICAgICBudWxsLFxuICAgICAgICBub25jZSxcbiAgICAgICAga2V5XG4gICAgICApO1xuICAgICAgcmV0dXJuIGNpcGhlclRleHQ7XG4gICAgfVxuICB9KSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgc29kaXVtOiAoc29kaXVtOiBhbnkpOiBNZXRob2RzID0+ICh7XG4gICAgY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9lbmNyeXB0OiAoXG4gICAgcGxhaW50ZXh0OiBCdWZmZXIsXG4gICAgYWRkaXRpb25hbERhdGE6IEJ1ZmZlcixcbiAgICBub25jZTogQnVmZmVyLFxuICAgIGtleTogQXJyYXlCdWZmZXJMaWtlKSA9PlxuICAgIHtcbiAgICAgIHJldHVybiBzb2RpdW0uYXBpLmNyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdChcbiAgICAgICAgcGxhaW50ZXh0LFxuICAgICAgICBhZGRpdGlvbmFsRGF0YSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH0pLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAnbGlic29kaXVtLXdyYXBwZXJzJzogKHNvZGl1bTogYW55KTogTWV0aG9kcyA9PiAoe1xuICAgIGNyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdDogKFxuICAgIHBsYWludGV4dDogQnVmZmVyLFxuICAgIGFkZGl0aW9uYWxEYXRhOiBCdWZmZXIsXG4gICAgbm9uY2U6IEJ1ZmZlcixcbiAgICBrZXk6IEFycmF5QnVmZmVyTGlrZSkgPT5cbiAgICB7XG4gICAgICByZXR1cm4gc29kaXVtLmNyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdChcbiAgICAgICAgcGxhaW50ZXh0LFxuICAgICAgICBhZGRpdGlvbmFsRGF0YSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH0pLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAnQHN0YWJsZWxpYi94Y2hhY2hhMjBwb2x5MTMwNSc6IChzdGFibGVsaWI6IGFueSk6IE1ldGhvZHMgPT4gKHtcbiAgICBjcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX2VuY3J5cHQoXG4gICAgY2lwaGVyVGV4dCxcbiAgICBhZGRpdGlvbmFsRGF0YSxcbiAgICBub25jZSxcbiAgICBrZXkpXG4gICAge1xuICAgICAgY29uc3QgY3J5cHRvID0gbmV3IHN0YWJsZWxpYi5YQ2hhQ2hhMjBQb2x5MTMwNShrZXkpO1xuICAgICAgcmV0dXJuIGNyeXB0by5zZWFsKG5vbmNlLCBjaXBoZXJUZXh0LCBhZGRpdGlvbmFsRGF0YSk7XG4gICAgfVxuICB9KSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgJ0Bub2JsZS9jaXBoZXJzL2NoYWNoYSc6IChub2JsZTogYW55KTogTWV0aG9kcyA9PiAoe1xuICAgIGNyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdChcbiAgICBwbGFpbnRleHQsXG4gICAgYWRkaXRpb25hbERhdGEsXG4gICAgbm9uY2UsXG4gICAga2V5KVxuICAgIHtcbiAgICAgIGNvbnN0IGNoYWNoYSA9IG5vYmxlLnhjaGFjaGEyMHBvbHkxMzA1KGtleSwgbm9uY2UsIGFkZGl0aW9uYWxEYXRhKTtcbiAgICAgIHJldHVybiBjaGFjaGEuZW5jcnlwdChwbGFpbnRleHQpO1xuICAgIH1cbiAgfSlcbn0gYXMgY29uc3Q7XG5cbi8vIEB0cy1pZ25vcmVcbmxpYnNbJ3NvZGl1bS1qYXZhc2NyaXB0J10gPSBsaWJzWydzb2RpdW0tbmF0aXZlJ107XG5cbmNvbnN0IHZhbGlkTGlicyA9IE9iamVjdC5rZXlzKGxpYnMpO1xuXG5jb25zdCBmYWxsYmFja0Vycm9yID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYENhbm5vdCBwbGF5IGF1ZGlvIGFzIG5vIHZhbGlkIGVuY3J5cHRpb24gcGFja2FnZSBpcyBpbnN0YWxsZWQuXG4tIEluc3RhbGwgb25lIG9mIHRoZSBmb2xsb3dpbmcgcGFja2FnZXM6ICR7dmFsaWRMaWJzLmpvaW4oJywgJyl9XG4tIFVzZSB0aGUgZ2VuZXJhdGVEZXBlbmRlbmN5UmVwb3J0KCkgZnVuY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXFxuYFxuICApO1xufTtcblxuY29uc3QgbWV0aG9kczogTWV0aG9kcyA9IHtcbiAgY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9lbmNyeXB0OiBmYWxsYmFja0Vycm9yXG59O1xuXG52b2lkIChhc3luYyAoKSA9PiB7XG4gIGZvciAoY29uc3QgbGliTmFtZSBvZiBPYmplY3Qua2V5cyhsaWJzKSBhcyAoa2V5b2YgdHlwZW9mIGxpYnMpW10pIHtcbiAgICB0cnkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICAgIGNvbnN0IGxpYiA9IGF3YWl0IGltcG9ydChsaWJOYW1lKTtcbiAgICAgIGlmIChsaWJOYW1lID09PSAnbGlic29kaXVtLXdyYXBwZXJzJyAmJiBsaWIucmVhZHkpIGF3YWl0IGxpYi5yZWFkeTtcbiAgICAgIE9iamVjdC5hc3NpZ24obWV0aG9kcywgbGlic1tsaWJOYW1lXShsaWIpKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2gge1xuXG4gICAgICAvL1xuICAgIH19XG59KSgpO1xuXG5leHBvcnQgeyBtZXRob2RzIH07IiwgIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG5leHBvcnQgY29uc3Qgbm9vcCA9ICgpID0+IHt9OyIsICIvLyBDb3B5cmlnaHQgZGlzY29yZC1wbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIExpY2Vuc2UuXG4vLyBDb3B5cmlnaHQgZGlzY29yZC5qcyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBBcGFjaGUgTGljZW5zZSAyLjBcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZGVjbGFyYXRpb24tbWVyZ2luZyAqL1xuXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdub2RlOmJ1ZmZlcic7XG5pbXBvcnQgeyBjcmVhdGVTb2NrZXQsIHR5cGUgU29ja2V0IH0gZnJvbSAnbm9kZTpkZ3JhbSc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdub2RlOmV2ZW50cyc7XG5pbXBvcnQgeyBpc0lQdjQgfSBmcm9tICdub2RlOm5ldCc7XG5cbi8qKlxuICogU3RvcmVzIGFuIElQIGFkZHJlc3MgYW5kIHBvcnQuIFVzZWQgdG8gc3RvcmUgc29ja2V0IGRldGFpbHMgZm9yIHRoZSBsb2NhbCBjbGllbnQgYXMgd2VsbCBhc1xuICogZm9yIERpc2NvcmQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU29ja2V0Q29uZmlnIHtcbiAgaXA6IHN0cmluZztcbiAgcG9ydDogbnVtYmVyO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgcmVzcG9uc2UgZnJvbSBEaXNjb3JkIHRvIGFpZCB3aXRoIGxvY2FsIElQIGRpc2NvdmVyeS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSByZWNlaXZlZCBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUxvY2FsUGFja2V0KG1lc3NhZ2U6IEJ1ZmZlcik6IFNvY2tldENvbmZpZyB7XG4gIGNvbnN0IHBhY2tldCA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpO1xuXG4gIGNvbnN0IGlwID0gcGFja2V0LnNsaWNlKDgsIHBhY2tldC5pbmRleE9mKDAsIDgpKS50b1N0cmluZygndXRmOCcpO1xuXG4gIGlmICghaXNJUHY0KGlwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIElQIGFkZHJlc3MnKTtcbiAgfVxuXG4gIGNvbnN0IHBvcnQgPSBwYWNrZXQucmVhZFVJbnQxNkJFKHBhY2tldC5sZW5ndGggLSAyKTtcblxuICByZXR1cm4geyBpcCwgcG9ydCB9O1xufVxuXG4vKipcbiAqIFRoZSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgYXQgd2hpY2gga2VlcCBhbGl2ZSBkYXRhZ3JhbXMgYXJlIHNlbnQuXG4gKi9cbmNvbnN0IEtFRVBfQUxJVkVfSU5URVJWQUwgPSA1ZTM7XG5cbi8qKlxuICogVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIGtlZXAgYWxpdmUgY291bnRlci5cbiAqL1xuY29uc3QgTUFYX0NPVU5URVJfVkFMVUUgPSAyICoqIDMyIC0gMTtcblxuZXhwb3J0IGludGVyZmFjZSBWb2ljZVVEUFNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIG9uKGV2ZW50OiAnZXJyb3InLCBsaXN0ZW5lcjogKGVycm9yOiBFcnJvcikgPT4gdm9pZCk6IHRoaXM7XG4gIG9uKGV2ZW50OiAnY2xvc2UnLCBsaXN0ZW5lcjogKCkgPT4gdm9pZCk6IHRoaXM7XG4gIG9uKGV2ZW50OiAnZGVidWcnLCBsaXN0ZW5lcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCk6IHRoaXM7XG4gIG9uKGV2ZW50OiAnbWVzc2FnZScsIGxpc3RlbmVyOiAobWVzc2FnZTogQnVmZmVyKSA9PiB2b2lkKTogdGhpcztcbn1cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBVRFAgbmV0d29ya2luZyBmb3IgYSB2b2ljZSBjb25uZWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVm9pY2VVRFBTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogVGhlIHVuZGVybHlpbmcgbmV0d29yayBTb2NrZXQgZm9yIHRoZSBWb2ljZVVEUFNvY2tldC5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgc29ja2V0OiBTb2NrZXQ7XG5cbiAgLyoqXG4gICAqIFRoZSBzb2NrZXQgZGV0YWlscyBmb3IgRGlzY29yZCAocmVtb3RlKVxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSByZW1vdGU6IFNvY2tldENvbmZpZztcblxuICAvKipcbiAgICogVGhlIGNvdW50ZXIgdXNlZCBpbiB0aGUga2VlcCBhbGl2ZSBtZWNoYW5pc20uXG4gICAqL1xuICBwcml2YXRlIGtlZXBBbGl2ZUNvdW50ZXIgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgYnVmZmVyIHVzZWQgdG8gd3JpdGUgdGhlIGtlZXAgYWxpdmUgY291bnRlciBpbnRvLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBrZWVwQWxpdmVCdWZmZXI6IEJ1ZmZlcjtcblxuICAvKipcbiAgICogVGhlIE5vZGUuanMgaW50ZXJ2YWwgZm9yIHRoZSBrZWVwLWFsaXZlIG1lY2hhbmlzbS5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkga2VlcEFsaXZlSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0O1xuXG4gIC8qKlxuICAgKiBUaGUgdGltZSB0YWtlbiB0byByZWNlaXZlIGEgcmVzcG9uc2UgdG8ga2VlcCBhbGl2ZSBtZXNzYWdlcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBmaWVsZCBpcyBubyBsb25nZXIgdXBkYXRlZCBhcyBrZWVwIGFsaXZlIG1lc3NhZ2VzIGFyZSBubyBsb25nZXIgdHJhY2tlZC5cbiAgICovXG4gIHB1YmxpYyBwaW5nPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFZvaWNlVURQU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gcmVtb3RlIC0gRGV0YWlscyBvZiB0aGUgcmVtb3RlIHNvY2tldFxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHJlbW90ZTogU29ja2V0Q29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvY2tldCA9IGNyZWF0ZVNvY2tldCgndWRwNCcpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdlcnJvcicsIChlcnJvcjogRXJyb3IpID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcikpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdtZXNzYWdlJywgKGJ1ZmZlcjogQnVmZmVyKSA9PiB0aGlzLm9uTWVzc2FnZShidWZmZXIpKTtcbiAgICB0aGlzLnNvY2tldC5vbignY2xvc2UnLCAoKSA9PiB0aGlzLmVtaXQoJ2Nsb3NlJykpO1xuICAgIHRoaXMucmVtb3RlID0gcmVtb3RlO1xuICAgIHRoaXMua2VlcEFsaXZlQnVmZmVyID0gQnVmZmVyLmFsbG9jKDgpO1xuICAgIHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICgpID0+IHRoaXMua2VlcEFsaXZlKCksXG4gICAgICBLRUVQX0FMSVZFX0lOVEVSVkFMXG4gICAgKTtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5rZWVwQWxpdmUoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkIG9uIHRoZSBVRFAgc29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gVGhlIHJlY2VpdmVkIGJ1ZmZlclxuICAgKi9cbiAgcHJpdmF0ZSBvbk1lc3NhZ2UoYnVmZmVyOiBCdWZmZXIpOiB2b2lkIHtcbiAgICAvLyBQcm9wYWdhdGUgdGhlIG1lc3NhZ2VcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWZmZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBhdCBhIHJlZ3VsYXIgaW50ZXJ2YWwgdG8gY2hlY2sgd2hldGhlciB3ZSBhcmUgc3RpbGwgYWJsZSB0byBzZW5kIGRhdGFncmFtcyB0byBEaXNjb3JkLlxuICAgKi9cbiAgcHJpdmF0ZSBrZWVwQWxpdmUoKSB7XG4gICAgdGhpcy5rZWVwQWxpdmVCdWZmZXIud3JpdGVVSW50MzJMRSh0aGlzLmtlZXBBbGl2ZUNvdW50ZXIsIDApO1xuICAgIHRoaXMuc2VuZCh0aGlzLmtlZXBBbGl2ZUJ1ZmZlcik7XG4gICAgdGhpcy5rZWVwQWxpdmVDb3VudGVyKys7XG4gICAgaWYgKHRoaXMua2VlcEFsaXZlQ291bnRlciA+IE1BWF9DT1VOVEVSX1ZBTFVFKSB7XG4gICAgICB0aGlzLmtlZXBBbGl2ZUNvdW50ZXIgPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGJ1ZmZlciB0byBEaXNjb3JkLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB0byBzZW5kXG4gICAqL1xuICBwdWJsaWMgc2VuZChidWZmZXI6IEJ1ZmZlcikge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnNvY2tldC5zZW5kKGJ1ZmZlciwgdGhpcy5yZW1vdGUucG9ydCwgdGhpcy5yZW1vdGUuaXApO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgc29ja2V0LCB0aGUgaW5zdGFuY2Ugd2lsbCBub3QgYmUgYWJsZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICB9IGNhdGNoIHtcblxuICAgICAgLy9cbiAgICB9XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBBbGl2ZUludGVydmFsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBJUCBkaXNjb3ZlcnkgdG8gZGlzY292ZXIgdGhlIGxvY2FsIGFkZHJlc3MgYW5kIHBvcnQgdG8gYmUgdXNlZCBmb3IgdGhlIHZvaWNlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBzc3JjIC0gVGhlIFNTUkMgcmVjZWl2ZWQgZnJvbSBEaXNjb3JkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcGVyZm9ybUlQRGlzY292ZXJ5KHNzcmM6IG51bWJlcik6IFByb21pc2U8U29ja2V0Q29uZmlnPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gKG1lc3NhZ2U6IEJ1ZmZlcikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChtZXNzYWdlLnJlYWRVSW50MTZCRSgwKSAhPT0gMikgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHBhcnNlTG9jYWxQYWNrZXQobWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5zb2NrZXQub2ZmKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgIHJlc29sdmUocGFja2V0KTtcbiAgICAgICAgfSBjYXRjaCB7XG5cbiAgICAgICAgICAvL1xuICAgICAgICB9fTtcblxuICAgICAgdGhpcy5zb2NrZXQub24oJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgICB0aGlzLnNvY2tldC5vbmNlKCdjbG9zZScsICgpID0+XG4gICAgICByZWplY3QobmV3IEVycm9yKCdDYW5ub3QgcGVyZm9ybSBJUCBkaXNjb3ZlcnkgLSBzb2NrZXQgY2xvc2VkJykpXG4gICAgICApO1xuXG4gICAgICBjb25zdCBkaXNjb3ZlcnlCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNzQpO1xuXG4gICAgICBkaXNjb3ZlcnlCdWZmZXIud3JpdGVVSW50MTZCRSgxLCAwKTtcbiAgICAgIGRpc2NvdmVyeUJ1ZmZlci53cml0ZVVJbnQxNkJFKDcwLCAyKTtcbiAgICAgIGRpc2NvdmVyeUJ1ZmZlci53cml0ZVVJbnQzMkJFKHNzcmMsIDQpO1xuICAgICAgdGhpcy5zZW5kKGRpc2NvdmVyeUJ1ZmZlcik7XG4gICAgfSk7XG4gIH1cbn0iLCAiLy8gQ29weXJpZ2h0IGRpc2NvcmQtcGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBMaWNlbnNlLlxuLy8gQ29weXJpZ2h0IGRpc2NvcmQuanMgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gQXBhY2hlIExpY2Vuc2UgMi4wXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZGVjbGFyYXRpb24tbWVyZ2luZyAqL1xuXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdub2RlOmV2ZW50cyc7XG5pbXBvcnQgeyBWb2ljZU9wY29kZXMgfSBmcm9tICdkaXNjb3JkLWFwaS10eXBlcy92b2ljZS92NCc7XG5pbXBvcnQgeyBXZWJTb2NrZXQgfSBmcm9tICd3cyc7XG5pbXBvcnQgeyB1bnNhZmUgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZvaWNlV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgb24oZXZlbnQ6ICdlcnJvcicsIGxpc3RlbmVyOiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkKTogdGhpcztcbiAgb24oZXZlbnQ6ICdvcGVuJywgbGlzdGVuZXI6IChldmVudDogRXZlbnQpID0+IHZvaWQpOiB0aGlzO1xuICBvbihldmVudDogJ2Nsb3NlJywgbGlzdGVuZXI6IChldmVudDogQ2xvc2VFdmVudCkgPT4gdm9pZCk6IHRoaXM7XG4gIC8qKlxuICAgKiBEZWJ1ZyBldmVudCBmb3IgVm9pY2VXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBldmVudFByb3BlcnR5XG4gICAqL1xuICBvbihldmVudDogJ2RlYnVnJywgbGlzdGVuZXI6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpOiB0aGlzO1xuICAvKipcbiAgICogUGFja2V0IGV2ZW50LlxuICAgKlxuICAgKiBAZXZlbnRQcm9wZXJ0eVxuICAgKi9cbiAgb24oZXZlbnQ6ICdwYWNrZXQnLCBsaXN0ZW5lcjogKHBhY2tldDogdW5zYWZlKSA9PiB2b2lkKTogdGhpcztcbn1cblxuLyoqXG4gKiBBbiBleHRlbnNpb24gb2YgdGhlIFdlYlNvY2tldCBjbGFzcyB0byBwcm92aWRlIGhlbHBlciBmdW5jdGlvbmFsaXR5IHdoZW4gaW50ZXJhY3RpbmdcbiAqIHdpdGggdGhlIERpc2NvcmQgVm9pY2UgZ2F0ZXdheS5cbiAqL1xuZXhwb3J0IGNsYXNzIFZvaWNlV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGhlYXJ0YmVhdCBpbnRlcnZhbCwgaWYgYW55LlxuICAgKi9cbiAgcHJpdmF0ZSBoZWFydGJlYXRJbnRlcnZhbD86IE5vZGVKUy5UaW1lb3V0O1xuXG4gIC8qKlxuICAgKiBUaGUgdGltZSAobWlsbGlzZWNvbmRzIHNpbmNlIFVOSVggZXBvY2gpIHRoYXQgdGhlIGxhc3QgaGVhcnRiZWF0IGFja25vd2xlZGdlbWVudCBwYWNrZXQgd2FzIHJlY2VpdmVkLlxuICAgKiBUaGlzIGlzIHNldCB0byAwIGlmIGFuIGFja25vd2xlZGdlbWVudCBwYWNrZXQgaGFzbid0IGJlZW4gcmVjZWl2ZWQgeWV0LlxuICAgKi9cbiAgcHJpdmF0ZSBsYXN0SGVhcnRiZWF0QWNrOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIChtaWxsaXNlY29uZHMgc2luY2UgVU5JWCBlcG9jaCkgdGhhdCB0aGUgbGFzdCBoZWFydGJlYXQgd2FzIHNlbnQuIFRoaXMgaXMgc2V0IHRvIDAgaWYgYSBoZWFydGJlYXRcbiAgICogaGFzbid0IGJlZW4gc2VudCB5ZXQuXG4gICAqL1xuICBwcml2YXRlIGxhc3RIZWFydGJlYXRTZW5kOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgY29uc2VjdXRpdmVseSBtaXNzZWQgaGVhcnRiZWF0cy5cbiAgICovXG4gIHByaXZhdGUgbWlzc2VkSGVhcnRiZWF0cyA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBsYXN0IHJlY29yZGVkIHBpbmcuXG4gICAqL1xuICBwdWJsaWMgcGluZz86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGRlYnVnIGxvZ2dlciBmdW5jdGlvbiwgaWYgZGVidWdnaW5nIGlzIGVuYWJsZWQuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGRlYnVnOiAoKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCkgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5kZXJseWluZyBXZWJTb2NrZXQgb2YgdGhpcyB3cmFwcGVyLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSB3czogV2ViU29ja2V0O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFZvaWNlV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIGNvbm5lY3QgdG9cbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihhZGRyZXNzOiBzdHJpbmcsIGRlYnVnOiBib29sZWFuKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldChhZGRyZXNzKTtcbiAgICB0aGlzLndzLm9ubWVzc2FnZSA9IChlcnIpID0+IHRoaXMub25NZXNzYWdlKGVyciBhcyB1bmtub3duIGFzIE1lc3NhZ2VFdmVudCk7XG4gICAgdGhpcy53cy5vbm9wZW4gPSAoZXJyKSA9PiB0aGlzLmVtaXQoJ29wZW4nLCBlcnIpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLndzLm9uZXJyb3IgPSAoZXJyOiBFcnJvciB8IEVycm9yRXZlbnQpID0+XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogZXJyLmVycm9yKTtcbiAgICB0aGlzLndzLm9uY2xvc2UgPSAoZXJyKSA9PiB0aGlzLmVtaXQoJ2Nsb3NlJywgZXJyKTtcblxuICAgIHRoaXMubGFzdEhlYXJ0YmVhdEFjayA9IDA7XG4gICAgdGhpcy5sYXN0SGVhcnRiZWF0U2VuZCA9IDA7XG5cbiAgICB0aGlzLmRlYnVnID0gZGVidWcgP1xuICAgIChtZXNzYWdlOiBzdHJpbmcpID0+IHRoaXMuZW1pdCgnZGVidWcnLCBtZXNzYWdlKSA6XG4gICAgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgVm9pY2VXZWJTb2NrZXQuIFRoZSBoZWFydGJlYXQgaW50ZXJ2YWwgaXMgY2xlYXJlZCwgYW5kIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmRlYnVnPy4oJ2Rlc3Ryb3llZCcpO1xuICAgICAgdGhpcy5zZXRIZWFydGJlYXRJbnRlcnZhbCgtMSk7XG4gICAgICB0aGlzLndzLmNsb3NlKDFfMDAwKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyID0gZXJyb3IgYXMgRXJyb3I7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBtZXNzYWdlIGV2ZW50cyBvbiB0aGUgV2ViU29ja2V0LiBBdHRlbXB0cyB0byBKU09OIHBhcnNlIHRoZSBtZXNzYWdlcyBhbmQgZW1pdCB0aGVtXG4gICAqIGFzIHBhY2tldHMuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBtZXNzYWdlIGV2ZW50XG4gICAqL1xuICBwdWJsaWMgb25NZXNzYWdlKGV2ZW50OiBNZXNzYWdlRXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgIT09ICdzdHJpbmcnKSByZXR1cm47XG5cbiAgICB0aGlzLmRlYnVnPy4oYDw8ICR7ZXZlbnQuZGF0YX1gKTtcblxuICAgIGxldCBwYWNrZXQ6IHVuc2FmZTtcbiAgICB0cnkge1xuICAgICAgcGFja2V0ID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyID0gZXJyb3IgYXMgRXJyb3I7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGFja2V0Lm9wID09PSBWb2ljZU9wY29kZXMuSGVhcnRiZWF0QWNrKSB7XG4gICAgICB0aGlzLmxhc3RIZWFydGJlYXRBY2sgPSBEYXRlLm5vdygpO1xuICAgICAgdGhpcy5taXNzZWRIZWFydGJlYXRzID0gMDtcbiAgICAgIHRoaXMucGluZyA9IHRoaXMubGFzdEhlYXJ0YmVhdEFjayAtIHRoaXMubGFzdEhlYXJ0YmVhdFNlbmQ7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgSlNPTi1zdHJpbmdpZmlhYmxlIHBhY2tldCBvdmVyIHRoZSBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBwYWNrZXQgLSBUaGUgcGFja2V0IHRvIHNlbmRcbiAgICovXG4gIHB1YmxpYyBzZW5kUGFja2V0KHBhY2tldDogdW5zYWZlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0cmluZ2lmaWVkID0gSlNPTi5zdHJpbmdpZnkocGFja2V0KTtcbiAgICAgIHRoaXMuZGVidWc/LihgPj4gJHtzdHJpbmdpZmllZH1gKTtcbiAgICAgIHRoaXMud3Muc2VuZChzdHJpbmdpZmllZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVyciA9IGVycm9yIGFzIEVycm9yO1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgaGVhcnRiZWF0IG92ZXIgdGhlIFdlYlNvY2tldC5cbiAgICovXG4gIHByaXZhdGUgc2VuZEhlYXJ0YmVhdCgpIHtcbiAgICB0aGlzLmxhc3RIZWFydGJlYXRTZW5kID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLm1pc3NlZEhlYXJ0YmVhdHMrKztcbiAgICBjb25zdCBub25jZSA9IHRoaXMubGFzdEhlYXJ0YmVhdFNlbmQ7XG4gICAgdGhpcy5zZW5kUGFja2V0KHtcbiAgICAgIG9wOiBWb2ljZU9wY29kZXMuSGVhcnRiZWF0LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGlkLWxlbmd0aFxuICAgICAgZDogbm9uY2VcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzL2NsZWFycyBhbiBpbnRlcnZhbCB0byBzZW5kIGhlYXJ0YmVhdHMgb3ZlciB0aGUgV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gbXMgLSBUaGUgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLiBJZiBuZWdhdGl2ZSwgdGhlIGludGVydmFsIHdpbGwgYmUgdW5zZXRcbiAgICovXG4gIHB1YmxpYyBzZXRIZWFydGJlYXRJbnRlcnZhbChtczogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwgIT09IHVuZGVmaW5lZClcbiAgICBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwpO1xuICAgIGlmIChtcyA+IDApIHtcbiAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RIZWFydGJlYXRTZW5kICE9PSAwICYmIHRoaXMubWlzc2VkSGVhcnRiZWF0cyA+PSAzKSB7XG4gICAgICAgICAgLy8gTWlzc2VkIHRvbyBtYW55IGhlYXJ0YmVhdHMgLSBkaXNjb25uZWN0XG4gICAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMuc2V0SGVhcnRiZWF0SW50ZXJ2YWwoLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZW5kSGVhcnRiZWF0KCk7XG4gICAgICB9LCBtcyk7XG4gICAgfVxuICB9XG59IiwgIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG5pbXBvcnQgdHlwZSB7IEpvaW5Db25maWcgfSBmcm9tICcuL0RhdGFTdG9yZSc7XG5pbXBvcnQgeyBjcmVhdGVWb2ljZUNvbm5lY3Rpb24gfSBmcm9tICcuL1ZvaWNlQ29ubmVjdGlvbic7XG5pbXBvcnQgdHlwZSB7IERpc2NvcmRHYXRld2F5QWRhcHRlckNyZWF0b3IgfSBmcm9tICcuL3V0aWwvYWRhcHRlcic7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgdGhhdCBjYW4gYmUgZ2l2ZW4gd2hlbiBjcmVhdGluZyBhIHZvaWNlIGNvbm5lY3Rpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlVm9pY2VDb25uZWN0aW9uT3B0aW9ucyB7XG4gIGFkYXB0ZXJDcmVhdG9yOiBEaXNjb3JkR2F0ZXdheUFkYXB0ZXJDcmVhdG9yO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBkZWJ1ZyBtZXNzYWdlcyB3aWxsIGJlIGVuYWJsZWQgZm9yIHRoZSB2b2ljZSBjb25uZWN0aW9uIGFuZCBpdHNcbiAgICogcmVsYXRlZCBjb21wb25lbnRzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICovXG4gIGRlYnVnPzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGUgb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB3aGVuIGpvaW5pbmcgYSB2b2ljZSBjaGFubmVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEpvaW5Wb2ljZUNoYW5uZWxPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBpZCBvZiB0aGUgRGlzY29yZCB2b2ljZSBjaGFubmVsIHRvIGpvaW4uXG4gICAqL1xuICBjaGFubmVsSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgZ3JvdXAgaWRlbnRpZmllciBmb3IgdGhlIHZvaWNlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBncm91cD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBndWlsZCB0aGF0IHRoZSB2b2ljZSBjaGFubmVsIGJlbG9uZ3MgdG8uXG4gICAqL1xuICBndWlsZElkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gam9pbiB0aGUgY2hhbm5lbCBkZWFmZW5lZCAoZGVmYXVsdHMgdG8gdHJ1ZSlcbiAgICovXG4gIHNlbGZEZWFmPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBqb2luIHRoZSBjaGFubmVsIG11dGVkIChkZWZhdWx0cyB0byB0cnVlKVxuICAgKi9cbiAgc2VsZk11dGU/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBWb2ljZUNvbm5lY3Rpb24gdG8gYSBEaXNjb3JkIHZvaWNlIGNoYW5uZWwuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSB0aGUgb3B0aW9ucyBmb3Igam9pbmluZyB0aGUgdm9pY2UgY2hhbm5lbFxuICovXG5leHBvcnQgZnVuY3Rpb24gam9pblZvaWNlQ2hhbm5lbChcbm9wdGlvbnM6IENyZWF0ZVZvaWNlQ29ubmVjdGlvbk9wdGlvbnMgJiBKb2luVm9pY2VDaGFubmVsT3B0aW9ucylcbntcbiAgY29uc3Qgam9pbkNvbmZpZzogSm9pbkNvbmZpZyA9IHtcbiAgICBzZWxmRGVhZjogdHJ1ZSxcbiAgICBzZWxmTXV0ZTogZmFsc2UsXG4gICAgZ3JvdXA6ICdkZWZhdWx0JyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG5cbiAgcmV0dXJuIGNyZWF0ZVZvaWNlQ29ubmVjdGlvbihqb2luQ29uZmlnLCB7XG4gICAgYWRhcHRlckNyZWF0b3I6IG9wdGlvbnMuYWRhcHRlckNyZWF0b3IsXG4gICAgZGVidWc6IG9wdGlvbnMuZGVidWdcbiAgfSk7XG59IiwgIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXRzLWV4cGVjdC1lcnJvciwgQHR5cGVzY3JpcHQtZXNsaW50L21ldGhvZC1zaWduYXR1cmUtc3R5bGUgKi9cbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ25vZGU6YnVmZmVyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ25vZGU6ZXZlbnRzJztcbmltcG9ydCB7IGFkZEF1ZGlvUGxheWVyLCBkZWxldGVBdWRpb1BsYXllciB9IGZyb20gJy4uL0RhdGFTdG9yZSc7XG5pbXBvcnQge1xuICBWb2ljZUNvbm5lY3Rpb25TdGF0dXMsXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uIH0gZnJvbVxuJy4uL1ZvaWNlQ29ubmVjdGlvbic7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IEF1ZGlvUGxheWVyRXJyb3IgfSBmcm9tICcuL0F1ZGlvUGxheWVyRXJyb3InO1xuaW1wb3J0IHR5cGUgeyBBdWRpb1Jlc291cmNlIH0gZnJvbSAnLi9BdWRpb1Jlc291cmNlJztcbmltcG9ydCB7IFBsYXllclN1YnNjcmlwdGlvbiB9IGZyb20gJy4vUGxheWVyU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHVuc2FmZSB9IGZyb20gJy4uL2NvbW1vbi90eXBlcyc7XG5cbi8vIFRoZSBPcHVzIFwic2lsZW50XCIgZnJhbWVcbmV4cG9ydCBjb25zdCBTSUxFTkNFX0ZSQU1FID0gQnVmZmVyLmZyb20oWzB4ZjgsIDB4ZmYsIDB4ZmVdKTtcblxuLyoqXG4gKiBEZXNjcmliZXMgdGhlIGJlaGF2aW9yIG9mIHRoZSBwbGF5ZXIgd2hlbiBhbiBhdWRpbyBwYWNrZXQgaXMgcGxheWVkIGJ1dCB0aGVyZSBhcmUgbm8gYXZhaWxhYmxlXG4gKiB2b2ljZSBjb25uZWN0aW9ucyB0byBwbGF5IHRvLlxuICovXG5leHBvcnQgZW51bSBOb1N1YnNjcmliZXJCZWhhdmlvciB7XG4gIC8qKlxuICAgKiBQYXVzZXMgcGxheWluZyB0aGUgc3RyZWFtIHVudGlsIGEgdm9pY2UgY29ubmVjdGlvbiBiZWNvbWVzIGF2YWlsYWJsZS5cbiAgICovXG4gIFBhdXNlID0gJ3BhdXNlJyxcblxuICAvKipcbiAgICogQ29udGludWVzIHRvIHBsYXkgdGhyb3VnaCB0aGUgcmVzb3VyY2UgcmVnYXJkbGVzcy5cbiAgICovXG4gIFBsYXkgPSAncGxheScsXG5cbiAgLyoqXG4gICAqIFRoZSBwbGF5ZXIgc3RvcHMgYW5kIGVudGVycyB0aGUgSWRsZSBzdGF0ZS5cbiAgICovXG4gIFN0b3AgPSAnc3RvcCcsXG59XG5cbmV4cG9ydCBlbnVtIEF1ZGlvUGxheWVyU3RhdHVzIHtcbiAgLyoqXG4gICAqIFdoZW4gdGhlIHBsYXllciBoYXMgcGF1c2VkIGl0c2VsZi4gT25seSBwb3NzaWJsZSB3aXRoIHRoZSBcInBhdXNlXCIgbm8gc3Vic2NyaWJlciBiZWhhdmlvci5cbiAgICovXG4gIEF1dG9QYXVzZWQgPSAnYXV0b3BhdXNlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHBsYXllciBpcyB3YWl0aW5nIGZvciBhbiBhdWRpbyByZXNvdXJjZSB0byBiZWNvbWUgcmVhZGFibGUgYmVmb3JlIHRyYW5zaXRpb25pbmcgdG8gUGxheWluZy5cbiAgICovXG4gIEJ1ZmZlcmluZyA9ICdidWZmZXJpbmcnLFxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZXJlIGlzIGN1cnJlbnRseSBubyByZXNvdXJjZSBmb3IgdGhlIHBsYXllciB0byBiZSBwbGF5aW5nLlxuICAgKi9cbiAgSWRsZSA9ICdpZGxlJyxcblxuICAvKipcbiAgICogV2hlbiB0aGUgcGxheWVyIGhhcyBiZWVuIG1hbnVhbGx5IHBhdXNlZC5cbiAgICovXG4gIFBhdXNlZCA9ICdwYXVzZWQnLFxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwbGF5ZXIgaXMgYWN0aXZlbHkgcGxheWluZyBhbiBhdWRpbyByZXNvdXJjZS5cbiAgICovXG4gIFBsYXlpbmcgPSAncGxheWluZycsXG59XG5cbi8qKlxuICogT3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgd2hlbiBjcmVhdGluZyBhbiBhdWRpbyBwbGF5ZXIsIHVzZWQgdG8gc3BlY2lmeSBpdHMgYmVoYXZpb3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQXVkaW9QbGF5ZXJPcHRpb25zIHtcbiAgYmVoYXZpb3JzPzoge1xuICAgIG1heE1pc3NlZEZyYW1lcz86IG51bWJlcjtcbiAgICBub1N1YnNjcmliZXI/OiBOb1N1YnNjcmliZXJCZWhhdmlvcjtcbiAgfTtcbiAgZGVidWc/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSB0aGF0IGFuIEF1ZGlvUGxheWVyIGlzIGluIHdoZW4gaXQgaGFzIG5vIHJlc291cmNlIHRvIHBsYXkuIFRoaXMgaXMgdGhlIHN0YXJ0aW5nIHN0YXRlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGlvUGxheWVySWRsZVN0YXRlIHtcbiAgc3RhdHVzOiBBdWRpb1BsYXllclN0YXR1cy5JZGxlO1xufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSB0aGF0IGFuIEF1ZGlvUGxheWVyIGlzIGluIHdoZW4gaXQgaXMgd2FpdGluZyBmb3IgYSByZXNvdXJjZSB0byBiZWNvbWUgcmVhZGFibGUuIE9uY2UgdGhpc1xuICogaGFwcGVucywgdGhlIEF1ZGlvUGxheWVyIHdpbGwgZW50ZXIgdGhlIFBsYXlpbmcgc3RhdGUuIElmIHRoZSByZXNvdXJjZSBlbmRzL2Vycm9ycyBiZWZvcmUgdGhpcywgdGhlblxuICogaXQgd2lsbCByZS1lbnRlciB0aGUgSWRsZSBzdGF0ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdWRpb1BsYXllckJ1ZmZlcmluZ1N0YXRlIHtcbiAgb25GYWlsdXJlQ2FsbGJhY2s6ICgpID0+IHZvaWQ7XG4gIG9uUmVhZGFibGVDYWxsYmFjazogKCkgPT4gdm9pZDtcbiAgb25TdHJlYW1FcnJvcjogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbiAgLyoqXG4gICAqIFRoZSByZXNvdXJjZSB0aGF0IHRoZSBBdWRpb1BsYXllciBpcyB3YWl0aW5nIGZvclxuICAgKi9cbiAgcmVzb3VyY2U6IEF1ZGlvUmVzb3VyY2U7XG4gIHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuQnVmZmVyaW5nO1xufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSB0aGF0IGFuIEF1ZGlvUGxheWVyIGlzIGluIHdoZW4gaXQgaXMgYWN0aXZlbHkgcGxheWluZyBhbiBBdWRpb1Jlc291cmNlLiBXaGVuIHBsYXliYWNrIGVuZHMsXG4gKiBpdCB3aWxsIGVudGVyIHRoZSBJZGxlIHN0YXRlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGlvUGxheWVyUGxheWluZ1N0YXRlIHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgY29uc2VjdXRpdmUgdGltZXMgdGhhdCB0aGUgYXVkaW8gcmVzb3VyY2UgaGFzIGJlZW4gdW5hYmxlIHRvIHByb3ZpZGUgYW4gT3B1cyBmcmFtZS5cbiAgICovXG4gIG1pc3NlZEZyYW1lczogbnVtYmVyO1xuICBvblN0cmVhbUVycm9yOiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgcGxheWJhY2sgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIG9mIHRoZSBjdXJyZW50IGF1ZGlvIHJlc291cmNlLiBUaGlzIGluY2x1ZGVzIGZpbGxlciBzaWxlbmNlIHBhY2tldHNcbiAgICogdGhhdCBoYXZlIGJlZW4gcGxheWVkIHdoZW4gdGhlIHJlc291cmNlIHdhcyBidWZmZXJpbmcuXG4gICAqL1xuICBwbGF5YmFja0R1cmF0aW9uOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSByZXNvdXJjZSB0aGF0IGlzIGJlaW5nIHBsYXllZC5cbiAgICovXG4gIHJlc291cmNlOiBBdWRpb1Jlc291cmNlO1xuXG4gIHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuUGxheWluZztcbn1cblxuLyoqXG4gKiBUaGUgc3RhdGUgdGhhdCBhbiBBdWRpb1BsYXllciBpcyBpbiB3aGVuIGl0IGhhcyBlaXRoZXIgYmVlbiBleHBsaWNpdGx5IHBhdXNlZCBieSB0aGUgdXNlciwgb3IgZG9uZVxuICogYXV0b21hdGljYWxseSBieSB0aGUgQXVkaW9QbGF5ZXIgaXRzZWxmIGlmIHRoZXJlIGFyZSBubyBhdmFpbGFibGUgc3Vic2NyaWJlcnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9QbGF5ZXJQYXVzZWRTdGF0ZSB7XG4gIG9uU3RyZWFtRXJyb3I6IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBUaGUgcGxheWJhY2sgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIG9mIHRoZSBjdXJyZW50IGF1ZGlvIHJlc291cmNlLiBUaGlzIGluY2x1ZGVzIGZpbGxlciBzaWxlbmNlIHBhY2tldHNcbiAgICogdGhhdCBoYXZlIGJlZW4gcGxheWVkIHdoZW4gdGhlIHJlc291cmNlIHdhcyBidWZmZXJpbmcuXG4gICAqL1xuICBwbGF5YmFja0R1cmF0aW9uOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHJlc291cmNlIG9mIHRoZSBhdWRpbyBwbGF5ZXIuXG4gICAqL1xuICByZXNvdXJjZTogQXVkaW9SZXNvdXJjZTtcblxuICAvKipcbiAgICogSG93IG1hbnkgc2lsZW5jZSBwYWNrZXRzIHN0aWxsIG5lZWQgdG8gYmUgcGxheWVkIHRvIGF2b2lkIGF1ZGlvIGludGVycG9sYXRpb24gZHVlIHRvIHRoZSBzdHJlYW0gc3VkZGVubHkgcGF1c2luZy5cbiAgICovXG4gIHNpbGVuY2VQYWNrZXRzUmVtYWluaW5nOiBudW1iZXI7XG5cbiAgc3RhdHVzOiBBdWRpb1BsYXllclN0YXR1cy5BdXRvUGF1c2VkIHwgQXVkaW9QbGF5ZXJTdGF0dXMuUGF1c2VkO1xufVxuXG4vKipcbiAqIFRoZSB2YXJpb3VzIHN0YXRlcyB0aGF0IHRoZSBwbGF5ZXIgY2FuIGJlIGluLlxuICovXG5leHBvcnQgdHlwZSBBdWRpb1BsYXllclN0YXRlID1cbkF1ZGlvUGxheWVyQnVmZmVyaW5nU3RhdGUgfFxuQXVkaW9QbGF5ZXJJZGxlU3RhdGUgfFxuQXVkaW9QbGF5ZXJQYXVzZWRTdGF0ZSB8XG5BdWRpb1BsYXllclBsYXlpbmdTdGF0ZTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZGVjbGFyYXRpb24tbWVyZ2luZ1xuZXhwb3J0IGludGVyZmFjZSBBdWRpb1BsYXllciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgZW1pdHRlZCBmcm9tIHRoZSBhdWRpbyByZXNvdXJjZSBwbGF5ZWQgYnkgdGhlIGF1ZGlvIHBsYXllclxuICAgKlxuICAgKiBAZXZlbnRQcm9wZXJ0eVxuICAgKi9cbiAgb24oZXZlbnQ6ICdlcnJvcicsIGxpc3RlbmVyOiAoZXJyb3I6IEF1ZGlvUGxheWVyRXJyb3IpID0+IHZvaWQpOiB0aGlzO1xuICAvKipcbiAgICogRW1pdHRlZCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGF1ZGlvIHBsYXllclxuICAgKlxuICAgKiBAZXZlbnRQcm9wZXJ0eVxuICAgKi9cbiAgb24oZXZlbnQ6ICdkZWJ1ZycsIGxpc3RlbmVyOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKTogdGhpcztcbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIGF1ZGlvIHBsYXllciBjaGFuZ2VzXG4gICAqXG4gICAqIEBldmVudFByb3BlcnR5XG4gICAqL1xuICBvbihcbiAgZXZlbnQ6ICdzdGF0ZUNoYW5nZScsXG4gIGxpc3RlbmVyOiAob2xkU3RhdGU6IEF1ZGlvUGxheWVyU3RhdGUsIG5ld1N0YXRlOiBBdWRpb1BsYXllclN0YXRlKSA9PiB2b2lkKVxuICA6IHRoaXM7XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIGF1ZGlvIHBsYXllciBpcyBzdWJzY3JpYmVkIHRvIGEgdm9pY2UgY29ubmVjdGlvblxuICAgKlxuICAgKiBAZXZlbnRQcm9wZXJ0eVxuICAgKi9cbiAgb24oXG4gIGV2ZW50OiAnc3Vic2NyaWJlJyB8ICd1bnN1YnNjcmliZScsXG4gIGxpc3RlbmVyOiAoc3Vic2NyaXB0aW9uOiBQbGF5ZXJTdWJzY3JpcHRpb24pID0+IHZvaWQpXG4gIDogdGhpcztcbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgc3RhdHVzIG9mIHN0YXRlIGNoYW5nZXMgdG8gYSBzcGVjaWZpYyBzdGF0dXNcbiAgICpcbiAgICogQGV2ZW50UHJvcGVydHlcbiAgICovXG4gIG9uPEV2ZW50IGV4dGVuZHMgQXVkaW9QbGF5ZXJTdGF0dXM+KFxuICBldmVudDogRXZlbnQsXG4gIGxpc3RlbmVyOiAoXG4gIG9sZFN0YXRlOiBBdWRpb1BsYXllclN0YXRlLFxuICBuZXdTdGF0ZTogQXVkaW9QbGF5ZXJTdGF0ZSAmIHtzdGF0dXM6IEV2ZW50O30pXG4gID0+IHZvaWQpXG4gIDogdGhpcztcbn1cblxuLyoqXG4gKiBTdHJpbmdpZmllcyBhbiBBdWRpb1BsYXllclN0YXRlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBzdHJpbmdpZnlcbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5U3RhdGUoc3RhdGU6IEF1ZGlvUGxheWVyU3RhdGUpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAuLi5zdGF0ZSxcbiAgICByZXNvdXJjZTogUmVmbGVjdC5oYXMoc3RhdGUsICdyZXNvdXJjZScpLFxuICAgIHN0ZXBUaW1lb3V0OiBSZWZsZWN0LmhhcyhzdGF0ZSwgJ3N0ZXBUaW1lb3V0JylcbiAgfSk7XG59XG5cbi8qKlxuICogVXNlZCB0byBwbGF5IGF1ZGlvIHJlc291cmNlcyAoaS5lLiB0cmFja3MsIHN0cmVhbXMpIHRvIHZvaWNlIGNvbm5lY3Rpb25zLlxuICpcbiAqIEByZW1hcmtzXG4gKiBBdWRpbyBwbGF5ZXJzIGFyZSBkZXNpZ25lZCB0byBiZSByZS11c2VkIC0gZXZlbiBpZiBhIHJlc291cmNlIGhhcyBmaW5pc2hlZCBwbGF5aW5nLCB0aGUgcGxheWVyIGl0c2VsZlxuICogY2FuIHN0aWxsIGJlIHVzZWQuXG4gKlxuICogVGhlIEF1ZGlvUGxheWVyIGRyaXZlcyB0aGUgdGltaW5nIG9mIHBsYXliYWNrLCBhbmQgdGhlcmVmb3JlIGlzIHVuYWZmZWN0ZWQgYnkgdm9pY2UgY29ubmVjdGlvbnNcbiAqIGJlY29taW5nIHVuYXZhaWxhYmxlLiBJdHMgYmVoYXZpb3IgaW4gdGhlc2Ugc2NlbmFyaW9zIGNhbiBiZSBjb25maWd1cmVkLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1kZWNsYXJhdGlvbi1tZXJnaW5nXG5leHBvcnQgY2xhc3MgQXVkaW9QbGF5ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogVGhlIHN0YXRlIHRoYXQgdGhlIEF1ZGlvUGxheWVyIGlzIGluLlxuICAgKi9cbiAgcHJpdmF0ZSBfc3RhdGU6IEF1ZGlvUGxheWVyU3RhdGU7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBWb2ljZUNvbm5lY3Rpb25zIHRoYXQgYXJlIHJlZ2lzdGVyZWQgdG8gdGhpcyBBdWRpb1BsYXllci4gVGhlIHBsYXllciB3aWxsIGF0dGVtcHQgdG8gcGxheSBhdWRpb1xuICAgKiB0byB0aGUgc3RyZWFtcyBpbiB0aGlzIGxpc3QuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHN1YnNjcmliZXJzOiBQbGF5ZXJTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgYmVoYXZpb3IgdGhhdCB0aGUgcGxheWVyIHNob3VsZCBmb2xsb3cgd2hlbiBpdCBlbnRlcnMgY2VydGFpbiBzaXR1YXRpb25zLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBiZWhhdmlvcnM6IHtcbiAgICBtYXhNaXNzZWRGcmFtZXM6IG51bWJlcjtcbiAgICBub1N1YnNjcmliZXI6IE5vU3Vic2NyaWJlckJlaGF2aW9yO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZGVidWcgbG9nZ2VyIGZ1bmN0aW9uLCBpZiBkZWJ1Z2dpbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgZGVidWc6ICgobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQXVkaW9QbGF5ZXIuXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Iob3B0aW9uczogQ3JlYXRlQXVkaW9QbGF5ZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3N0YXRlID0geyBzdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLklkbGUgfTtcbiAgICB0aGlzLmJlaGF2aW9ycyA9IHtcbiAgICAgIG5vU3Vic2NyaWJlcjogTm9TdWJzY3JpYmVyQmVoYXZpb3IuUGF1c2UsXG4gICAgICBtYXhNaXNzZWRGcmFtZXM6IDUsXG4gICAgICAuLi5vcHRpb25zLmJlaGF2aW9yc1xuICAgIH07XG4gICAgdGhpcy5kZWJ1ZyA9XG4gICAgb3B0aW9ucy5kZWJ1ZyA9PT0gZmFsc2UgP1xuICAgIG51bGwgOlxuICAgIChtZXNzYWdlOiBzdHJpbmcpID0+IHRoaXMuZW1pdCgnZGVidWcnLCBtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2Ygc3Vic2NyaWJlZCB2b2ljZSBjb25uZWN0aW9ucyB0aGF0IGNhbiBjdXJyZW50bHkgcmVjZWl2ZSBhdWRpbyB0byBwbGF5LlxuICAgKi9cbiAgcHVibGljIGdldCBwbGF5YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVycy5cbiAgICBmaWx0ZXIoXG4gICAgICAoeyBjb25uZWN0aW9uIH0pID0+XG4gICAgICBjb25uZWN0aW9uLnN0YXRlLnN0YXR1cyA9PT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLlJlYWR5XG4gICAgKS5cbiAgICBtYXAoKHsgY29ubmVjdGlvbiB9KSA9PiBjb25uZWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIGEgVm9pY2VDb25uZWN0aW9uIHRvIHRoZSBhdWRpbyBwbGF5ZXIncyBwbGF5IGxpc3QuIElmIHRoZSBWb2ljZUNvbm5lY3Rpb24gaXMgYWxyZWFkeSBzdWJzY3JpYmVkLFxuICAgKiB0aGVuIHRoZSBleGlzdGluZyBzdWJzY3JpcHRpb24gaXMgdXNlZC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSBkaXJlY3RseSBjYWxsZWQuIEluc3RlYWQsIHVzZSBWb2ljZUNvbm5lY3Rpb24jc3Vic2NyaWJlLlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiAtIFRoZSBjb25uZWN0aW9uIHRvIHN1YnNjcmliZVxuICAgKiBAcmV0dXJucyBUaGUgbmV3IHN1YnNjcmlwdGlvbiBpZiB0aGUgdm9pY2UgY29ubmVjdGlvbiBpcyBub3QgeWV0IHN1YnNjcmliZWQsIG90aGVyd2lzZSB0aGUgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uXG4gICAqL1xuICAvLyBAdHMtaWdub3JlXG4gIHByaXZhdGUgc3Vic2NyaWJlKGNvbm5lY3Rpb246IFZvaWNlQ29ubmVjdGlvbikge1xuICAgIGNvbnN0IGV4aXN0aW5nU3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpYmVycy5maW5kKFxuICAgICAgKHN1YnNjcmlwdGlvbikgPT4gc3Vic2NyaXB0aW9uLmNvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb25cbiAgICApO1xuICAgIGlmICghZXhpc3RpbmdTdWJzY3JpcHRpb24pIHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG5ldyBQbGF5ZXJTdWJzY3JpcHRpb24oY29ubmVjdGlvbiwgdGhpcyk7XG4gICAgICB0aGlzLnN1YnNjcmliZXJzLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmVtaXQoJ3N1YnNjcmliZScsIHN1YnNjcmlwdGlvbikpO1xuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhpc3RpbmdTdWJzY3JpcHRpb247XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGEgc3Vic2NyaXB0aW9uIC0gaS5lLiByZW1vdmVzIGEgdm9pY2UgY29ubmVjdGlvbiBmcm9tIHRoZSBwbGF5IGxpc3Qgb2YgdGhlIGF1ZGlvIHBsYXllci5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSBkaXJlY3RseSBjYWxsZWQuIEluc3RlYWQsIHVzZSBQbGF5ZXJTdWJzY3JpcHRpb24jdW5zdWJzY3JpYmUuXG4gICAqIEBwYXJhbSBzdWJzY3JpcHRpb24gLSBUaGUgc3Vic2NyaXB0aW9uIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCB0aGUgc3Vic2NyaXB0aW9uIGV4aXN0ZWQgb24gdGhlIHBsYXllciBhbmQgd2FzIHJlbW92ZWRcbiAgICovXG4gIC8vIEB0cy1pZ25vcmVcbiAgcHJpdmF0ZSB1bnN1YnNjcmliZShzdWJzY3JpcHRpb246IFBsYXllclN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdWJzY3JpYmVycy5pbmRleE9mKHN1YnNjcmlwdGlvbik7XG4gICAgY29uc3QgZXhpc3RzID0gaW5kZXggIT09IC0xO1xuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5jb25uZWN0aW9uLnNldFNwZWFraW5nKGZhbHNlKTtcbiAgICAgIHRoaXMuZW1pdCgndW5zdWJzY3JpYmUnLCBzdWJzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBleGlzdHM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YXRlIHRoYXQgdGhlIHBsYXllciBpcyBpbi5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBuZXcgc3RhdGUgZm9yIHRoZSBwbGF5ZXIsIHBlcmZvcm1pbmcgY2xlYW4tdXAgb3BlcmF0aW9ucyB3aGVyZSBuZWNlc3NhcnkuXG4gICAqL1xuICBwdWJsaWMgc2V0IHN0YXRlKG5ld1N0YXRlOiBBdWRpb1BsYXllclN0YXRlKSB7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBjb25zdCBuZXdSZXNvdXJjZSA9IFJlZmxlY3QuZ2V0KG5ld1N0YXRlLCAncmVzb3VyY2UnKSBhc1xuICAgIEF1ZGlvUmVzb3VyY2UgfFxuICAgIHVuZGVmaW5lZDtcblxuICAgIGlmIChcbiAgICBvbGRTdGF0ZS5zdGF0dXMgIT09IEF1ZGlvUGxheWVyU3RhdHVzLklkbGUgJiZcbiAgICBvbGRTdGF0ZS5yZXNvdXJjZSAhPT0gbmV3UmVzb3VyY2UpXG4gICAge1xuICAgICAgb2xkU3RhdGUucmVzb3VyY2UucGxheVN0cmVhbS5vbignZXJyb3InLCBub29wKTtcbiAgICAgIG9sZFN0YXRlLnJlc291cmNlLnBsYXlTdHJlYW0ub2ZmKCdlcnJvcicsIG9sZFN0YXRlLm9uU3RyZWFtRXJyb3IpO1xuICAgICAgb2xkU3RhdGUucmVzb3VyY2UuYXVkaW9QbGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgICBvbGRTdGF0ZS5yZXNvdXJjZS5wbGF5U3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIG9sZFN0YXRlLnJlc291cmNlLnBsYXlTdHJlYW0ucmVhZCgpOyAvLyByZXF1aXJlZCB0byBlbnN1cmUgYnVmZmVyZWQgZGF0YSBpcyBkcmFpbmVkLCBwcmV2ZW50cyBtZW1vcnkgbGVha1xuICAgIH1cblxuICAgIC8vIFdoZW4gbGVhdmluZyB0aGUgQnVmZmVyaW5nIHN0YXRlIChvciBidWZmZXJpbmcgYSBuZXcgcmVzb3VyY2UpLCB0aGVuIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gaXRcbiAgICBpZiAoXG4gICAgb2xkU3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5CdWZmZXJpbmcgJiYgKFxuICAgIG5ld1N0YXRlLnN0YXR1cyAhPT0gQXVkaW9QbGF5ZXJTdGF0dXMuQnVmZmVyaW5nIHx8XG4gICAgbmV3U3RhdGUucmVzb3VyY2UgIT09IG9sZFN0YXRlLnJlc291cmNlKSlcbiAgICB7XG4gICAgICBvbGRTdGF0ZS5yZXNvdXJjZS5wbGF5U3RyZWFtLm9mZignZW5kJywgb2xkU3RhdGUub25GYWlsdXJlQ2FsbGJhY2spO1xuICAgICAgb2xkU3RhdGUucmVzb3VyY2UucGxheVN0cmVhbS5vZmYoJ2Nsb3NlJywgb2xkU3RhdGUub25GYWlsdXJlQ2FsbGJhY2spO1xuICAgICAgb2xkU3RhdGUucmVzb3VyY2UucGxheVN0cmVhbS5vZmYoJ2ZpbmlzaCcsIG9sZFN0YXRlLm9uRmFpbHVyZUNhbGxiYWNrKTtcbiAgICAgIG9sZFN0YXRlLnJlc291cmNlLnBsYXlTdHJlYW0ub2ZmKCdyZWFkYWJsZScsIG9sZFN0YXRlLm9uUmVhZGFibGVDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLy8gdHJhbnNpdGlvbmluZyBpbnRvIGFuIGlkbGUgc2hvdWxkIGVuc3VyZSB0aGF0IGNvbm5lY3Rpb25zIHN0b3Agc3BlYWtpbmdcbiAgICBpZiAobmV3U3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5JZGxlKSB7XG4gICAgICB0aGlzLl9zaWduYWxTdG9wU3BlYWtpbmcoKTtcbiAgICAgIGRlbGV0ZUF1ZGlvUGxheWVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIGF0dGFjaCB0byB0aGUgZ2xvYmFsIGF1ZGlvIHBsYXllciB0aW1lclxuICAgIGlmIChuZXdSZXNvdXJjZSkge1xuICAgICAgYWRkQXVkaW9QbGF5ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gcGxheWluZyAtPiBwbGF5aW5nIHN0YXRlIGNoYW5nZXMgc2hvdWxkIHN0aWxsIHRyYW5zaXRpb24gaWYgYSByZXNvdXJjZSBjaGFuZ2VkIChzZWVtcyBsaWtlIGl0IHdvdWxkIGJlIHVzZWZ1bCEpXG4gICAgY29uc3QgZGlkQ2hhbmdlUmVzb3VyY2VzID1cbiAgICBvbGRTdGF0ZS5zdGF0dXMgIT09IEF1ZGlvUGxheWVyU3RhdHVzLklkbGUgJiZcbiAgICBuZXdTdGF0ZS5zdGF0dXMgPT09IEF1ZGlvUGxheWVyU3RhdHVzLlBsYXlpbmcgJiZcbiAgICBvbGRTdGF0ZS5yZXNvdXJjZSAhPT0gbmV3U3RhdGUucmVzb3VyY2U7XG5cbiAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuXG4gICAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZScsIG9sZFN0YXRlLCB0aGlzLl9zdGF0ZSk7XG4gICAgaWYgKG9sZFN0YXRlLnN0YXR1cyAhPT0gbmV3U3RhdGUuc3RhdHVzIHx8IGRpZENoYW5nZVJlc291cmNlcykge1xuICAgICAgdGhpcy5lbWl0KG5ld1N0YXRlLnN0YXR1cywgb2xkU3RhdGUsIHRoaXMuX3N0YXRlIGFzIHVuc2FmZSk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWJ1Zz8uKFxuICAgICAgYHN0YXRlIGNoYW5nZTpcXG5mcm9tICR7c3RyaW5naWZ5U3RhdGUob2xkU3RhdGUpfVxcbnRvICR7c3RyaW5naWZ5U3RhdGUoXG4gICAgICAgIG5ld1N0YXRlXG4gICAgICApfWBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFBsYXlzIGEgbmV3IHJlc291cmNlIG9uIHRoZSBwbGF5ZXIuIElmIHRoZSBwbGF5ZXIgaXMgYWxyZWFkeSBwbGF5aW5nIGEgcmVzb3VyY2UsIHRoZSBleGlzdGluZyByZXNvdXJjZSBpcyBkZXN0cm95ZWRcbiAgICogKGl0IGNhbm5vdCBiZSByZXVzZWQsIGV2ZW4gaW4gYW5vdGhlciBwbGF5ZXIpIGFuZCBpcyByZXBsYWNlZCB3aXRoIHRoZSBuZXcgcmVzb3VyY2UuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSBwbGF5ZXIgd2lsbCB0cmFuc2l0aW9uIHRvIHRoZSBQbGF5aW5nIHN0YXRlIG9uY2UgcGxheWJhY2sgYmVnaW5zLCBhbmQgd2lsbCByZXR1cm4gdG8gdGhlIElkbGUgc3RhdGUgb25jZVxuICAgKiBwbGF5YmFjayBpcyBlbmRlZC5cbiAgICpcbiAgICogSWYgdGhlIHBsYXllciB3YXMgcHJldmlvdXNseSBwbGF5aW5nIGEgcmVzb3VyY2UgYW5kIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgdGhlIHBsYXllciB3aWxsIG5vdCB0cmFuc2l0aW9uIHRvIHRoZVxuICAgKiBJZGxlIHN0YXRlIGR1cmluZyB0aGUgc3dhcCBvdmVyLlxuICAgKiBAcGFyYW0gcmVzb3VyY2UgLSBUaGUgcmVzb3VyY2UgdG8gcGxheVxuICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgaWYgYXR0ZW1wdGluZyB0byBwbGF5IGFuIGF1ZGlvIHJlc291cmNlIHRoYXQgaGFzIGFscmVhZHkgZW5kZWQsIG9yIGlzIGJlaW5nIHBsYXllZCBieSBhbm90aGVyIHBsYXllclxuICAgKi9cbiAgcHVibGljIHBsYXk8TWV0YWRhdGE+KHJlc291cmNlOiBBdWRpb1Jlc291cmNlPE1ldGFkYXRhPikge1xuICAgIGlmIChyZXNvdXJjZS5lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGxheSBhIHJlc291cmNlIHRoYXQgaGFzIGFscmVhZHkgZW5kZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc291cmNlLmF1ZGlvUGxheWVyKSB7XG4gICAgICBpZiAocmVzb3VyY2UuYXVkaW9QbGF5ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdSZXNvdXJjZSBpcyBhbHJlYWR5IGJlaW5nIHBsYXllZCBieSBhbm90aGVyIGF1ZGlvIHBsYXllci4nXG4gICAgICApO1xuICAgIH1cblxuICAgIHJlc291cmNlLmF1ZGlvUGxheWVyID0gdGhpcztcblxuICAgIC8vIEF0dGFjaCBlcnJvciBsaXN0ZW5lcnMgdG8gdGhlIHN0cmVhbSB0aGF0IHdpbGwgcHJvcGFnYXRlIHRoZSBlcnJvciBhbmQgdGhlbiByZXR1cm4gdG8gdGhlIElkbGVcbiAgICAvLyBzdGF0ZSBpZiB0aGUgcmVzb3VyY2UgaXMgc3RpbGwgYmVpbmcgdXNlZC5cbiAgICBjb25zdCBvblN0cmVhbUVycm9yID0gKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzICE9PSBBdWRpb1BsYXllclN0YXR1cy5JZGxlKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgQXVkaW9QbGF5ZXJFcnJvcihlcnJvciwgdGhpcy5zdGF0ZS5yZXNvdXJjZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICB0aGlzLnN0YXRlLnN0YXR1cyAhPT0gQXVkaW9QbGF5ZXJTdGF0dXMuSWRsZSAmJlxuICAgICAgdGhpcy5zdGF0ZS5yZXNvdXJjZSA9PT0gcmVzb3VyY2UpXG4gICAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgc3RhdHVzOiBBdWRpb1BsYXllclN0YXR1cy5JZGxlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJlc291cmNlLnBsYXlTdHJlYW0ub25jZSgnZXJyb3InLCBvblN0cmVhbUVycm9yKTtcblxuICAgIGlmIChyZXNvdXJjZS5zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBzdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLlBsYXlpbmcsXG4gICAgICAgIG1pc3NlZEZyYW1lczogMCxcbiAgICAgICAgcGxheWJhY2tEdXJhdGlvbjogMCxcbiAgICAgICAgcmVzb3VyY2UsXG4gICAgICAgIG9uU3RyZWFtRXJyb3JcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9uUmVhZGFibGVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gQXVkaW9QbGF5ZXJTdGF0dXMuQnVmZmVyaW5nICYmXG4gICAgICAgIHRoaXMuc3RhdGUucmVzb3VyY2UgPT09IHJlc291cmNlKVxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuUGxheWluZyxcbiAgICAgICAgICAgIG1pc3NlZEZyYW1lczogMCxcbiAgICAgICAgICAgIHBsYXliYWNrRHVyYXRpb246IDAsXG4gICAgICAgICAgICByZXNvdXJjZSxcbiAgICAgICAgICAgIG9uU3RyZWFtRXJyb3JcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvbkZhaWx1cmVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gQXVkaW9QbGF5ZXJTdGF0dXMuQnVmZmVyaW5nICYmXG4gICAgICAgIHRoaXMuc3RhdGUucmVzb3VyY2UgPT09IHJlc291cmNlKVxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuSWRsZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlc291cmNlLnBsYXlTdHJlYW0ub25jZSgncmVhZGFibGUnLCBvblJlYWRhYmxlQ2FsbGJhY2spO1xuXG4gICAgICByZXNvdXJjZS5wbGF5U3RyZWFtLm9uY2UoJ2VuZCcsIG9uRmFpbHVyZUNhbGxiYWNrKTtcbiAgICAgIHJlc291cmNlLnBsYXlTdHJlYW0ub25jZSgnY2xvc2UnLCBvbkZhaWx1cmVDYWxsYmFjayk7XG4gICAgICByZXNvdXJjZS5wbGF5U3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIG9uRmFpbHVyZUNhbGxiYWNrKTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc3RhdHVzOiBBdWRpb1BsYXllclN0YXR1cy5CdWZmZXJpbmcsXG4gICAgICAgIHJlc291cmNlLFxuICAgICAgICBvblJlYWRhYmxlQ2FsbGJhY2ssXG4gICAgICAgIG9uRmFpbHVyZUNhbGxiYWNrLFxuICAgICAgICBvblN0cmVhbUVycm9yXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZXMgcGxheWJhY2sgb2YgdGhlIGN1cnJlbnQgcmVzb3VyY2UsIGlmIGFueS5cbiAgICpcbiAgICogQHBhcmFtIGludGVycG9sYXRlU2lsZW5jZSAtIElmIHRydWUsIHRoZSBwbGF5ZXIgd2lsbCBwbGF5IDUgcGFja2V0cyBvZiBzaWxlbmNlIGFmdGVyIHBhdXNpbmcgdG8gcHJldmVudCBhdWRpbyBnbGl0Y2hlc1xuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBsYXllciB3YXMgc3VjY2Vzc2Z1bGx5IHBhdXNlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAgICovXG4gIHB1YmxpYyBwYXVzZShpbnRlcnBvbGF0ZVNpbGVuY2UgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzICE9PSBBdWRpb1BsYXllclN0YXR1cy5QbGF5aW5nKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICBzdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLlBhdXNlZCxcbiAgICAgIHNpbGVuY2VQYWNrZXRzUmVtYWluaW5nOiBpbnRlcnBvbGF0ZVNpbGVuY2UgPyA1IDogMFxuICAgIH07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVW5wYXVzZXMgcGxheWJhY2sgb2YgdGhlIGN1cnJlbnQgcmVzb3VyY2UsIGlmIGFueS5cbiAgICpcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwbGF5ZXIgd2FzIHN1Y2Nlc3NmdWxseSB1bnBhdXNlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAgICovXG4gIHB1YmxpYyB1bnBhdXNlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyAhPT0gQXVkaW9QbGF5ZXJTdGF0dXMuUGF1c2VkKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICBzdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLlBsYXlpbmcsXG4gICAgICBtaXNzZWRGcmFtZXM6IDBcbiAgICB9O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHBsYXliYWNrIG9mIHRoZSBjdXJyZW50IHJlc291cmNlIGFuZCBkZXN0cm95cyB0aGUgcmVzb3VyY2UuIFRoZSBwbGF5ZXIgd2lsbCBlaXRoZXIgdHJhbnNpdGlvbiB0byB0aGUgSWRsZSBzdGF0ZSxcbiAgICogb3IgcmVtYWluIGluIGl0cyBjdXJyZW50IHN0YXRlIHVudGlsIHRoZSBzaWxlbmNlIHBhZGRpbmcgZnJhbWVzIG9mIHRoZSByZXNvdXJjZSBoYXZlIGJlZW4gcGxheWVkLlxuICAgKlxuICAgKiBAcGFyYW0gZm9yY2UgLSBJZiB0cnVlLCB3aWxsIGZvcmNlIHRoZSBwbGF5ZXIgdG8gZW50ZXIgdGhlIElkbGUgc3RhdGUgZXZlbiBpZiB0aGUgcmVzb3VyY2UgaGFzIHNpbGVuY2UgcGFkZGluZyBmcmFtZXNcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwbGF5ZXIgd2lsbCBjb21lIHRvIGEgc3RvcCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAgICovXG4gIHB1YmxpYyBzdG9wKGZvcmNlID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09IEF1ZGlvUGxheWVyU3RhdHVzLklkbGUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZm9yY2UgfHwgdGhpcy5zdGF0ZS5yZXNvdXJjZS5zaWxlbmNlUGFkZGluZ0ZyYW1lcyA9PT0gMCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc3RhdHVzOiBBdWRpb1BsYXllclN0YXR1cy5JZGxlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5yZXNvdXJjZS5zaWxlbmNlUmVtYWluaW5nID09PSAtMSkge1xuICAgICAgdGhpcy5zdGF0ZS5yZXNvdXJjZS5zaWxlbmNlUmVtYWluaW5nID1cbiAgICAgIHRoaXMuc3RhdGUucmVzb3VyY2Uuc2lsZW5jZVBhZGRpbmdGcmFtZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2UgKGlmIGFueSkgaXMgcGxheWFibGUgKHJlYWRhYmxlKVxuICAgKlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlc291cmNlIGlzIHBsYXlhYmxlLCBvdGhlcndpc2UgYGZhbHNlYFxuICAgKi9cbiAgcHVibGljIGNoZWNrUGxheWFibGUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBpZiAoXG4gICAgc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5JZGxlIHx8XG4gICAgc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5CdWZmZXJpbmcpXG5cbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBJZiB0aGUgc3RyZWFtIGhhcyBiZWVuIGRlc3Ryb3llZCBvciBpcyBubyBsb25nZXIgcmVhZGFibGUsIHRoZW4gdHJhbnNpdGlvbiB0byB0aGUgSWRsZSBzdGF0ZS5cbiAgICBpZiAoIXN0YXRlLnJlc291cmNlLnJlYWRhYmxlKSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBzdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLklkbGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHJvdWdobHkgZXZlcnkgMjBtcyBieSB0aGUgZ2xvYmFsIGF1ZGlvIHBsYXllciB0aW1lci4gRGlzcGF0Y2hlcyBhbnkgYXVkaW8gcGFja2V0cyB0aGF0IGFyZSBidWZmZXJlZFxuICAgKiBieSB0aGUgYWN0aXZlIGNvbm5lY3Rpb25zIG9mIHRoaXMgYXVkaW8gcGxheWVyLlxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBwcml2YXRlIF9zdGVwRGlzcGF0Y2goKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcblxuICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIElkbGUgc3RhdGVcbiAgICBpZiAoXG4gICAgc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5JZGxlIHx8XG4gICAgc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5CdWZmZXJpbmcpXG5cbiAgICByZXR1cm47XG5cbiAgICAvLyBEaXNwYXRjaCBhbnkgYXVkaW8gcGFja2V0cyB0aGF0IHdlcmUgcHJlcGFyZWQgaW4gdGhlIHByZXZpb3VzIGN5Y2xlXG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIHRoaXMucGxheWFibGUpIHtcbiAgICAgIGNvbm5lY3Rpb24uZGlzcGF0Y2hBdWRpbygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgcm91Z2hseSBldmVyeSAyMG1zIGJ5IHRoZSBnbG9iYWwgYXVkaW8gcGxheWVyIHRpbWVyLiBBdHRlbXB0cyB0byByZWFkIGFuIGF1ZGlvIHBhY2tldCBmcm9tIHRoZVxuICAgKiB1bmRlcmx5aW5nIHJlc291cmNlIG9mIHRoZSBzdHJlYW0sIGFuZCB0aGVuIGhhcyBhbGwgdGhlIGFjdGl2ZSBjb25uZWN0aW9ucyBvZiB0aGUgYXVkaW8gcGxheWVyIHByZXBhcmUgaXRcbiAgICogKGVuY3J5cHQgaXQsIGFwcGVuZCBoZWFkZXIgZGF0YSkgc28gdGhhdCBpdCBpcyByZWFkeSB0byBwbGF5IGF0IHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjeWNsZS5cbiAgICovXG4gIC8vIEB0cy1pZ25vcmVcbiAgcHJpdmF0ZSBfc3RlcFByZXBhcmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcblxuICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIElkbGUgc3RhdGVcbiAgICBpZiAoXG4gICAgc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5JZGxlIHx8XG4gICAgc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5CdWZmZXJpbmcpXG5cbiAgICByZXR1cm47XG5cbiAgICAvLyBMaXN0IG9mIGNvbm5lY3Rpb25zIHRoYXQgY2FuIHJlY2VpdmUgdGhlIHBhY2tldFxuICAgIGNvbnN0IHBsYXlhYmxlID0gdGhpcy5wbGF5YWJsZTtcblxuICAgIC8qIElmIHRoZSBwbGF5ZXIgd2FzIHByZXZpb3VzbHkgaW4gdGhlIEF1dG9QYXVzZWQgc3RhdGUsIGNoZWNrIHRvIHNlZSB3aGV0aGVyIHRoZXJlIGFyZSBuZXdseSBhdmFpbGFibGVcbiAgICAgY29ubmVjdGlvbnMsIGFsbG93aW5nIHVzIHRvIHRyYW5zaXRpb24gb3V0IG9mIHRoZSBBdXRvUGF1c2VkIHN0YXRlIGJhY2sgaW50byB0aGUgUGxheWluZyBzdGF0ZSAqL1xuICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09IEF1ZGlvUGxheWVyU3RhdHVzLkF1dG9QYXVzZWQgJiYgcGxheWFibGUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuUGxheWluZyxcbiAgICAgICAgbWlzc2VkRnJhbWVzOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qIElmIHRoZSBwbGF5ZXIgaXMgKGF1dG8pcGF1c2VkLCBjaGVjayB0byBzZWUgd2hldGhlciBzaWxlbmNlIHBhY2tldHMgc2hvdWxkIGJlIHBsYXllZCBhbmRcbiAgICAgc2V0IGEgdGltZW91dCB0byBiZWdpbiB0aGUgbmV4dCBjeWNsZSwgZW5kaW5nIHRoZSBjdXJyZW50IGN5Y2xlIGhlcmUuICovXG4gICAgaWYgKFxuICAgIHN0YXRlLnN0YXR1cyA9PT0gQXVkaW9QbGF5ZXJTdGF0dXMuUGF1c2VkIHx8XG4gICAgc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5BdXRvUGF1c2VkKVxuICAgIHtcbiAgICAgIGlmIChzdGF0ZS5zaWxlbmNlUGFja2V0c1JlbWFpbmluZyA+IDApIHtcbiAgICAgICAgc3RhdGUuc2lsZW5jZVBhY2tldHNSZW1haW5pbmctLTtcbiAgICAgICAgdGhpcy5fcHJlcGFyZVBhY2tldChTSUxFTkNFX0ZSQU1FLCBwbGF5YWJsZSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUuc2lsZW5jZVBhY2tldHNSZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9zaWduYWxTdG9wU3BlYWtpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGF2YWlsYWJsZSBjb25uZWN0aW9ucyBpbiB0aGlzIGN5Y2xlLCBvYnNlcnZlIHRoZSBjb25maWd1cmVkIFwibm8gc3Vic2NyaWJlclwiIGJlaGF2aW9yLlxuICAgIGlmIChwbGF5YWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLmJlaGF2aW9ycy5ub1N1YnNjcmliZXIgPT09IE5vU3Vic2NyaWJlckJlaGF2aW9yLlBhdXNlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgc3RhdHVzOiBBdWRpb1BsYXllclN0YXR1cy5BdXRvUGF1c2VkLFxuICAgICAgICAgIHNpbGVuY2VQYWNrZXRzUmVtYWluaW5nOiA1XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5iZWhhdmlvcnMubm9TdWJzY3JpYmVyID09PSBOb1N1YnNjcmliZXJCZWhhdmlvci5TdG9wKSB7XG4gICAgICAgIHRoaXMuc3RvcCh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIHJlYWQgYW4gT3B1cyBwYWNrZXQgZnJvbSB0aGUgcmVzb3VyY2UuIElmIHRoZXJlIGlzbid0IGFuIGF2YWlsYWJsZSBwYWNrZXQsXG4gICAgICogcGxheSBhIHNpbGVuY2UgcGFja2V0LiBJZiB0aGVyZSBhcmUgNSBjb25zZWN1dGl2ZSBjeWNsZXMgd2l0aCBmYWlsZWQgcmVhZHMsIHRoZW4gdGhlXG4gICAgICogcGxheWJhY2sgd2lsbCBlbmQuXG4gICAgICovXG4gICAgY29uc3QgcGFja2V0OiBCdWZmZXIgfCBudWxsID0gc3RhdGUucmVzb3VyY2UucmVhZCgpO1xuXG4gICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gQXVkaW9QbGF5ZXJTdGF0dXMuUGxheWluZykge1xuICAgICAgaWYgKHBhY2tldCkge1xuICAgICAgICB0aGlzLl9wcmVwYXJlUGFja2V0KHBhY2tldCwgcGxheWFibGUsIHN0YXRlKTtcbiAgICAgICAgc3RhdGUubWlzc2VkRnJhbWVzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVQYWNrZXQoU0lMRU5DRV9GUkFNRSwgcGxheWFibGUsIHN0YXRlKTtcbiAgICAgICAgc3RhdGUubWlzc2VkRnJhbWVzKys7XG4gICAgICAgIGlmIChzdGF0ZS5taXNzZWRGcmFtZXMgPj0gdGhpcy5iZWhhdmlvcnMubWF4TWlzc2VkRnJhbWVzKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2lnbmFscyB0byBhbGwgdGhlIHN1YnNjcmliZWQgY29ubmVjdGlvbnMgdGhhdCB0aGV5IHNob3VsZCBzZW5kIGEgcGFja2V0IHRvIERpc2NvcmQgaW5kaWNhdGluZ1xuICAgKiB0aGV5IGFyZSBubyBsb25nZXIgc3BlYWtpbmcuIENhbGxlZCBvbmNlIHBsYXliYWNrIG9mIGEgcmVzb3VyY2UgZW5kcy5cbiAgICovXG4gIHByaXZhdGUgX3NpZ25hbFN0b3BTcGVha2luZygpIHtcbiAgICBmb3IgKGNvbnN0IHsgY29ubmVjdGlvbiB9IG9mIHRoaXMuc3Vic2NyaWJlcnMpIHtcbiAgICAgIGNvbm5lY3Rpb24uc2V0U3BlYWtpbmcoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0cnVjdHMgdGhlIGdpdmVuIGNvbm5lY3Rpb25zIHRvIGVhY2ggcHJlcGFyZSB0aGlzIHBhY2tldCB0byBiZSBwbGF5ZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiBuZXh0IGN5Y2xlLlxuICAgKlxuICAgKiBAcGFyYW0gcGFja2V0IC0gVGhlIE9wdXMgcGFja2V0IHRvIGJlIHByZXBhcmVkIGJ5IGVhY2ggcmVjZWl2ZXJcbiAgICogQHBhcmFtIHJlY2VpdmVycyAtIFRoZSBjb25uZWN0aW9ucyB0aGF0IHNob3VsZCBwbGF5IHRoaXMgcGFja2V0XG4gICAqL1xuICBwcml2YXRlIF9wcmVwYXJlUGFja2V0KFxuICBwYWNrZXQ6IEJ1ZmZlcixcbiAgcmVjZWl2ZXJzOiBWb2ljZUNvbm5lY3Rpb25bXSxcbiAgc3RhdGU6IEF1ZGlvUGxheWVyUGF1c2VkU3RhdGUgfCBBdWRpb1BsYXllclBsYXlpbmdTdGF0ZSlcbiAge1xuICAgIHN0YXRlLnBsYXliYWNrRHVyYXRpb24gKz0gMjA7XG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIHJlY2VpdmVycykge1xuICAgICAgY29ubmVjdGlvbi5wcmVwYXJlQXVkaW9QYWNrZXQocGFja2V0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEF1ZGlvUGxheWVyIHRvIGJlIHVzZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBdWRpb1BsYXllcihvcHRpb25zPzogQ3JlYXRlQXVkaW9QbGF5ZXJPcHRpb25zKSB7XG4gIHJldHVybiBuZXcgQXVkaW9QbGF5ZXIob3B0aW9ucyk7XG59IiwgIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG5pbXBvcnQgdHlwZSB7IEF1ZGlvUmVzb3VyY2UgfSBmcm9tICcuL0F1ZGlvUmVzb3VyY2UnO1xuXG4vKipcbiAqIEFuIGVycm9yIGVtaXR0ZWQgYnkgYW4gQXVkaW9QbGF5ZXIuIENvbnRhaW5zIGFuIGF0dGFjaGVkIHJlc291cmNlIHRvIGFpZCB3aXRoXG4gKiBkZWJ1Z2dpbmcgYW5kIGlkZW50aWZ5aW5nIHdoZXJlIHRoZSBlcnJvciBjYW1lIGZyb20uXG4gKi9cbmV4cG9ydCBjbGFzcyBBdWRpb1BsYXllckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogVGhlIHJlc291cmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXVkaW8gcGxheWVyIGF0IHRoZSB0aW1lIHRoZSBlcnJvciB3YXMgdGhyb3duLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHJlc291cmNlOiBBdWRpb1Jlc291cmNlO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihlcnJvcjogRXJyb3IsIHJlc291cmNlOiBBdWRpb1Jlc291cmNlKSB7XG4gICAgc3VwZXIoZXJyb3IubWVzc2FnZSk7XG4gICAgdGhpcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgIHRoaXMubmFtZSA9IGVycm9yLm5hbWU7XG4gICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrITtcbiAgfVxufSIsICIvLyBDb3B5cmlnaHQgZGlzY29yZC1wbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIExpY2Vuc2UuXG4vLyBDb3B5cmlnaHQgZGlzY29yZC5qcyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBBcGFjaGUgTGljZW5zZSAyLjBcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2RvdC1ub3RhdGlvbiAqL1xuaW1wb3J0IHR5cGUgeyBWb2ljZUNvbm5lY3Rpb24gfSBmcm9tICcuLi9Wb2ljZUNvbm5lY3Rpb24nO1xuaW1wb3J0IHR5cGUgeyBBdWRpb1BsYXllciB9IGZyb20gJy4vQXVkaW9QbGF5ZXInO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdWJzY3JpcHRpb24gb2YgYSB2b2ljZSBjb25uZWN0aW9uIHRvIGFuIGF1ZGlvIHBsYXllciwgYWxsb3dpbmdcbiAqIHRoZSBhdWRpbyBwbGF5ZXIgdG8gcGxheSBhdWRpbyBvbiB0aGUgdm9pY2UgY29ubmVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFBsYXllclN1YnNjcmlwdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgdm9pY2UgY29ubmVjdGlvbiBvZiB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjb25uZWN0aW9uOiBWb2ljZUNvbm5lY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBhdWRpbyBwbGF5ZXIgb2YgdGhpcyBzdWJzY3JpcHRpb24uXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcGxheWVyOiBBdWRpb1BsYXllcjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoY29ubmVjdGlvbjogVm9pY2VDb25uZWN0aW9uLCBwbGF5ZXI6IEF1ZGlvUGxheWVyKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB0aGlzLnBsYXllciA9IHBsYXllcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgdGhlIGNvbm5lY3Rpb24gZnJvbSB0aGUgYXVkaW8gcGxheWVyLCBtZWFuaW5nIHRoYXQgdGhlXG4gICAqIGF1ZGlvIHBsYXllciBjYW5ub3Qgc3RyZWFtIGF1ZGlvIHRvIGl0IHVudGlsIGEgbmV3IHN1YnNjcmlwdGlvbiBpcyBtYWRlLlxuICAgKi9cbiAgcHVibGljIHVuc3Vic2NyaWJlKCkge1xuICAgIHRoaXMuY29ubmVjdGlvblsnb25TdWJzY3JpcHRpb25SZW1vdmVkJ10odGhpcyk7XG4gICAgdGhpcy5wbGF5ZXJbJ3Vuc3Vic2NyaWJlJ10odGhpcyk7XG4gIH1cbn0iLCAiLy8gQ29weXJpZ2h0IGRpc2NvcmQtcGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBMaWNlbnNlLlxuLy8gQ29weXJpZ2h0IGRpc2NvcmQuanMgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gQXBhY2hlIExpY2Vuc2UgMi4wXG5cbmltcG9ydCB0eXBlIHsgQnVmZmVyIH0gZnJvbSAnbm9kZTpidWZmZXInO1xuaW1wb3J0IHsgcGlwZWxpbmUsIHR5cGUgUmVhZGFibGUgfSBmcm9tICdub2RlOnN0cmVhbSc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vdXRpbC91dGlsJztcbmltcG9ydCB7IFNJTEVOQ0VfRlJBTUUsIHR5cGUgQXVkaW9QbGF5ZXIgfSBmcm9tICcuL0F1ZGlvUGxheWVyJztcbmltcG9ydCB7XG4gIGZpbmRQaXBlbGluZSxcbiAgU3RyZWFtVHlwZSxcbiAgVHJhbnNmb3JtZXJUeXBlLFxuICB0eXBlIEVkZ2UgfSBmcm9tXG4nLi9UcmFuc2Zvcm1lckdyYXBoJztcbmltcG9ydCB7XG4gIE9nZ0RlbXV4ZXIsXG4gIE9wdXNEZWNvZGVyLFxuICBPcHVzRW5jb2RlcixcbiAgV2VibURlbXV4ZXIgfSBmcm9tXG4nQGRpc2NvcmQtcGxheWVyL29wdXMnO1xuaW1wb3J0IHsgVm9sdW1lVHJhbnNmb3JtZXIgfSBmcm9tICdAZGlzY29yZC1wbGF5ZXIvZXF1YWxpemVyJztcblxuLyoqXG4gKiBPcHRpb25zIHRoYXQgYXJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IGF1ZGlvIHJlc291cmNlLlxuICpcbiAqIEB0eXBlUGFyYW0gTWV0YWRhdGEgLSB0aGUgdHlwZSBmb3IgdGhlIG1ldGFkYXRhIChpZiBhbnkpIG9mIHRoZSBhdWRpbyByZXNvdXJjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUF1ZGlvUmVzb3VyY2VPcHRpb25zPE1ldGFkYXRhPiB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBpbmxpbmUgdm9sdW1lIHNob3VsZCBiZSBlbmFibGVkLiBJZiBlbmFibGVkLCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGNoYW5nZSB0aGUgdm9sdW1lXG4gICAqIG9mIHRoZSBzdHJlYW0gb24tdGhlLWZseS4gSG93ZXZlciwgdGhpcyBhbHNvIGluY3JlYXNlcyB0aGUgcGVyZm9ybWFuY2UgY29zdCBvZiBwbGF5YmFjay4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGlubGluZVZvbHVtZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSBpbnB1dCBzdHJlYW0uIERlZmF1bHRzIHRvIGBTdHJlYW1UeXBlLkFyYml0cmFyeWAuXG4gICAqL1xuICBpbnB1dFR5cGU/OiBTdHJlYW1UeXBlO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBtZXRhZGF0YSB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgcmVzb3VyY2UgKGUuZy4gdHJhY2sgdGl0bGUsIHJhbmRvbSBpZCkuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBpZGVudGlmaWNhdGlvbiBwdXJwb3NlcyB3aGVuIHRoZSByZXNvdXJjZSBpcyBwYXNzZWQgYXJvdW5kIGluIGV2ZW50cy5cbiAgICogU2VlIHtAbGluayBBdWRpb1Jlc291cmNlLm1ldGFkYXRhfVxuICAgKi9cbiAgbWV0YWRhdGE/OiBNZXRhZGF0YTtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzaWxlbmNlIGZyYW1lcyB0byBhcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgcmVzb3VyY2UncyBhdWRpbyBzdHJlYW0sIHRvIHByZXZlbnQgaW50ZXJwb2xhdGlvbiBnbGl0Y2hlcy5cbiAgICogRGVmYXVsdHMgdG8gNS5cbiAgICovXG4gIHNpbGVuY2VQYWRkaW5nRnJhbWVzPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYXVkaW8gcmVzb3VyY2UgdGhhdCBjYW4gYmUgcGxheWVkIGJ5IGFuIGF1ZGlvIHBsYXllci5cbiAqXG4gKiBAdHlwZVBhcmFtIE1ldGFkYXRhIC0gdGhlIHR5cGUgZm9yIHRoZSBtZXRhZGF0YSAoaWYgYW55KSBvZiB0aGUgYXVkaW8gcmVzb3VyY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEF1ZGlvUmVzb3VyY2U8TWV0YWRhdGEgPSB1bmtub3duPiB7XG4gIC8qKlxuICAgKiBBbiBvYmplY3QtbW9kZSBSZWFkYWJsZSBzdHJlYW0gdGhhdCBlbWl0cyBPcHVzIHBhY2tldHMuIFRoaXMgaXMgd2hhdCBpcyBwbGF5ZWQgYnkgYXVkaW8gcGxheWVycy5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwbGF5U3RyZWFtOiBSZWFkYWJsZTtcblxuICAvKipcbiAgICogVGhlIHBpcGVsaW5lIHVzZWQgdG8gY29udmVydCB0aGUgaW5wdXQgc3RyZWFtIGludG8gYSBwbGF5YWJsZSBmb3JtYXQuIEZvciBleGFtcGxlLCB0aGlzIG1heVxuICAgKiBjb250YWluIGFuIEZGbXBlZyBjb21wb25lbnQgZm9yIGFyYml0cmFyeSBpbnB1dHMsIGFuZCBpdCBtYXkgY29udGFpbiBhIFZvbHVtZVRyYW5zZm9ybWVyIGNvbXBvbmVudFxuICAgKiBmb3IgcmVzb3VyY2VzIHdpdGggaW5saW5lIHZvbHVtZSB0cmFuc2Zvcm1hdGlvbiBlbmFibGVkLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGVkZ2VzOiByZWFkb25seSBFZGdlW107XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIG1ldGFkYXRhIHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHJlc291cmNlLlxuICAgKi9cbiAgcHVibGljIG1ldGFkYXRhOiBNZXRhZGF0YTtcblxuICAvKipcbiAgICogSWYgdGhlIHJlc291cmNlIHdhcyBjcmVhdGVkIHdpdGggaW5saW5lIHZvbHVtZSB0cmFuc2Zvcm1hdGlvbiBlbmFibGVkLCB0aGVuIHRoaXMgd2lsbCBiZSBhXG4gICAqIGBAZGlzY29yZC1wbGF5ZXIvZXF1YWxpemVyYCBWb2x1bWVUcmFuc2Zvcm1lci4gWW91IGNhbiB1c2UgdGhpcyB0byBhbHRlciB0aGUgdm9sdW1lIG9mIHRoZSBzdHJlYW0uXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgdm9sdW1lPzogVm9sdW1lVHJhbnNmb3JtZXI7XG5cbiAgLyoqXG4gICAqIElmIHVzaW5nIGFuIE9wdXMgZW5jb2RlciB0byBjcmVhdGUgdGhpcyBhdWRpbyByZXNvdXJjZSwgdGhlbiB0aGlzIHdpbGwgYmUgYWBAZGlzY29yZC1wbGF5ZXIvb3B1c2Agb3B1cy5FbmNvZGVyLlxuICAgKiBZb3UgY2FuIHVzZSB0aGlzIHRvIGNvbnRyb2wgc2V0dGluZ3Mgc3VjaCBhcyBiaXRyYXRlLCBGRUMsIFBMUC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBlbmNvZGVyPzogT3B1c0VuY29kZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBhdWRpbyBwbGF5ZXIgdGhhdCB0aGUgcmVzb3VyY2UgaXMgc3Vic2NyaWJlZCB0bywgaWYgYW55LlxuICAgKi9cbiAgcHVibGljIGF1ZGlvUGxheWVyPzogQXVkaW9QbGF5ZXIgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBwbGF5YmFjayBkdXJhdGlvbiBvZiB0aGlzIGF1ZGlvIHJlc291cmNlLCBnaXZlbiBpbiBtaWxsaXNlY29uZHMuXG4gICAqL1xuICBwdWJsaWMgcGxheWJhY2tEdXJhdGlvbiA9IDA7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzdHJlYW0gZm9yIHRoaXMgcmVzb3VyY2UgaGFzIHN0YXJ0ZWQgKGRhdGEgaGFzIGJlY29tZSByZWFkYWJsZSlcbiAgICovXG4gIHB1YmxpYyBzdGFydGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygc2lsZW5jZSBmcmFtZXMgdG8gYXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIHJlc291cmNlJ3MgYXVkaW8gc3RyZWFtLCB0byBwcmV2ZW50IGludGVycG9sYXRpb24gZ2xpdGNoZXMuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgc2lsZW5jZVBhZGRpbmdGcmFtZXM6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiByZW1haW5pbmcgc2lsZW5jZSBmcmFtZXMgdG8gcGxheS4gSWYgLTEsIHRoZSBmcmFtZXMgaGF2ZSBub3QgeWV0IHN0YXJ0ZWQgcGxheWluZy5cbiAgICovXG4gIHB1YmxpYyBzaWxlbmNlUmVtYWluaW5nID0gLTE7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICBlZGdlczogcmVhZG9ubHkgRWRnZVtdLFxuICBzdHJlYW1zOiByZWFkb25seSBSZWFkYWJsZVtdLFxuICBtZXRhZGF0YTogTWV0YWRhdGEsXG4gIHNpbGVuY2VQYWRkaW5nRnJhbWVzOiBudW1iZXIpXG4gIHtcbiAgICB0aGlzLmVkZ2VzID0gZWRnZXM7XG4gICAgdGhpcy5wbGF5U3RyZWFtID1cbiAgICBzdHJlYW1zLmxlbmd0aCA+IDEgP1xuICAgIHBpcGVsaW5lKHN0cmVhbXMsIG5vb3ApIGFzIHVua25vd24gYXMgUmVhZGFibGUgOlxuICAgIHN0cmVhbXNbMF0hO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB0aGlzLnNpbGVuY2VQYWRkaW5nRnJhbWVzID0gc2lsZW5jZVBhZGRpbmdGcmFtZXM7XG5cbiAgICBmb3IgKGNvbnN0IHN0cmVhbSBvZiBzdHJlYW1zKSB7XG4gICAgICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgVm9sdW1lVHJhbnNmb3JtZXIpIHtcbiAgICAgICAgdGhpcy52b2x1bWUgPSBzdHJlYW07XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIE9wdXNFbmNvZGVyKSB7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IHN0cmVhbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBsYXlTdHJlYW0ub25jZSgncmVhZGFibGUnLCAoKSA9PiB0aGlzLnN0YXJ0ZWQgPSB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgcmVzb3VyY2UgaXMgcmVhZGFibGUuIElmIHRoZSB1bmRlcmx5aW5nIHJlc291cmNlIGlzIG5vIGxvbmdlciByZWFkYWJsZSwgdGhpcyB3aWxsIHN0aWxsIHJldHVybiB0cnVlXG4gICAqIHdoaWxlIHRoZXJlIGFyZSBzaWxlbmNlIHBhZGRpbmcgZnJhbWVzIGxlZnQgdG8gcGxheS5cbiAgICovXG4gIHB1YmxpYyBnZXQgcmVhZGFibGUoKSB7XG4gICAgaWYgKHRoaXMuc2lsZW5jZVJlbWFpbmluZyA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHJlYWwgPSB0aGlzLnBsYXlTdHJlYW0ucmVhZGFibGU7XG4gICAgaWYgKCFyZWFsKSB7XG4gICAgICBpZiAodGhpcy5zaWxlbmNlUmVtYWluaW5nID09PSAtMSlcbiAgICAgIHRoaXMuc2lsZW5jZVJlbWFpbmluZyA9IHRoaXMuc2lsZW5jZVBhZGRpbmdGcmFtZXM7XG4gICAgICByZXR1cm4gdGhpcy5zaWxlbmNlUmVtYWluaW5nICE9PSAwO1xuICAgIH1cblxuICAgIHJldHVybiByZWFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyByZXNvdXJjZSBoYXMgZW5kZWQgb3Igbm90LlxuICAgKi9cbiAgcHVibGljIGdldCBlbmRlZCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5wbGF5U3RyZWFtLnJlYWRhYmxlRW5kZWQgfHxcbiAgICAgIHRoaXMucGxheVN0cmVhbS5kZXN0cm95ZWQgfHxcbiAgICAgIHRoaXMuc2lsZW5jZVJlbWFpbmluZyA9PT0gMCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byByZWFkIGFuIE9wdXMgcGFja2V0IGZyb20gdGhlIGF1ZGlvIHJlc291cmNlLiBJZiBhIHBhY2tldCBpcyBhdmFpbGFibGUsIHRoZSBwbGF5YmFja0R1cmF0aW9uXG4gICAqIGlzIGluY3JlbWVudGVkLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJdCBpcyBhZHZpc2FibGUgdG8gY2hlY2sgdGhhdCB0aGUgcGxheVN0cmVhbSBpcyByZWFkYWJsZSBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZC4gV2hpbGUgbm8gcnVudGltZVxuICAgKiBlcnJvcnMgd2lsbCBiZSB0aHJvd24sIHlvdSBzaG91bGQgY2hlY2sgdGhhdCB0aGUgcmVzb3VyY2UgaXMgc3RpbGwgYXZhaWxhYmxlIGJlZm9yZSBhdHRlbXB0aW5nIHRvXG4gICAqIHJlYWQgZnJvbSBpdC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgcmVhZCgpOiBCdWZmZXIgfCBudWxsIHtcbiAgICBpZiAodGhpcy5zaWxlbmNlUmVtYWluaW5nID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2lsZW5jZVJlbWFpbmluZyA+IDApIHtcbiAgICAgIHRoaXMuc2lsZW5jZVJlbWFpbmluZy0tO1xuICAgICAgcmV0dXJuIFNJTEVOQ0VfRlJBTUU7XG4gICAgfVxuXG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5wbGF5U3RyZWFtLnJlYWQoKSBhcyBCdWZmZXIgfCBudWxsO1xuICAgIGlmIChwYWNrZXQpIHtcbiAgICAgIHRoaXMucGxheWJhY2tEdXJhdGlvbiArPSAyMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0IGEgcGF0aCBjb250YWlucyBhdCBsZWFzdCBvbmUgdm9sdW1lIHRyYW5zZm9ybWluZyBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byB2YWxpZGF0ZSBjb25zdHJhaW50cyBvblxuICovXG5leHBvcnQgY29uc3QgVk9MVU1FX0NPTlNUUkFJTlQgPSAocGF0aDogRWRnZVtdKSA9PlxucGF0aC5zb21lKChlZGdlKSA9PiBlZGdlLnR5cGUgPT09IFRyYW5zZm9ybWVyVHlwZS5JbmxpbmVWb2x1bWUpO1xuXG5leHBvcnQgY29uc3QgTk9fQ09OU1RSQUlOVCA9ICgpID0+IHRydWU7XG5cbi8qKlxuICogVHJpZXMgdG8gaW5mZXIgdGhlIHR5cGUgb2YgYSBzdHJlYW0gdG8gYWlkIHdpdGggdHJhbnNjb2RlciBwaXBlbGluaW5nLlxuICpcbiAqIEBwYXJhbSBzdHJlYW0gLSBUaGUgc3RyZWFtIHRvIGluZmVyIHRoZSB0eXBlIG9mXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZlclN0cmVhbVR5cGUoc3RyZWFtOiBSZWFkYWJsZSk6IHtcbiAgaGFzVm9sdW1lOiBib29sZWFuO1xuICBzdHJlYW1UeXBlOiBTdHJlYW1UeXBlO1xufSB7XG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBPcHVzRW5jb2Rlcikge1xuICAgIHJldHVybiB7IHN0cmVhbVR5cGU6IFN0cmVhbVR5cGUuT3B1cywgaGFzVm9sdW1lOiBmYWxzZSB9O1xuICB9IGVsc2UgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIE9wdXNEZWNvZGVyKSB7XG4gICAgcmV0dXJuIHsgc3RyZWFtVHlwZTogU3RyZWFtVHlwZS5SYXcsIGhhc1ZvbHVtZTogZmFsc2UgfTtcbiAgfSBlbHNlIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBWb2x1bWVUcmFuc2Zvcm1lcikge1xuICAgIHJldHVybiB7IHN0cmVhbVR5cGU6IFN0cmVhbVR5cGUuUmF3LCBoYXNWb2x1bWU6IHRydWUgfTtcbiAgfSBlbHNlIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBPZ2dEZW11eGVyKSB7XG4gICAgcmV0dXJuIHsgc3RyZWFtVHlwZTogU3RyZWFtVHlwZS5PcHVzLCBoYXNWb2x1bWU6IGZhbHNlIH07XG4gIH0gZWxzZSBpZiAoc3RyZWFtIGluc3RhbmNlb2YgV2VibURlbXV4ZXIpIHtcbiAgICByZXR1cm4geyBzdHJlYW1UeXBlOiBTdHJlYW1UeXBlLk9wdXMsIGhhc1ZvbHVtZTogZmFsc2UgfTtcbiAgfVxuXG4gIHJldHVybiB7IHN0cmVhbVR5cGU6IFN0cmVhbVR5cGUuQXJiaXRyYXJ5LCBoYXNWb2x1bWU6IGZhbHNlIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhdWRpbyByZXNvdXJjZSB0aGF0IGNhbiBiZSBwbGF5ZWQgYnkgYXVkaW8gcGxheWVycy5cbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgdGhlIGlucHV0IGlzIGdpdmVuIGFzIGEgc3RyaW5nLCB0aGVuIHRoZSBpbnB1dFR5cGUgb3B0aW9uIHdpbGwgYmUgb3ZlcnJpZGRlbiBhbmQgRkZtcGVnIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBJZiB0aGUgaW5wdXQgaXMgbm90IGluIHRoZSBjb3JyZWN0IGZvcm1hdCwgdGhlbiBhIHBpcGVsaW5lIG9mIHRyYW5zY29kZXJzIGFuZCB0cmFuc2Zvcm1lcnMgd2lsbCBiZSBjcmVhdGVkXG4gKiB0byBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0YW50IHN0cmVhbSBpcyBpbiB0aGUgY29ycmVjdCBmb3JtYXQgZm9yIHBsYXliYWNrLiBUaGlzIGNvdWxkIGludm9sdmUgdXNpbmcgRkZtcGVnLFxuICogT3B1cyB0cmFuc2NvZGVycywgYW5kIE9nZy9XZWJNIGRlbXV4ZXJzLlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHJlc291cmNlIHRvIHBsYXlcbiAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhYmxlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSByZXNvdXJjZVxuICogQHR5cGVQYXJhbSBNZXRhZGF0YSAtIHRoZSB0eXBlIGZvciB0aGUgbWV0YWRhdGEgKGlmIGFueSkgb2YgdGhlIGF1ZGlvIHJlc291cmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBdWRpb1Jlc291cmNlPE1ldGFkYXRhPihcbmlucHV0OiBSZWFkYWJsZSB8IHN0cmluZyxcbm9wdGlvbnM6IENyZWF0ZUF1ZGlvUmVzb3VyY2VPcHRpb25zPE1ldGFkYXRhPiAmXG5QaWNrPFxuICBNZXRhZGF0YSBleHRlbmRzIG51bGwgfCB1bmRlZmluZWQgP1xuICBDcmVhdGVBdWRpb1Jlc291cmNlT3B0aW9uczxNZXRhZGF0YT4gOlxuICBSZXF1aXJlZDxDcmVhdGVBdWRpb1Jlc291cmNlT3B0aW9uczxNZXRhZGF0YT4+LFxuICAnbWV0YWRhdGEnPilcblxuOiBBdWRpb1Jlc291cmNlPE1ldGFkYXRhIGV4dGVuZHMgbnVsbCB8IHVuZGVmaW5lZCA/IG51bGwgOiBNZXRhZGF0YT47XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhdWRpbyByZXNvdXJjZSB0aGF0IGNhbiBiZSBwbGF5ZWQgYnkgYXVkaW8gcGxheWVycy5cbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgdGhlIGlucHV0IGlzIGdpdmVuIGFzIGEgc3RyaW5nLCB0aGVuIHRoZSBpbnB1dFR5cGUgb3B0aW9uIHdpbGwgYmUgb3ZlcnJpZGRlbiBhbmQgRkZtcGVnIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBJZiB0aGUgaW5wdXQgaXMgbm90IGluIHRoZSBjb3JyZWN0IGZvcm1hdCwgdGhlbiBhIHBpcGVsaW5lIG9mIHRyYW5zY29kZXJzIGFuZCB0cmFuc2Zvcm1lcnMgd2lsbCBiZSBjcmVhdGVkXG4gKiB0byBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0YW50IHN0cmVhbSBpcyBpbiB0aGUgY29ycmVjdCBmb3JtYXQgZm9yIHBsYXliYWNrLiBUaGlzIGNvdWxkIGludm9sdmUgdXNpbmcgRkZtcGVnLFxuICogT3B1cyB0cmFuc2NvZGVycywgYW5kIE9nZy9XZWJNIGRlbXV4ZXJzLlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHJlc291cmNlIHRvIHBsYXlcbiAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhYmxlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSByZXNvdXJjZVxuICogQHR5cGVQYXJhbSBNZXRhZGF0YSAtIHRoZSB0eXBlIGZvciB0aGUgbWV0YWRhdGEgKGlmIGFueSkgb2YgdGhlIGF1ZGlvIHJlc291cmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBdWRpb1Jlc291cmNlPE1ldGFkYXRhIGV4dGVuZHMgbnVsbCB8IHVuZGVmaW5lZD4oXG5pbnB1dDogUmVhZGFibGUgfCBzdHJpbmcsXG5vcHRpb25zPzogT21pdDxDcmVhdGVBdWRpb1Jlc291cmNlT3B0aW9uczxNZXRhZGF0YT4sICdtZXRhZGF0YSc+KVxuOiBBdWRpb1Jlc291cmNlPG51bGw+O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXVkaW8gcmVzb3VyY2UgdGhhdCBjYW4gYmUgcGxheWVkIGJ5IGF1ZGlvIHBsYXllcnMuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHRoZSBpbnB1dCBpcyBnaXZlbiBhcyBhIHN0cmluZywgdGhlbiB0aGUgaW5wdXRUeXBlIG9wdGlvbiB3aWxsIGJlIG92ZXJyaWRkZW4gYW5kIEZGbXBlZyB3aWxsIGJlIHVzZWQuXG4gKlxuICogSWYgdGhlIGlucHV0IGlzIG5vdCBpbiB0aGUgY29ycmVjdCBmb3JtYXQsIHRoZW4gYSBwaXBlbGluZSBvZiB0cmFuc2NvZGVycyBhbmQgdHJhbnNmb3JtZXJzIHdpbGwgYmUgY3JlYXRlZFxuICogdG8gZW5zdXJlIHRoYXQgdGhlIHJlc3VsdGFudCBzdHJlYW0gaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0IGZvciBwbGF5YmFjay4gVGhpcyBjb3VsZCBpbnZvbHZlIHVzaW5nIEZGbXBlZyxcbiAqIE9wdXMgdHJhbnNjb2RlcnMsIGFuZCBPZ2cvV2ViTSBkZW11eGVycy5cbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSByZXNvdXJjZSB0byBwbGF5XG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYWJsZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgcmVzb3VyY2VcbiAqIEB0eXBlUGFyYW0gTWV0YWRhdGEgLSB0aGUgdHlwZSBmb3IgdGhlIG1ldGFkYXRhIChpZiBhbnkpIG9mIHRoZSBhdWRpbyByZXNvdXJjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXVkaW9SZXNvdXJjZTxNZXRhZGF0YT4oXG5pbnB1dDogUmVhZGFibGUgfCBzdHJpbmcsXG5vcHRpb25zOiBDcmVhdGVBdWRpb1Jlc291cmNlT3B0aW9uczxNZXRhZGF0YT4gPSB7fSlcbjogQXVkaW9SZXNvdXJjZTxNZXRhZGF0YT4ge1xuICBsZXQgaW5wdXRUeXBlID0gb3B0aW9ucy5pbnB1dFR5cGU7XG4gIGxldCBuZWVkc0lubGluZVZvbHVtZSA9IEJvb2xlYW4ob3B0aW9ucy5pbmxpbmVWb2x1bWUpO1xuXG4gIC8vIHN0cmluZyBpbnB1dHMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIEZGbXBlZ1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIGlucHV0VHlwZSA9IFN0cmVhbVR5cGUuQXJiaXRyYXJ5O1xuICB9IGVsc2UgaWYgKGlucHV0VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYW5hbHlzaXMgPSBpbmZlclN0cmVhbVR5cGUoaW5wdXQpO1xuICAgIGlucHV0VHlwZSA9IGFuYWx5c2lzLnN0cmVhbVR5cGU7XG4gICAgbmVlZHNJbmxpbmVWb2x1bWUgPSBuZWVkc0lubGluZVZvbHVtZSAmJiAhYW5hbHlzaXMuaGFzVm9sdW1lO1xuICB9XG5cbiAgY29uc3QgdHJhbnNmb3JtZXJQaXBlbGluZSA9IGZpbmRQaXBlbGluZShcbiAgICBpbnB1dFR5cGUsXG4gICAgbmVlZHNJbmxpbmVWb2x1bWUgPyBWT0xVTUVfQ09OU1RSQUlOVCA6IE5PX0NPTlNUUkFJTlRcbiAgKTtcblxuICBpZiAodHJhbnNmb3JtZXJQaXBlbGluZS5sZW5ndGggPT09IDApIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBwaXBlbGluZSBjb25zdHJ1Y3RlZCBmb3Igc3RyaW5nIHJlc291cmNlICcke2lucHV0fSdgXG4gICAgKTtcbiAgICAvLyBObyBhZGp1c3RtZW50cyByZXF1aXJlZFxuICAgIHJldHVybiBuZXcgQXVkaW9SZXNvdXJjZTxNZXRhZGF0YT4oXG4gICAgICBbXSxcbiAgICAgIFtpbnB1dF0sXG4gICAgICAob3B0aW9ucy5tZXRhZGF0YSA/PyBudWxsKSBhcyBNZXRhZGF0YSxcbiAgICAgIG9wdGlvbnMuc2lsZW5jZVBhZGRpbmdGcmFtZXMgPz8gNVxuICAgICk7XG4gIH1cblxuICBjb25zdCBzdHJlYW1zID0gdHJhbnNmb3JtZXJQaXBlbGluZS5tYXAoKGVkZ2UpID0+IGVkZ2UudHJhbnNmb3JtZXIoaW5wdXQpKTtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHN0cmVhbXMudW5zaGlmdChpbnB1dCk7XG5cbiAgcmV0dXJuIG5ldyBBdWRpb1Jlc291cmNlPE1ldGFkYXRhPihcbiAgICB0cmFuc2Zvcm1lclBpcGVsaW5lLFxuICAgIHN0cmVhbXMsXG4gICAgKG9wdGlvbnMubWV0YWRhdGEgPz8gbnVsbCkgYXMgTWV0YWRhdGEsXG4gICAgb3B0aW9ucy5zaWxlbmNlUGFkZGluZ0ZyYW1lcyA/PyA1XG4gICk7XG59IiwgIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG5pbXBvcnQgdHlwZSB7IFJlYWRhYmxlIH0gZnJvbSAnbm9kZTpzdHJlYW0nO1xuaW1wb3J0IHtcbiAgT3B1c0VuY29kZXIsXG4gIE9wdXNEZWNvZGVyLFxuICBPZ2dEZW11eGVyLFxuICBXZWJtRGVtdXhlciB9IGZyb21cbidAZGlzY29yZC1wbGF5ZXIvb3B1cyc7XG5pbXBvcnQgeyBjcmVhdGVGRm1wZWdBcmdzLCBGRm1wZWcgfSBmcm9tICdAZGlzY29yZC1wbGF5ZXIvZmZtcGVnJztcbmltcG9ydCB7IFZvbHVtZVRyYW5zZm9ybWVyIH0gZnJvbSAnQGRpc2NvcmQtcGxheWVyL2VxdWFsaXplcic7XG5cbmNvbnN0IEZGTVBFR19QQ01fQVJHVU1FTlRTID0gY3JlYXRlRkZtcGVnQXJncyh7XG4gIGFuYWx5emVkdXJhdGlvbjogJzAnLFxuICBsb2dsZXZlbDogJzAnLFxuICBmOiAnczE2bGUnLFxuICBhcjogJzQ4MDAwJyxcbiAgYWM6ICcyJ1xufSk7XG5cbmNvbnN0IEZGTVBFR19PUFVTX0FSR1VNRU5UUyA9IGNyZWF0ZUZGbXBlZ0FyZ3Moe1xuICBhbmFseXplZHVyYXRpb246ICcwJyxcbiAgbG9nbGV2ZWw6ICcwJyxcbiAgYWNvZGVjOiAnbGlib3B1cycsXG4gIGY6ICdvcHVzJyxcbiAgYXI6ICc0ODAwMCcsXG4gIGFjOiAnMidcbn0pO1xuXG4vKipcbiAqIFRoZSBkaWZmZXJlbnQgdHlwZXMgb2Ygc3RyZWFtIHRoYXQgY2FuIGV4aXN0IHdpdGhpbiB0aGUgcGlwZWxpbmUuXG4gKi9cbmV4cG9ydCBlbnVtIFN0cmVhbVR5cGUge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHN0cmVhbSBhdCB0aGlzIHBvaW50IGlzIHVua25vd24uXG4gICAqL1xuICBBcmJpdHJhcnkgPSAnYXJiaXRyYXJ5JyxcbiAgLyoqXG4gICAqIFRoZSBzdHJlYW0gYXQgdGhpcyBwb2ludCBpcyBPcHVzIGF1ZGlvIGVuY29kZWQgaW4gYW4gT2dnIHdyYXBwZXIuXG4gICAqL1xuICBPZ2dPcHVzID0gJ29nZy9vcHVzJyxcbiAgLyoqXG4gICAqIFRoZSBzdHJlYW0gYXQgdGhpcyBwb2ludCBpcyBPcHVzIGF1ZGlvLCBhbmQgdGhlIHN0cmVhbSBpcyBpbiBvYmplY3QtbW9kZS4gVGhpcyBpcyByZWFkeSB0byBwbGF5LlxuICAgKi9cbiAgT3B1cyA9ICdvcHVzJyxcbiAgLyoqXG4gICAqIFRoZSBzdHJlYW0gYXQgdGhpcyBwb2ludCBpcyBzMTZsZSBQQ00uXG4gICAqL1xuICBSYXcgPSAncmF3JyxcbiAgLyoqXG4gICAqIFRoZSBzdHJlYW0gYXQgdGhpcyBwb2ludCBpcyBPcHVzIGF1ZGlvIGVuY29kZWQgaW4gYSBXZWJNIHdyYXBwZXIuXG4gICAqL1xuICBXZWJtT3B1cyA9ICd3ZWJtL29wdXMnLFxufVxuXG4vKipcbiAqIFRoZSBkaWZmZXJlbnQgdHlwZXMgb2YgdHJhbnNmb3JtZXJzIHRoYXQgY2FuIGV4aXN0IHdpdGhpbiB0aGUgcGlwZWxpbmUuXG4gKi9cbmV4cG9ydCBlbnVtIFRyYW5zZm9ybWVyVHlwZSB7XG4gIEZGbXBlZ09nZyA9ICdmZm1wZWcgb2dnJyxcbiAgRkZtcGVnUENNID0gJ2ZmbXBlZyBwY20nLFxuICBJbmxpbmVWb2x1bWUgPSAndm9sdW1lIHRyYW5zZm9ybWVyJyxcbiAgT2dnT3B1c0RlbXV4ZXIgPSAnb2dnL29wdXMgZGVtdXhlcicsXG4gIE9wdXNEZWNvZGVyID0gJ29wdXMgZGVjb2RlcicsXG4gIE9wdXNFbmNvZGVyID0gJ29wdXMgZW5jb2RlcicsXG4gIFdlYm1PcHVzRGVtdXhlciA9ICd3ZWJtL29wdXMgZGVtdXhlcicsXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHBhdGh3YXkgZnJvbSBvbmUgc3RyZWFtIHR5cGUgdG8gYW5vdGhlciB1c2luZyBhIHRyYW5zZm9ybWVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVkZ2Uge1xuICBjb3N0OiBudW1iZXI7XG4gIGZyb206IE5vZGU7XG4gIHRvOiBOb2RlO1xuICB0cmFuc2Zvcm1lcihpbnB1dDogUmVhZGFibGUgfCBzdHJpbmcpOiBSZWFkYWJsZTtcbiAgdHlwZTogVHJhbnNmb3JtZXJUeXBlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0eXBlIG9mIHN0cmVhbSB3aXRoaW4gdGhlIGdyYXBoLCBlLmcuIGFuIE9wdXMgc3RyZWFtLCBvciBhIHN0cmVhbSBvZiByYXcgYXVkaW8uXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlIHtcbiAgLyoqXG4gICAqIFRoZSBvdXRib3VuZCBlZGdlcyBmcm9tIHRoaXMgbm9kZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBlZGdlczogRWRnZVtdID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHN0cmVhbSBmb3IgdGhpcyBub2RlLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHR5cGU6IFN0cmVhbVR5cGU7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHR5cGU6IFN0cmVhbVR5cGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb3V0Ym91bmQgZWRnZSBmcm9tIHRoaXMgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGVkZ2UgLSBUaGUgZWRnZSB0byBjcmVhdGVcbiAgICovXG4gIHB1YmxpYyBhZGRFZGdlKGVkZ2U6IE9taXQ8RWRnZSwgJ2Zyb20nPikge1xuICAgIHRoaXMuZWRnZXMucHVzaCh7IC4uLmVkZ2UsIGZyb206IHRoaXMgfSk7XG4gIH1cbn1cblxuLy8gQ3JlYXRlIGEgbm9kZSBmb3IgZWFjaCBzdHJlYW0gdHlwZVxubGV0IE5PREVTOiBNYXA8U3RyZWFtVHlwZSwgTm9kZT4gfCBudWxsID0gbnVsbDtcblxuZnVuY3Rpb24gY2FuRW5hYmxlRkZtcGVnT3B0aW1pemF0aW9ucygpOiBib29sZWFuIHtcbiAgcmV0dXJuIEZGbXBlZy5yZXNvbHZlU2FmZSgpPy5yZXN1bHQuaW5jbHVkZXMoJy0tZW5hYmxlLWxpYm9wdXMnKSA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIGEgbm9kZSBmcm9tIGl0cyBzdHJlYW0gdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSBzdHJlYW0gdHlwZSBvZiB0aGUgdGFyZ2V0IG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGUodHlwZTogU3RyZWFtVHlwZSkge1xuICBjb25zdCBub2RlID0gKE5PREVTID8/PSBpbml0aWFsaXplTm9kZXMoKSkuZ2V0KHR5cGUpO1xuICBpZiAoIW5vZGUpIHRocm93IG5ldyBFcnJvcihgTm9kZSB0eXBlICcke3R5cGV9JyBkb2VzIG5vdCBleGlzdCFgKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVOb2RlcygpOiBNYXA8U3RyZWFtVHlwZSwgTm9kZT4ge1xuICBjb25zdCBub2RlcyA9IG5ldyBNYXA8U3RyZWFtVHlwZSwgTm9kZT4oKTtcbiAgZm9yIChjb25zdCBzdHJlYW1UeXBlIG9mIE9iamVjdC52YWx1ZXMoU3RyZWFtVHlwZSkpIHtcbiAgICBub2Rlcy5zZXQoc3RyZWFtVHlwZSwgbmV3IE5vZGUoc3RyZWFtVHlwZSkpO1xuICB9XG5cbiAgbm9kZXMuZ2V0KFN0cmVhbVR5cGUuUmF3KSEuYWRkRWRnZSh7XG4gICAgdHlwZTogVHJhbnNmb3JtZXJUeXBlLk9wdXNFbmNvZGVyLFxuICAgIHRvOiBub2Rlcy5nZXQoU3RyZWFtVHlwZS5PcHVzKSEsXG4gICAgY29zdDogMS41LFxuICAgIHRyYW5zZm9ybWVyOiAoKSA9PlxuICAgIG5ldyBPcHVzRW5jb2Rlcih7IHJhdGU6IDQ4XzAwMCwgY2hhbm5lbHM6IDIsIGZyYW1lU2l6ZTogOTYwIH0pXG4gIH0pO1xuXG4gIG5vZGVzLmdldChTdHJlYW1UeXBlLk9wdXMpIS5hZGRFZGdlKHtcbiAgICB0eXBlOiBUcmFuc2Zvcm1lclR5cGUuT3B1c0RlY29kZXIsXG4gICAgdG86IG5vZGVzLmdldChTdHJlYW1UeXBlLlJhdykhLFxuICAgIGNvc3Q6IDEuNSxcbiAgICB0cmFuc2Zvcm1lcjogKCkgPT5cbiAgICBuZXcgT3B1c0RlY29kZXIoeyByYXRlOiA0OF8wMDAsIGNoYW5uZWxzOiAyLCBmcmFtZVNpemU6IDk2MCB9KVxuICB9KTtcblxuICBub2Rlcy5nZXQoU3RyZWFtVHlwZS5PZ2dPcHVzKSEuYWRkRWRnZSh7XG4gICAgdHlwZTogVHJhbnNmb3JtZXJUeXBlLk9nZ09wdXNEZW11eGVyLFxuICAgIHRvOiBub2Rlcy5nZXQoU3RyZWFtVHlwZS5PcHVzKSEsXG4gICAgY29zdDogMSxcbiAgICB0cmFuc2Zvcm1lcjogKCkgPT4gbmV3IE9nZ0RlbXV4ZXIoKVxuICB9KTtcblxuICBub2Rlcy5nZXQoU3RyZWFtVHlwZS5XZWJtT3B1cykhLmFkZEVkZ2Uoe1xuICAgIHR5cGU6IFRyYW5zZm9ybWVyVHlwZS5XZWJtT3B1c0RlbXV4ZXIsXG4gICAgdG86IG5vZGVzLmdldChTdHJlYW1UeXBlLk9wdXMpISxcbiAgICBjb3N0OiAxLFxuICAgIHRyYW5zZm9ybWVyOiAoKSA9PiBuZXcgV2VibURlbXV4ZXIoKVxuICB9KTtcblxuICBjb25zdCBGRk1QRUdfUENNX0VER0U6IE9taXQ8RWRnZSwgJ2Zyb20nPiA9IHtcbiAgICB0eXBlOiBUcmFuc2Zvcm1lclR5cGUuRkZtcGVnUENNLFxuICAgIHRvOiBub2Rlcy5nZXQoU3RyZWFtVHlwZS5SYXcpISxcbiAgICBjb3N0OiAyLFxuICAgIHRyYW5zZm9ybWVyOiAoaW5wdXQpID0+XG4gICAgbmV3IEZGbXBlZyh7XG4gICAgICBhcmdzOiBbXG4gICAgICAnLWknLFxuICAgICAgdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyA/IGlucHV0IDogJy0nLFxuICAgICAgLi4uRkZNUEVHX1BDTV9BUkdVTUVOVFNdXG5cbiAgICB9KVxuICB9O1xuXG4gIG5vZGVzLmdldChTdHJlYW1UeXBlLkFyYml0cmFyeSkhLmFkZEVkZ2UoRkZNUEVHX1BDTV9FREdFKTtcbiAgbm9kZXMuZ2V0KFN0cmVhbVR5cGUuT2dnT3B1cykhLmFkZEVkZ2UoRkZNUEVHX1BDTV9FREdFKTtcbiAgbm9kZXMuZ2V0KFN0cmVhbVR5cGUuV2VibU9wdXMpIS5hZGRFZGdlKEZGTVBFR19QQ01fRURHRSk7XG5cbiAgbm9kZXMuZ2V0KFN0cmVhbVR5cGUuUmF3KSEuYWRkRWRnZSh7XG4gICAgdHlwZTogVHJhbnNmb3JtZXJUeXBlLklubGluZVZvbHVtZSxcbiAgICB0bzogbm9kZXMuZ2V0KFN0cmVhbVR5cGUuUmF3KSEsXG4gICAgY29zdDogMC41LFxuICAgIHRyYW5zZm9ybWVyOiAoKSA9PiBuZXcgVm9sdW1lVHJhbnNmb3JtZXIoeyB0eXBlOiAnczE2bGUnIH0pXG4gIH0pO1xuXG4gIGlmIChjYW5FbmFibGVGRm1wZWdPcHRpbWl6YXRpb25zKCkpIHtcbiAgICBjb25zdCBGRk1QRUdfT0dHX0VER0U6IE9taXQ8RWRnZSwgJ2Zyb20nPiA9IHtcbiAgICAgIHR5cGU6IFRyYW5zZm9ybWVyVHlwZS5GRm1wZWdPZ2csXG4gICAgICB0bzogbm9kZXMuZ2V0KFN0cmVhbVR5cGUuT2dnT3B1cykhLFxuICAgICAgY29zdDogMixcbiAgICAgIHRyYW5zZm9ybWVyOiAoaW5wdXQpID0+XG4gICAgICBuZXcgRkZtcGVnKHtcbiAgICAgICAgYXJnczogW1xuICAgICAgICAnLWknLFxuICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gaW5wdXQgOiAnLScsXG4gICAgICAgIC4uLkZGTVBFR19PUFVTX0FSR1VNRU5UU11cblxuICAgICAgfSlcbiAgICB9O1xuICAgIG5vZGVzLmdldChTdHJlYW1UeXBlLkFyYml0cmFyeSkhLmFkZEVkZ2UoRkZNUEVHX09HR19FREdFKTtcbiAgICAvLyBJbmNsdWRlIE9nZyBhbmQgV2ViTSBhcyB3ZWxsIGluIGNhc2UgdGhleSBoYXZlIGRpZmZlcmVudCBzYW1wbGluZyByYXRlcyBvciBhcmUgbW9ubyBpbnN0ZWFkIG9mIHN0ZXJlb1xuICAgIC8vIGF0IHRoZSBtb21lbnQsIHRoaXMgd2lsbCBub3QgZG8gYW55dGhpbmcuIEhvd2V2ZXIsIGlmL3doZW4gZGV0ZWN0aW9uIGZvciBjb3JyZWN0IE9wdXMgaGVhZGVycyBpc1xuICAgIC8vIGltcGxlbWVudGVkLCB0aGlzIHdpbGwgaGVscCBpbmZvcm0gdGhlIHZvaWNlIGVuZ2luZSB0aGF0IGl0IGlzIGFibGUgdG8gdHJhbnNjb2RlIHRoZSBhdWRpby5cbiAgICBub2Rlcy5nZXQoU3RyZWFtVHlwZS5PZ2dPcHVzKSEuYWRkRWRnZShGRk1QRUdfT0dHX0VER0UpO1xuICAgIG5vZGVzLmdldChTdHJlYW1UeXBlLldlYm1PcHVzKSEuYWRkRWRnZShGRk1QRUdfT0dHX0VER0UpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdGVwIGluIHRoZSBwYXRoIGZyb20gbm9kZSBBIHRvIG5vZGUgQi5cbiAqL1xuaW50ZXJmYWNlIFN0ZXAge1xuICAvKipcbiAgICogVGhlIGNvc3Qgb2YgdGhlIHN0ZXBzIGFmdGVyIHRoaXMgc3RlcC5cbiAgICovXG4gIGNvc3Q6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIGVkZ2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RlcC5cbiAgICovXG4gIGVkZ2U/OiBFZGdlO1xuXG4gIC8qKlxuICAgKiBUaGUgbmV4dCBzdGVwLlxuICAgKi9cbiAgbmV4dD86IFN0ZXA7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHNob3J0ZXN0IGNvc3QgcGF0aCBmcm9tIG5vZGUgQSB0byBub2RlIEIuXG4gKlxuICogQHBhcmFtIGZyb20gLSBUaGUgc3RhcnQgbm9kZVxuICogQHBhcmFtIGNvbnN0cmFpbnRzIC0gRXh0cmEgdmFsaWRhdGlvbiBmb3IgYSBwb3RlbnRpYWwgc29sdXRpb24uIFRha2VzIGEgcGF0aCwgcmV0dXJucyB0cnVlIGlmIHRoZSBwYXRoIGlzIHZhbGlkXG4gKiBAcGFyYW0gZ29hbCAtIFRoZSB0YXJnZXQgbm9kZVxuICogQHBhcmFtIHBhdGggLSBUaGUgcnVubmluZyBwYXRoXG4gKiBAcGFyYW0gZGVwdGggLSBUaGUgbnVtYmVyIG9mIHJlbWFpbmluZyByZWN1cnNpb25zXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXRoKFxuZnJvbTogTm9kZSxcbmNvbnN0cmFpbnRzOiAocGF0aDogRWRnZVtdKSA9PiBib29sZWFuLFxuZ29hbCA9IGdldE5vZGUoU3RyZWFtVHlwZS5PcHVzKSxcbnBhdGg6IEVkZ2VbXSA9IFtdLFxuZGVwdGggPSA1KVxuOiBTdGVwIHtcbiAgaWYgKGZyb20gPT09IGdvYWwgJiYgY29uc3RyYWludHMocGF0aCkpIHtcbiAgICByZXR1cm4geyBjb3N0OiAwIH07XG4gIH0gZWxzZSBpZiAoZGVwdGggPT09IDApIHtcbiAgICByZXR1cm4geyBjb3N0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfTtcbiAgfVxuXG4gIGxldCBjdXJyZW50QmVzdDogU3RlcCB8IHVuZGVmaW5lZDtcbiAgZm9yIChjb25zdCBlZGdlIG9mIGZyb20uZWRnZXMpIHtcbiAgICBpZiAoY3VycmVudEJlc3QgJiYgZWRnZS5jb3N0ID4gY3VycmVudEJlc3QuY29zdCkgY29udGludWU7XG4gICAgY29uc3QgbmV4dCA9IGZpbmRQYXRoKFxuICAgICAgZWRnZS50byxcbiAgICAgIGNvbnN0cmFpbnRzLFxuICAgICAgZ29hbCxcbiAgICAgIFsuLi5wYXRoLCBlZGdlXSxcbiAgICAgIGRlcHRoIC0gMVxuICAgICk7XG4gICAgY29uc3QgY29zdCA9IGVkZ2UuY29zdCArIG5leHQuY29zdDtcbiAgICBpZiAoIWN1cnJlbnRCZXN0IHx8IGNvc3QgPCBjdXJyZW50QmVzdC5jb3N0KSB7XG4gICAgICBjdXJyZW50QmVzdCA9IHsgY29zdCwgZWRnZSwgbmV4dCB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50QmVzdCA/PyB7IGNvc3Q6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9O1xufVxuXG4vKipcbiAqIFRha2VzIHRoZSBzb2x1dGlvbiBmcm9tIGZpbmRQYXRoIGFuZCBhc3NlbWJsZXMgaXQgaW50byBhIGxpc3Qgb2YgZWRnZXMuXG4gKlxuICogQHBhcmFtIHN0ZXAgLSBUaGUgZmlyc3Qgc3RlcCBvZiB0aGUgcGF0aFxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RQaXBlbGluZShzdGVwOiBTdGVwKSB7XG4gIGNvbnN0IGVkZ2VzOiBFZGdlW10gPSBbXTtcbiAgbGV0IGN1cnJlbnQ6IFN0ZXAgfCB1bmRlZmluZWQgPSBzdGVwO1xuICB3aGlsZSAoY3VycmVudD8uZWRnZSkge1xuICAgIGVkZ2VzLnB1c2goY3VycmVudC5lZGdlKTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIGVkZ2VzO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBsb3dlc3QtY29zdCBwaXBlbGluZSB0byBjb252ZXJ0IHRoZSBpbnB1dCBzdHJlYW0gdHlwZSBpbnRvIGFuIE9wdXMgc3RyZWFtLlxuICpcbiAqIEBwYXJhbSBmcm9tIC0gVGhlIHN0cmVhbSB0eXBlIHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSBjb25zdHJhaW50IC0gRXh0cmEgY29uc3RyYWludHMgdGhhdCBtYXkgYmUgaW1wb3NlZCBvbiBwb3RlbnRpYWwgc29sdXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQaXBlbGluZShcbmZyb206IFN0cmVhbVR5cGUsXG5jb25zdHJhaW50OiAocGF0aDogRWRnZVtdKSA9PiBib29sZWFuKVxue1xuICByZXR1cm4gY29uc3RydWN0UGlwZWxpbmUoZmluZFBhdGgoZ2V0Tm9kZShmcm9tKSwgY29uc3RyYWludCkpO1xufSIsICIvLyBDb3B5cmlnaHQgZGlzY29yZC1wbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIExpY2Vuc2UuXG4vLyBDb3B5cmlnaHQgZGlzY29yZC5qcyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBBcGFjaGUgTGljZW5zZSAyLjBcblxuaW1wb3J0IHsgdHlwZSBFdmVudEVtaXR0ZXIsIG9uY2UgfSBmcm9tICdub2RlOmV2ZW50cyc7XG5pbXBvcnQgdHlwZSB7XG4gIFZvaWNlQ29ubmVjdGlvbixcbiAgVm9pY2VDb25uZWN0aW9uU3RhdHVzIH0gZnJvbVxuJy4uL1ZvaWNlQ29ubmVjdGlvbic7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvUGxheWVyLCBBdWRpb1BsYXllclN0YXR1cyB9IGZyb20gJy4uL2F1ZGlvL0F1ZGlvUGxheWVyJztcbmltcG9ydCB7IGFib3J0QWZ0ZXIgfSBmcm9tICcuL2Fib3J0QWZ0ZXInO1xuXG4vKipcbiAqIEFsbG93cyBhIHZvaWNlIGNvbm5lY3Rpb24gYSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgdG8gZW50ZXIgYSBnaXZlbiBzdGF0ZSwgb3RoZXJ3aXNlIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHZvaWNlIGNvbm5lY3Rpb24gdGhhdCB3ZSB3YW50IHRvIG9ic2VydmUgdGhlIHN0YXRlIGNoYW5nZSBmb3JcbiAqIEBwYXJhbSBzdGF0dXMgLSBUaGUgc3RhdHVzIHRoYXQgdGhlIHZvaWNlIGNvbm5lY3Rpb24gc2hvdWxkIGJlIGluXG4gKiBAcGFyYW0gdGltZW91dE9yU2lnbmFsIC0gVGhlIG1heGltdW0gdGltZSB3ZSBhcmUgYWxsb3dpbmcgZm9yIHRoaXMgdG8gb2NjdXIsIG9yIGEgc2lnbmFsIHRoYXQgd2lsbCBhYm9ydCB0aGUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnRlcnNTdGF0ZShcbnRhcmdldDogVm9pY2VDb25uZWN0aW9uLFxuc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMsXG50aW1lb3V0T3JTaWduYWw6IEFib3J0U2lnbmFsIHwgbnVtYmVyKVxuOiBQcm9taXNlPFZvaWNlQ29ubmVjdGlvbj47XG5cbi8qKlxuICogQWxsb3dzIGFuIGF1ZGlvIHBsYXllciBhIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSB0byBlbnRlciBhIGdpdmVuIHN0YXRlLCBvdGhlcndpc2UgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgYXVkaW8gcGxheWVyIHRoYXQgd2Ugd2FudCB0byBvYnNlcnZlIHRoZSBzdGF0ZSBjaGFuZ2UgZm9yXG4gKiBAcGFyYW0gc3RhdHVzIC0gVGhlIHN0YXR1cyB0aGF0IHRoZSBhdWRpbyBwbGF5ZXIgc2hvdWxkIGJlIGluXG4gKiBAcGFyYW0gdGltZW91dE9yU2lnbmFsIC0gVGhlIG1heGltdW0gdGltZSB3ZSBhcmUgYWxsb3dpbmcgZm9yIHRoaXMgdG8gb2NjdXIsIG9yIGEgc2lnbmFsIHRoYXQgd2lsbCBhYm9ydCB0aGUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnRlcnNTdGF0ZShcbnRhcmdldDogQXVkaW9QbGF5ZXIsXG5zdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLFxudGltZW91dE9yU2lnbmFsOiBBYm9ydFNpZ25hbCB8IG51bWJlcilcbjogUHJvbWlzZTxBdWRpb1BsYXllcj47XG5cbi8qKlxuICogQWxsb3dzIGEgdGFyZ2V0IGEgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIHRvIGVudGVyIGEgZ2l2ZW4gc3RhdGUsIG90aGVyd2lzZSByZWplY3RzIHdpdGggYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSBvYmplY3QgdGhhdCB3ZSB3YW50IHRvIG9ic2VydmUgdGhlIHN0YXRlIGNoYW5nZSBmb3JcbiAqIEBwYXJhbSBzdGF0dXMgLSBUaGUgc3RhdHVzIHRoYXQgdGhlIHRhcmdldCBzaG91bGQgYmUgaW5cbiAqIEBwYXJhbSB0aW1lb3V0T3JTaWduYWwgLSBUaGUgbWF4aW11bSB0aW1lIHdlIGFyZSBhbGxvd2luZyBmb3IgdGhpcyB0byBvY2N1ciwgb3IgYSBzaWduYWwgdGhhdCB3aWxsIGFib3J0IHRoZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVudGVyc1N0YXRlPFRhcmdldCBleHRlbmRzIEF1ZGlvUGxheWVyIHwgVm9pY2VDb25uZWN0aW9uPihcbnRhcmdldDogVGFyZ2V0LFxuc3RhdHVzOiBBdWRpb1BsYXllclN0YXR1cyB8IFZvaWNlQ29ubmVjdGlvblN0YXR1cyxcbnRpbWVvdXRPclNpZ25hbDogQWJvcnRTaWduYWwgfCBudW1iZXIpXG57XG4gIGlmICh0YXJnZXQuc3RhdGUuc3RhdHVzICE9PSBzdGF0dXMpIHtcbiAgICBjb25zdCBbYWMsIHNpZ25hbF0gPVxuICAgIHR5cGVvZiB0aW1lb3V0T3JTaWduYWwgPT09ICdudW1iZXInID9cbiAgICBhYm9ydEFmdGVyKHRpbWVvdXRPclNpZ25hbCkgOlxuICAgIFt1bmRlZmluZWQsIHRpbWVvdXRPclNpZ25hbF07XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG9uY2UodGFyZ2V0IGFzIEV2ZW50RW1pdHRlciwgc3RhdHVzLCB7IHNpZ25hbCB9KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYWM/LmFib3J0KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCAiLy8gQ29weXJpZ2h0IGRpc2NvcmQtcGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBMaWNlbnNlLlxuLy8gQ29weXJpZ2h0IGRpc2NvcmQuanMgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gQXBhY2hlIExpY2Vuc2UgMi4wXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhYm9ydCBjb250cm9sbGVyIHRoYXQgYWJvcnRzIGFmdGVyIHRoZSBnaXZlbiB0aW1lLlxuICpcbiAqIEBwYXJhbSBkZWxheSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhYm9ydGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRBZnRlcihkZWxheTogbnVtYmVyKTogW0Fib3J0Q29udHJvbGxlciwgQWJvcnRTaWduYWxdIHtcbiAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGFjLmFib3J0KCksIGRlbGF5KTtcbiAgYWMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpKTtcbiAgcmV0dXJuIFthYywgYWMuc2lnbmFsXTtcbn0iLCAiXG5cblxuXG5cblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAvKiBAX19NQUNST19fIGdldFZlcnNpb24gKi9cIjcuMS4wXCI7Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQ01BLElBQUFBLHNCQUE2Qjs7O0FDSDdCLGlCQUErQjtBQWtCeEIsU0FBUyw4QkFBOEIsUUFBb0I7QUFDaEUsU0FBTztBQUFBLElBQ0wsSUFBSSwwQkFBZTtBQUFBO0FBQUEsSUFFbkIsR0FBRztBQUFBLE1BQ0QsVUFBVSxPQUFPO0FBQUEsTUFDakIsWUFBWSxPQUFPO0FBQUEsTUFDbkIsV0FBVyxPQUFPO0FBQUEsTUFDbEIsV0FBVyxPQUFPO0FBQUEsSUFDcEI7QUFBQSxFQUNGO0FBQ0Y7QUFYZ0I7QUFjaEIsSUFBTSxTQUFTLG9CQUFJLElBQTBDO0FBQzdELE9BQU8sSUFBSSxXQUFXLG9CQUFJLElBQUksQ0FBQztBQUUvQixTQUFTLGlCQUFpQixPQUFl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QU8sQ0FBQztBQUMvRCxTQUFPLENBQUMsSUFBSSxHQUFHLE1BQU07QUFDdkI7QUFMZ0I7OztBRG9DaEIsZUFBc0IsWUFDdEIsUUFDQSxRQUNBLGlCQUNBO0FBQ0UsTUFBSSxPQUFPLE1BQU0sV0FBVyxRQUFRO0FBQ2xDLFVBQU0sQ0FBQyxJQUFJLE1BQU0sSUFDakIsT0FBTyxvQkFBb0IsV0FDM0IsV0FBVyxlQUFlLElBQzFCLENBQUMsUUFBVyxlQUFlO0FBQzNCLFFBQUk7QUFDRixnQkFBTSwwQkFBSyxRQUF3QixRQUFRLEVBQUUsT0FBTyxDQUFDO0FBQUEsSUFDdkQsVUFBRTtBQUNBLFVBQUksTUFBTTtBQUFBLElBQ1o7QUFBQSxFQUNGO0FBRUEsU0FBTztBQUNUO0FBbEJzQjs7O0FFdENmLElBQU07QUFBQTtBQUFBLEVBQXFDO0FBQUE7IiwKICAibmFtZXMiOiBbImltcG9ydF9ub2RlX2V2ZW50cyIsICJpbXBvcnRfbm9kZV9idWZmZXIiLCAiaW1wb3J0X25vZGVfZXZlbnRzIiwgImltcG9ydF92NCIsICJub25jZSIsICJjcnlwdG8iLCAiaW1wb3J0X25vZGVfYnVmZmVyIiwgImltcG9ydF9ub2RlX2V2ZW50cyIsICJub25jZSIsICJjcnlwdG8iLCAib3B0aW9uIiwgImNyeXB0byIsICJWb2ljZUNvbm5lY3Rpb25TdGF0dXMiLCAiVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdFJlYXNvbiIsICJpbXBvcnRfbm9kZV9idWZmZXIiLCAiaW1wb3J0X25vZGVfZXZlbnRzIiwgIk5vU3Vic2NyaWJlckJlaGF2aW9yIiwgIkF1ZGlvUGxheWVyU3RhdHVzIiwgInN0cmluZ2lmeVN0YXRlIiwgIlN0cmVhbVR5cGUiLCAiaW1wb3J0X29wdXMiLCAiaW1wb3J0X2VxdWFsaXplciIsICJpbXBvcnRfbm9kZV9ldmVudHMiXQp9Cg==